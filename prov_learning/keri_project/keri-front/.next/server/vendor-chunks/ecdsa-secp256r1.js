/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ecdsa-secp256r1";
exports.ids = ["vendor-chunks/ecdsa-secp256r1"];
exports.modules = {

/***/ "(ssr)/./node_modules/ecdsa-secp256r1/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ecdsa-secp256r1/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const crypto = __webpack_require__(/*! crypto */ \"crypto\")\n\nconst asn = __webpack_require__(/*! asn1.js */ \"(ssr)/./node_modules/asn1.js/lib/asn1.js\")\nconst BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\")\n\n/* ========================================================================== *\n * From RFC-4492 (Appendix A) Equivalent Curves (Informative)                 *\n * ========================================================================== *\n *                                                                            *\n * +------------------------------------------------------------------------+ *\n * |                         Curve names chosen by                          | *\n * |                   different standards organizations                    | *\n * +-----------+------------+------------+------------+---------------------+ *\n * |   SECG    | ANSI X9.62 |    NIST    |  OpenSSL   |      ASN.1 OID      | *\n * +-----------+------------+------------+------------+---------------------+ *\n * | secp256r1 | prime256v1 | NIST P-256 | prime256v1 | 1.2.840.10045.3.1.7 | *\n * +-----------+------------+------------+------------+---------------------+ *\n * ========================================================================== */\n\nconst curve = 'prime256v1' /* OpenSSL curve name */\nconst jwkCurve = 'P-256' /* JWK curve name */\nconst curveLength = Math.ceil(256 / 8) /* Byte length for validation */\n\n/* ========================================================================== *\n * CLASS DEFINITION                                                           *\n * ========================================================================== */\n\nfunction ECDSA({ x, y, d }) {\n  if (x.length !== curveLength) throw new TypeError('Public EC Key point X of wrong length')\n  if (y.length !== curveLength) throw new TypeError('Public EC Key point Y of wrong length')\n\n  this.x = x\n  this.y = y\n  this.publicCodePoint = Buffer.concat([Buffer.from([0x04]), x, y])\n  if (d) {\n    this.d = d\n    this.isPrivate = true\n  } else {\n    this.isPrivate = false\n  }\n}\n\n/* ========================================================================== *\n * FACTORIES                                                                  *\n * ========================================================================== */\n\nECDSA.generateKey = function generateKeys() {\n  const ecdh = crypto.createECDH(curve)\n  ecdh.generateKeys()\n\n  return new ECDSA({\n    d: ecdh.getPrivateKey(),\n    x: ecdh.getPublicKey().slice(1, curveLength + 1),\n    y: ecdh.getPublicKey().slice(curveLength + 1)\n  })\n}\n\nECDSA.fromJWK = function fromJWK(jwk) {\n  return new ECDSA({\n    x: Buffer.from(jwk.x, 'base64'),\n    y: Buffer.from(jwk.y, 'base64'),\n    d: jwk.d ? Buffer.from(jwk.d, 'base64') : false\n  })\n}\n\nECDSA.fromCompressedPublicKey = function fromCompressedPublicKey(compressedKey, format = 'base64') {\n  const key = crypto.ECDH.convertKey(compressedKey, curve, format, 'base64', 'uncompressed')\n  const keyBuffer = Buffer.from(key, 'base64')\n  return new ECDSA({\n    x: keyBuffer.slice(1, curveLength + 1),\n    y: keyBuffer.slice(curveLength + 1)\n  })\n}\n\n/* ========================================================================== *\n * ASN.1                                                                      *\n * ========================================================================== */\n\nconst ASN1 = {\n  Rfc5915: asn.define('Rfc5915Key', function() {\n    this.seq().obj(\n      this.key('version').int(),\n      this.key('privateKey').octstr(),\n      this.key('parameters')\n        .optional()\n        .explicit(0)\n        .objid({\n          '1 2 840 10045 3 1 7': 'prime256v1',\n          '1 3 132 0 10': 'secp256k1',\n          '1 3 132 0 34': 'secp384r1',\n          '1 3 132 0 35': 'secp521r1'\n        }),\n      this.key('publicKey')\n        .optional()\n        .explicit(1)\n        .bitstr()\n    )\n  }),\n  Pkcs8: asn.define('Pkcs8Key', function() {\n    this.seq().obj(\n      this.key('version').int(),\n      this.key('algorithmIdentifier')\n        .seq()\n        .obj(\n          this.key('privateKeyType').objid({\n            '1 2 840 10045 2 1': 'EC'\n          }),\n          this.key('parameters').objid({\n            '1 2 840 10045 3 1 7': 'prime256v1',\n            '1 3 132 0 10': 'secp256k1',\n            '1 3 132 0 34': 'secp384r1',\n            '1 3 132 0 35': 'secp521r1'\n          })\n        ),\n      this.key('privateKey').octstr()\n    )\n  }),\n  Spki: asn.define('SpkiKey', function() {\n    this.seq().obj(\n      this.key('algorithmIdentifier')\n        .seq()\n        .obj(\n          this.key('publicKeyType').objid({\n            '1 2 840 10045 2 1': 'EC'\n          }),\n          this.key('parameters').objid({\n            '1 2 840 10045 3 1 7': 'prime256v1',\n            '1 3 132 0 10': 'secp256k1',\n            '1 3 132 0 34': 'secp384r1',\n            '1 3 132 0 35': 'secp521r1'\n          })\n        ),\n      this.key('publicKey').bitstr()\n    )\n  }),\n  EcdsaDerSig: asn.define('ECPrivateKey', function() {\n    return this.seq().obj(this.key('r').int(), this.key('s').int())\n  })\n}\n\n/* ========================================================================== *\n * SIGNING / VALIDATION                                                       *\n * ========================================================================== */\n\nfunction hash(object) {\n  return crypto\n    .createHash('sha256')\n    .update(typeof object === 'string' ? object : JSON.stringify(object))\n    .digest('base64')\n}\n\nECDSA.prototype.sign = function sign(message, format = 'base64') {\n  function removeDerEncoding(signatureBuffer) {\n    const { r, s } = ASN1.EcdsaDerSig.decode(signatureBuffer, 'der')\n    return Buffer.concat([r.toBuffer(), s.toBuffer()]).toString(format)\n  }\n\n  if (!this.isPrivate) throw new Error('EC Private Key needed to sign')\n  const sign = crypto.createSign('RSA-SHA256') // RSA works with EC keys, too\n  sign.write(message)\n  sign.end()\n  return removeDerEncoding(sign.sign(this.toPEM()))\n}\n\nECDSA.prototype.hashAndSign = async function hashAndSign(message, format = 'base64') {\n  return this.sign(await hash(message), format)\n}\n\nECDSA.prototype.verify = function verify(message, signature, format = 'base64') {\n  function signatureToDer(signatureBuffer) {\n    const r = new BN(signatureBuffer.slice(0, curveLength).toString('hex'), 16, 'be')\n    const s = new BN(signatureBuffer.slice(curveLength).toString('hex'), 16, 'be')\n    return ASN1.EcdsaDerSig.encode({ r, s }, 'der')\n  }\n\n  const verify = crypto.createVerify('RSA-SHA256') // RSA works with EC keys, too\n  verify.write(message)\n  verify.end()\n  const key = this.isPrivate ? this.asPublic() : this\n  const signatureBuffer = Buffer.from(signature, format)\n  return verify.verify(\n    key.toPEM(),\n    signatureBuffer.length <= 2 * curveLength ? signatureToDer(signatureBuffer) : signatureBuffer,\n    format\n  )\n}\n\nECDSA.prototype.hashAndVerify = async function hashAndVerify(\n  message,\n  signature,\n  format = 'base64'\n) {\n  return this.verify(await hash(message), signature, format)\n}\n\n/* ========================================================================== *\n * CONVERSION                                                                 *\n * ========================================================================== */\n\nECDSA.prototype.asPublic = function asPublic() {\n  if (!this.isPrivate) return this\n  return new ECDSA({ x: this.x, y: this.y })\n}\n\nECDSA.prototype.toCompressedPublicKey = function toCompressedPublicKey(format = 'base64') {\n  return crypto.ECDH.convertKey(this.publicCodePoint, curve, 'base64', format, 'compressed')\n}\n\nECDSA.prototype.toBuffer = function toBuffer(format) {\n  if (format === 'pem') {\n    return Buffer.from(this.toPEM(), 'ascii')\n  } else if (this.isPrivate) {\n    // Strip leading zeroes from private key\n    let d = this.d\n    while (d[0] === 0) d = d.slice(1)\n\n    // Encode in PKCS8\n    return ASN1.Pkcs8.encode(\n      {\n        version: 0,\n        algorithmIdentifier: {\n          privateKeyType: 'EC',\n          parameters: curve\n        },\n        // Private key is RFC5915 minus curve\n        privateKey: ASN1.Rfc5915.encode(\n          {\n            version: 1,\n            privateKey: d,\n            publicKey: { data: this.publicCodePoint }\n          },\n          'der'\n        )\n      },\n      'der'\n    )\n  } else {\n    return ASN1.Spki.encode(\n      {\n        algorithmIdentifier: {\n          publicKeyType: 'EC',\n          parameters: curve\n        },\n        publicKey: { data: this.publicCodePoint }\n      },\n      'der'\n    )\n  }\n}\n\nECDSA.prototype.toPEM = function toPEM() {\n  return this.isPrivate\n    ? '-----BEGIN PRIVATE KEY-----\\n' +\n        this.toBuffer('pkcs8')\n          .toString('base64')\n          .match(/.{1,64}/g)\n          .join('\\n') +\n        '\\n-----END PRIVATE KEY-----\\n'\n    : '-----BEGIN PUBLIC KEY-----\\n' +\n        this.toBuffer('spki')\n          .toString('base64')\n          .match(/.{1,64}/g)\n          .join('\\n') +\n        '\\n-----END PUBLIC KEY-----\\n'\n}\n\nECDSA.prototype.toJWK = function toJWK() {\n  function urlsafe(buffer) {\n    return buffer\n      .toString('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '')\n  }\n\n  const jwk = {\n    kty: 'EC',\n    crv: jwkCurve,\n    x: urlsafe(this.x),\n    y: urlsafe(this.y)\n  }\n\n  if (this.isPrivate) {\n    let d = this.d\n    if (d.length < curveLength) {\n      const remaining = curveLength - d.length\n      d = Buffer.concat([Buffer.alloc(remaining).fill(0), d])\n    }\n    jwk.d = urlsafe(d)\n  }\n\n  return jwk\n}\n\n/* ========================================================================== *\n * EXPORTS                                                                    *\n * ========================================================================== */\n\nmodule.exports = ECDSA\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWNkc2Etc2VjcDI1NnIxL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0IsWUFBWSxtQkFBTyxDQUFDLHlEQUFTO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxtREFBTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQjtBQUNyQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9lY2RzYS1zZWNwMjU2cjEvaW5kZXguanM/ZjFjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5jb25zdCBhc24gPSByZXF1aXJlKCdhc24xLmpzJylcbmNvbnN0IEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqXG4gKiBGcm9tIFJGQy00NDkyIChBcHBlbmRpeCBBKSBFcXVpdmFsZW50IEN1cnZlcyAoSW5mb3JtYXRpdmUpICAgICAgICAgICAgICAgICAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnZlIG5hbWVzIGNob3NlbiBieSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAqXG4gKiB8ICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudCBzdGFuZGFyZHMgb3JnYW5pemF0aW9ucyAgICAgICAgICAgICAgICAgICAgfCAqXG4gKiArLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqXG4gKiB8ICAgU0VDRyAgICB8IEFOU0kgWDkuNjIgfCAgICBOSVNUICAgIHwgIE9wZW5TU0wgICB8ICAgICAgQVNOLjEgT0lEICAgICAgfCAqXG4gKiArLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqXG4gKiB8IHNlY3AyNTZyMSB8IHByaW1lMjU2djEgfCBOSVNUIFAtMjU2IHwgcHJpbWUyNTZ2MSB8IDEuMi44NDAuMTAwNDUuMy4xLjcgfCAqXG4gKiArLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5jb25zdCBjdXJ2ZSA9ICdwcmltZTI1NnYxJyAvKiBPcGVuU1NMIGN1cnZlIG5hbWUgKi9cbmNvbnN0IGp3a0N1cnZlID0gJ1AtMjU2JyAvKiBKV0sgY3VydmUgbmFtZSAqL1xuY29uc3QgY3VydmVMZW5ndGggPSBNYXRoLmNlaWwoMjU2IC8gOCkgLyogQnl0ZSBsZW5ndGggZm9yIHZhbGlkYXRpb24gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKlxuICogQ0xBU1MgREVGSU5JVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuZnVuY3Rpb24gRUNEU0EoeyB4LCB5LCBkIH0pIHtcbiAgaWYgKHgubGVuZ3RoICE9PSBjdXJ2ZUxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVibGljIEVDIEtleSBwb2ludCBYIG9mIHdyb25nIGxlbmd0aCcpXG4gIGlmICh5Lmxlbmd0aCAhPT0gY3VydmVMZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmxpYyBFQyBLZXkgcG9pbnQgWSBvZiB3cm9uZyBsZW5ndGgnKVxuXG4gIHRoaXMueCA9IHhcbiAgdGhpcy55ID0geVxuICB0aGlzLnB1YmxpY0NvZGVQb2ludCA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFsweDA0XSksIHgsIHldKVxuICBpZiAoZCkge1xuICAgIHRoaXMuZCA9IGRcbiAgICB0aGlzLmlzUHJpdmF0ZSA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzUHJpdmF0ZSA9IGZhbHNlXG4gIH1cbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKlxuICogRkFDVE9SSUVTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuRUNEU0EuZ2VuZXJhdGVLZXkgPSBmdW5jdGlvbiBnZW5lcmF0ZUtleXMoKSB7XG4gIGNvbnN0IGVjZGggPSBjcnlwdG8uY3JlYXRlRUNESChjdXJ2ZSlcbiAgZWNkaC5nZW5lcmF0ZUtleXMoKVxuXG4gIHJldHVybiBuZXcgRUNEU0Eoe1xuICAgIGQ6IGVjZGguZ2V0UHJpdmF0ZUtleSgpLFxuICAgIHg6IGVjZGguZ2V0UHVibGljS2V5KCkuc2xpY2UoMSwgY3VydmVMZW5ndGggKyAxKSxcbiAgICB5OiBlY2RoLmdldFB1YmxpY0tleSgpLnNsaWNlKGN1cnZlTGVuZ3RoICsgMSlcbiAgfSlcbn1cblxuRUNEU0EuZnJvbUpXSyA9IGZ1bmN0aW9uIGZyb21KV0soandrKSB7XG4gIHJldHVybiBuZXcgRUNEU0Eoe1xuICAgIHg6IEJ1ZmZlci5mcm9tKGp3ay54LCAnYmFzZTY0JyksXG4gICAgeTogQnVmZmVyLmZyb20oandrLnksICdiYXNlNjQnKSxcbiAgICBkOiBqd2suZCA/IEJ1ZmZlci5mcm9tKGp3ay5kLCAnYmFzZTY0JykgOiBmYWxzZVxuICB9KVxufVxuXG5FQ0RTQS5mcm9tQ29tcHJlc3NlZFB1YmxpY0tleSA9IGZ1bmN0aW9uIGZyb21Db21wcmVzc2VkUHVibGljS2V5KGNvbXByZXNzZWRLZXksIGZvcm1hdCA9ICdiYXNlNjQnKSB7XG4gIGNvbnN0IGtleSA9IGNyeXB0by5FQ0RILmNvbnZlcnRLZXkoY29tcHJlc3NlZEtleSwgY3VydmUsIGZvcm1hdCwgJ2Jhc2U2NCcsICd1bmNvbXByZXNzZWQnKVxuICBjb25zdCBrZXlCdWZmZXIgPSBCdWZmZXIuZnJvbShrZXksICdiYXNlNjQnKVxuICByZXR1cm4gbmV3IEVDRFNBKHtcbiAgICB4OiBrZXlCdWZmZXIuc2xpY2UoMSwgY3VydmVMZW5ndGggKyAxKSxcbiAgICB5OiBrZXlCdWZmZXIuc2xpY2UoY3VydmVMZW5ndGggKyAxKVxuICB9KVxufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqXG4gKiBBU04uMSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5jb25zdCBBU04xID0ge1xuICBSZmM1OTE1OiBhc24uZGVmaW5lKCdSZmM1OTE1S2V5JywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKSxcbiAgICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJylcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmV4cGxpY2l0KDApXG4gICAgICAgIC5vYmppZCh7XG4gICAgICAgICAgJzEgMiA4NDAgMTAwNDUgMyAxIDcnOiAncHJpbWUyNTZ2MScsXG4gICAgICAgICAgJzEgMyAxMzIgMCAxMCc6ICdzZWNwMjU2azEnLFxuICAgICAgICAgICcxIDMgMTMyIDAgMzQnOiAnc2VjcDM4NHIxJyxcbiAgICAgICAgICAnMSAzIDEzMiAwIDM1JzogJ3NlY3A1MjFyMSdcbiAgICAgICAgfSksXG4gICAgICB0aGlzLmtleSgncHVibGljS2V5JylcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmV4cGxpY2l0KDEpXG4gICAgICAgIC5iaXRzdHIoKVxuICAgIClcbiAgfSksXG4gIFBrY3M4OiBhc24uZGVmaW5lKCdQa2NzOEtleScsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VxKCkub2JqKFxuICAgICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdhbGdvcml0aG1JZGVudGlmaWVyJylcbiAgICAgICAgLnNlcSgpXG4gICAgICAgIC5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXlUeXBlJykub2JqaWQoe1xuICAgICAgICAgICAgJzEgMiA4NDAgMTAwNDUgMiAxJzogJ0VDJ1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub2JqaWQoe1xuICAgICAgICAgICAgJzEgMiA4NDAgMTAwNDUgMyAxIDcnOiAncHJpbWUyNTZ2MScsXG4gICAgICAgICAgICAnMSAzIDEzMiAwIDEwJzogJ3NlY3AyNTZrMScsXG4gICAgICAgICAgICAnMSAzIDEzMiAwIDM0JzogJ3NlY3AzODRyMScsXG4gICAgICAgICAgICAnMSAzIDEzMiAwIDM1JzogJ3NlY3A1MjFyMSdcbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKVxuICAgIClcbiAgfSksXG4gIFNwa2k6IGFzbi5kZWZpbmUoJ1Nwa2lLZXknLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdhbGdvcml0aG1JZGVudGlmaWVyJylcbiAgICAgICAgLnNlcSgpXG4gICAgICAgIC5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ3B1YmxpY0tleVR5cGUnKS5vYmppZCh7XG4gICAgICAgICAgICAnMSAyIDg0MCAxMDA0NSAyIDEnOiAnRUMnXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5vYmppZCh7XG4gICAgICAgICAgICAnMSAyIDg0MCAxMDA0NSAzIDEgNyc6ICdwcmltZTI1NnYxJyxcbiAgICAgICAgICAgICcxIDMgMTMyIDAgMTAnOiAnc2VjcDI1NmsxJyxcbiAgICAgICAgICAgICcxIDMgMTMyIDAgMzQnOiAnc2VjcDM4NHIxJyxcbiAgICAgICAgICAgICcxIDMgMTMyIDAgMzUnOiAnc2VjcDUyMXIxJ1xuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICB0aGlzLmtleSgncHVibGljS2V5JykuYml0c3RyKClcbiAgICApXG4gIH0pLFxuICBFY2RzYURlclNpZzogYXNuLmRlZmluZSgnRUNQcml2YXRlS2V5JywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxKCkub2JqKHRoaXMua2V5KCdyJykuaW50KCksIHRoaXMua2V5KCdzJykuaW50KCkpXG4gIH0pXG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICpcbiAqIFNJR05JTkcgLyBWQUxJREFUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbmZ1bmN0aW9uIGhhc2gob2JqZWN0KSB7XG4gIHJldHVybiBjcnlwdG9cbiAgICAuY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAudXBkYXRlKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnID8gb2JqZWN0IDogSlNPTi5zdHJpbmdpZnkob2JqZWN0KSlcbiAgICAuZGlnZXN0KCdiYXNlNjQnKVxufVxuXG5FQ0RTQS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgZm9ybWF0ID0gJ2Jhc2U2NCcpIHtcbiAgZnVuY3Rpb24gcmVtb3ZlRGVyRW5jb2Rpbmcoc2lnbmF0dXJlQnVmZmVyKSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBBU04xLkVjZHNhRGVyU2lnLmRlY29kZShzaWduYXR1cmVCdWZmZXIsICdkZXInKVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtyLnRvQnVmZmVyKCksIHMudG9CdWZmZXIoKV0pLnRvU3RyaW5nKGZvcm1hdClcbiAgfVxuXG4gIGlmICghdGhpcy5pc1ByaXZhdGUpIHRocm93IG5ldyBFcnJvcignRUMgUHJpdmF0ZSBLZXkgbmVlZGVkIHRvIHNpZ24nKVxuICBjb25zdCBzaWduID0gY3J5cHRvLmNyZWF0ZVNpZ24oJ1JTQS1TSEEyNTYnKSAvLyBSU0Egd29ya3Mgd2l0aCBFQyBrZXlzLCB0b29cbiAgc2lnbi53cml0ZShtZXNzYWdlKVxuICBzaWduLmVuZCgpXG4gIHJldHVybiByZW1vdmVEZXJFbmNvZGluZyhzaWduLnNpZ24odGhpcy50b1BFTSgpKSlcbn1cblxuRUNEU0EucHJvdG90eXBlLmhhc2hBbmRTaWduID0gYXN5bmMgZnVuY3Rpb24gaGFzaEFuZFNpZ24obWVzc2FnZSwgZm9ybWF0ID0gJ2Jhc2U2NCcpIHtcbiAgcmV0dXJuIHRoaXMuc2lnbihhd2FpdCBoYXNoKG1lc3NhZ2UpLCBmb3JtYXQpXG59XG5cbkVDRFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBmb3JtYXQgPSAnYmFzZTY0Jykge1xuICBmdW5jdGlvbiBzaWduYXR1cmVUb0RlcihzaWduYXR1cmVCdWZmZXIpIHtcbiAgICBjb25zdCByID0gbmV3IEJOKHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgwLCBjdXJ2ZUxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNiwgJ2JlJylcbiAgICBjb25zdCBzID0gbmV3IEJOKHNpZ25hdHVyZUJ1ZmZlci5zbGljZShjdXJ2ZUxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNiwgJ2JlJylcbiAgICByZXR1cm4gQVNOMS5FY2RzYURlclNpZy5lbmNvZGUoeyByLCBzIH0sICdkZXInKVxuICB9XG5cbiAgY29uc3QgdmVyaWZ5ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeSgnUlNBLVNIQTI1NicpIC8vIFJTQSB3b3JrcyB3aXRoIEVDIGtleXMsIHRvb1xuICB2ZXJpZnkud3JpdGUobWVzc2FnZSlcbiAgdmVyaWZ5LmVuZCgpXG4gIGNvbnN0IGtleSA9IHRoaXMuaXNQcml2YXRlID8gdGhpcy5hc1B1YmxpYygpIDogdGhpc1xuICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUsIGZvcm1hdClcbiAgcmV0dXJuIHZlcmlmeS52ZXJpZnkoXG4gICAga2V5LnRvUEVNKCksXG4gICAgc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA8PSAyICogY3VydmVMZW5ndGggPyBzaWduYXR1cmVUb0RlcihzaWduYXR1cmVCdWZmZXIpIDogc2lnbmF0dXJlQnVmZmVyLFxuICAgIGZvcm1hdFxuICApXG59XG5cbkVDRFNBLnByb3RvdHlwZS5oYXNoQW5kVmVyaWZ5ID0gYXN5bmMgZnVuY3Rpb24gaGFzaEFuZFZlcmlmeShcbiAgbWVzc2FnZSxcbiAgc2lnbmF0dXJlLFxuICBmb3JtYXQgPSAnYmFzZTY0J1xuKSB7XG4gIHJldHVybiB0aGlzLnZlcmlmeShhd2FpdCBoYXNoKG1lc3NhZ2UpLCBzaWduYXR1cmUsIGZvcm1hdClcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKlxuICogQ09OVkVSU0lPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuRUNEU0EucHJvdG90eXBlLmFzUHVibGljID0gZnVuY3Rpb24gYXNQdWJsaWMoKSB7XG4gIGlmICghdGhpcy5pc1ByaXZhdGUpIHJldHVybiB0aGlzXG4gIHJldHVybiBuZXcgRUNEU0EoeyB4OiB0aGlzLngsIHk6IHRoaXMueSB9KVxufVxuXG5FQ0RTQS5wcm90b3R5cGUudG9Db21wcmVzc2VkUHVibGljS2V5ID0gZnVuY3Rpb24gdG9Db21wcmVzc2VkUHVibGljS2V5KGZvcm1hdCA9ICdiYXNlNjQnKSB7XG4gIHJldHVybiBjcnlwdG8uRUNESC5jb252ZXJ0S2V5KHRoaXMucHVibGljQ29kZVBvaW50LCBjdXJ2ZSwgJ2Jhc2U2NCcsIGZvcm1hdCwgJ2NvbXByZXNzZWQnKVxufVxuXG5FQ0RTQS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcihmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PT0gJ3BlbScpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy50b1BFTSgpLCAnYXNjaWknKVxuICB9IGVsc2UgaWYgKHRoaXMuaXNQcml2YXRlKSB7XG4gICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvZXMgZnJvbSBwcml2YXRlIGtleVxuICAgIGxldCBkID0gdGhpcy5kXG4gICAgd2hpbGUgKGRbMF0gPT09IDApIGQgPSBkLnNsaWNlKDEpXG5cbiAgICAvLyBFbmNvZGUgaW4gUEtDUzhcbiAgICByZXR1cm4gQVNOMS5Qa2NzOC5lbmNvZGUoXG4gICAgICB7XG4gICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgIGFsZ29yaXRobUlkZW50aWZpZXI6IHtcbiAgICAgICAgICBwcml2YXRlS2V5VHlwZTogJ0VDJyxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBjdXJ2ZVxuICAgICAgICB9LFxuICAgICAgICAvLyBQcml2YXRlIGtleSBpcyBSRkM1OTE1IG1pbnVzIGN1cnZlXG4gICAgICAgIHByaXZhdGVLZXk6IEFTTjEuUmZjNTkxNS5lbmNvZGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGQsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHsgZGF0YTogdGhpcy5wdWJsaWNDb2RlUG9pbnQgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2RlcidcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgICdkZXInXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBBU04xLlNwa2kuZW5jb2RlKFxuICAgICAge1xuICAgICAgICBhbGdvcml0aG1JZGVudGlmaWVyOiB7XG4gICAgICAgICAgcHVibGljS2V5VHlwZTogJ0VDJyxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBjdXJ2ZVxuICAgICAgICB9LFxuICAgICAgICBwdWJsaWNLZXk6IHsgZGF0YTogdGhpcy5wdWJsaWNDb2RlUG9pbnQgfVxuICAgICAgfSxcbiAgICAgICdkZXInXG4gICAgKVxuICB9XG59XG5cbkVDRFNBLnByb3RvdHlwZS50b1BFTSA9IGZ1bmN0aW9uIHRvUEVNKCkge1xuICByZXR1cm4gdGhpcy5pc1ByaXZhdGVcbiAgICA/ICctLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4nICtcbiAgICAgICAgdGhpcy50b0J1ZmZlcigncGtjczgnKVxuICAgICAgICAgIC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAubWF0Y2goLy57MSw2NH0vZylcbiAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAnXFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLVxcbidcbiAgICA6ICctLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbicgK1xuICAgICAgICB0aGlzLnRvQnVmZmVyKCdzcGtpJylcbiAgICAgICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgICAgLm1hdGNoKC8uezEsNjR9L2cpXG4gICAgICAgICAgLmpvaW4oJ1xcbicpICtcbiAgICAgICAgJ1xcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLVxcbidcbn1cblxuRUNEU0EucHJvdG90eXBlLnRvSldLID0gZnVuY3Rpb24gdG9KV0soKSB7XG4gIGZ1bmN0aW9uIHVybHNhZmUoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclxuICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICAgIC5yZXBsYWNlKC89L2csICcnKVxuICB9XG5cbiAgY29uc3QgandrID0ge1xuICAgIGt0eTogJ0VDJyxcbiAgICBjcnY6IGp3a0N1cnZlLFxuICAgIHg6IHVybHNhZmUodGhpcy54KSxcbiAgICB5OiB1cmxzYWZlKHRoaXMueSlcbiAgfVxuXG4gIGlmICh0aGlzLmlzUHJpdmF0ZSkge1xuICAgIGxldCBkID0gdGhpcy5kXG4gICAgaWYgKGQubGVuZ3RoIDwgY3VydmVMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGN1cnZlTGVuZ3RoIC0gZC5sZW5ndGhcbiAgICAgIGQgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MocmVtYWluaW5nKS5maWxsKDApLCBkXSlcbiAgICB9XG4gICAgandrLmQgPSB1cmxzYWZlKGQpXG4gIH1cblxuICByZXR1cm4gandrXG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICpcbiAqIEVYUE9SVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbm1vZHVsZS5leHBvcnRzID0gRUNEU0FcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ecdsa-secp256r1/index.js\n");

/***/ })

};
;