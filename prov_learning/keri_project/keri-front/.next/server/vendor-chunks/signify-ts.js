"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/signify-ts";
exports.ids = ["vendor-chunks/signify-ts"];
exports.modules = {

/***/ "(ssr)/./node_modules/signify-ts/dist/signify-ts.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/signify-ts/dist/signify-ts.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: () => (/* binding */ Agent),\n/* harmony export */   Algos: () => (/* binding */ Algos),\n/* harmony export */   Authenticater: () => (/* binding */ Authenticater),\n/* harmony export */   B64ChrByIdx: () => (/* binding */ B64ChrByIdx),\n/* harmony export */   B64IdxByChr: () => (/* binding */ B64IdxByChr),\n/* harmony export */   BexCodex: () => (/* binding */ BexCodex),\n/* harmony export */   BexDex: () => (/* binding */ BexDex),\n/* harmony export */   CesrNumber: () => (/* binding */ CesrNumber),\n/* harmony export */   Challenges: () => (/* binding */ Challenges),\n/* harmony export */   Cigar: () => (/* binding */ Cigar),\n/* harmony export */   Cipher: () => (/* binding */ Cipher),\n/* harmony export */   Codex: () => (/* binding */ Codex),\n/* harmony export */   Contacts: () => (/* binding */ Contacts),\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Counter: () => (/* binding */ Counter),\n/* harmony export */   CounterCodex: () => (/* binding */ CounterCodex),\n/* harmony export */   Creatory: () => (/* binding */ Creatory),\n/* harmony export */   CredentialTypes: () => (/* binding */ CredentialTypes),\n/* harmony export */   Credentials: () => (/* binding */ Credentials),\n/* harmony export */   CtrDex: () => (/* binding */ CtrDex),\n/* harmony export */   Decrypter: () => (/* binding */ Decrypter),\n/* harmony export */   Diger: () => (/* binding */ Diger),\n/* harmony export */   DigiCodex: () => (/* binding */ DigiCodex),\n/* harmony export */   DigiDex: () => (/* binding */ DigiDex),\n/* harmony export */   DipLabels: () => (/* binding */ DipLabels),\n/* harmony export */   DrtLabels: () => (/* binding */ DrtLabels),\n/* harmony export */   EmptyMaterialError: () => (/* binding */ EmptyMaterialError),\n/* harmony export */   Encrypter: () => (/* binding */ Encrypter),\n/* harmony export */   Escrows: () => (/* binding */ Escrows),\n/* harmony export */   EventResult: () => (/* binding */ EventResult),\n/* harmony export */   Exchanges: () => (/* binding */ Exchanges),\n/* harmony export */   FALSY: () => (/* binding */ FALSY),\n/* harmony export */   GroupKeeper: () => (/* binding */ GroupKeeper),\n/* harmony export */   Groups: () => (/* binding */ Groups),\n/* harmony export */   HEADER_SIG_INPUT: () => (/* binding */ HEADER_SIG_INPUT),\n/* harmony export */   HEADER_SIG_TIME: () => (/* binding */ HEADER_SIG_TIME),\n/* harmony export */   Hab: () => (/* binding */ Hab),\n/* harmony export */   Habery: () => (/* binding */ Habery),\n/* harmony export */   IcpLabels: () => (/* binding */ IcpLabels),\n/* harmony export */   Ident: () => (/* binding */ Ident),\n/* harmony export */   Identifier: () => (/* binding */ Identifier),\n/* harmony export */   IdrDex: () => (/* binding */ IdrDex),\n/* harmony export */   Ids: () => (/* binding */ Ids),\n/* harmony export */   IdxBthSigDex: () => (/* binding */ IdxBthSigDex),\n/* harmony export */   IdxCrtSigDex: () => (/* binding */ IdxCrtSigDex),\n/* harmony export */   IdxSigDex: () => (/* binding */ IdxSigDex),\n/* harmony export */   Ilks: () => (/* binding */ Ilks),\n/* harmony export */   IndexedBothSigCodex: () => (/* binding */ IndexedBothSigCodex),\n/* harmony export */   IndexedCurrentSigCodex: () => (/* binding */ IndexedCurrentSigCodex),\n/* harmony export */   IndexedSigCodex: () => (/* binding */ IndexedSigCodex),\n/* harmony export */   Indexer: () => (/* binding */ Indexer),\n/* harmony export */   IndexerCodex: () => (/* binding */ IndexerCodex),\n/* harmony export */   Inputage: () => (/* binding */ Inputage),\n/* harmony export */   Ipex: () => (/* binding */ Ipex),\n/* harmony export */   IxnLabels: () => (/* binding */ IxnLabels),\n/* harmony export */   KeyEvents: () => (/* binding */ KeyEvents),\n/* harmony export */   KeyManager: () => (/* binding */ KeyManager),\n/* harmony export */   KeyStates: () => (/* binding */ KeyStates),\n/* harmony export */   KsnLabels: () => (/* binding */ KsnLabels),\n/* harmony export */   LargeVrzDex: () => (/* binding */ LargeVrzDex),\n/* harmony export */   MINSIGSIZE: () => (/* binding */ MINSIGSIZE),\n/* harmony export */   MINSNIFFSIZE: () => (/* binding */ MINSNIFFSIZE),\n/* harmony export */   Manager: () => (/* binding */ Manager),\n/* harmony export */   Matter: () => (/* binding */ Matter),\n/* harmony export */   MatterCodex: () => (/* binding */ MatterCodex),\n/* harmony export */   MtrDex: () => (/* binding */ MtrDex),\n/* harmony export */   NonTransCodex: () => (/* binding */ NonTransCodex),\n/* harmony export */   NonTransDex: () => (/* binding */ NonTransDex),\n/* harmony export */   Notifications: () => (/* binding */ Notifications),\n/* harmony export */   NumCodex: () => (/* binding */ NumCodex),\n/* harmony export */   NumDex: () => (/* binding */ NumDex),\n/* harmony export */   Oobis: () => (/* binding */ Oobis),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Prefixer: () => (/* binding */ Prefixer),\n/* harmony export */   RandyCreator: () => (/* binding */ RandyCreator),\n/* harmony export */   RandyKeeper: () => (/* binding */ RandyKeeper),\n/* harmony export */   Registries: () => (/* binding */ Registries),\n/* harmony export */   RegistryResult: () => (/* binding */ RegistryResult),\n/* harmony export */   RotLabels: () => (/* binding */ RotLabels),\n/* harmony export */   RpyLabels: () => (/* binding */ RpyLabels),\n/* harmony export */   Saider: () => (/* binding */ Saider),\n/* harmony export */   Salter: () => (/* binding */ Salter),\n/* harmony export */   SaltyCreator: () => (/* binding */ SaltyCreator),\n/* harmony export */   SaltyKeeper: () => (/* binding */ SaltyKeeper),\n/* harmony export */   Schemas: () => (/* binding */ Schemas),\n/* harmony export */   Seqner: () => (/* binding */ Seqner),\n/* harmony export */   Serder: () => (/* binding */ Serder),\n/* harmony export */   Serials: () => (/* binding */ Serials),\n/* harmony export */   Siger: () => (/* binding */ Siger),\n/* harmony export */   Signage: () => (/* binding */ Signage),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignifyClient: () => (/* binding */ SignifyClient),\n/* harmony export */   Sizage: () => (/* binding */ Sizage),\n/* harmony export */   SmallVrzDex: () => (/* binding */ SmallVrzDex),\n/* harmony export */   TRUTHY: () => (/* binding */ TRUTHY),\n/* harmony export */   Tholder: () => (/* binding */ Tholder),\n/* harmony export */   Tier: () => (/* binding */ Tier),\n/* harmony export */   TraitCodex: () => (/* binding */ TraitCodex),\n/* harmony export */   TraitDex: () => (/* binding */ TraitDex),\n/* harmony export */   Unqualified: () => (/* binding */ Unqualified),\n/* harmony export */   VEREX: () => (/* binding */ VEREX),\n/* harmony export */   VERFULLSIZE: () => (/* binding */ VERFULLSIZE),\n/* harmony export */   Verfer: () => (/* binding */ Verfer),\n/* harmony export */   Version: () => (/* binding */ Version),\n/* harmony export */   Versionage: () => (/* binding */ Versionage),\n/* harmony export */   Xizage: () => (/* binding */ Xizage),\n/* harmony export */   ample: () => (/* binding */ ample),\n/* harmony export */   arrayEquals: () => (/* binding */ arrayEquals),\n/* harmony export */   b: () => (/* binding */ b),\n/* harmony export */   b64ToInt: () => (/* binding */ b64ToInt),\n/* harmony export */   bytesToInt: () => (/* binding */ bytesToInt),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   d: () => (/* binding */ d),\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   desiginput: () => (/* binding */ desiginput),\n/* harmony export */   designature: () => (/* binding */ designature),\n/* harmony export */   deversify: () => (/* binding */ deversify),\n/* harmony export */   dumps: () => (/* binding */ dumps),\n/* harmony export */   exchange: () => (/* binding */ exchange),\n/* harmony export */   extractValues: () => (/* binding */ extractValues),\n/* harmony export */   incept: () => (/* binding */ incept),\n/* harmony export */   intToB64: () => (/* binding */ intToB64),\n/* harmony export */   intToB64b: () => (/* binding */ intToB64b),\n/* harmony export */   intToBytes: () => (/* binding */ intToBytes),\n/* harmony export */   interact: () => (/* binding */ interact),\n/* harmony export */   messagize: () => (/* binding */ messagize),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   nowUTC: () => (/* binding */ nowUTC),\n/* harmony export */   openManager: () => (/* binding */ openManager),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   parseRangeHeaders: () => (/* binding */ parseRangeHeaders),\n/* harmony export */   randomNonce: () => (/* binding */ randomNonce),\n/* harmony export */   randomPasscode: () => (/* binding */ randomPasscode),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   readInt: () => (/* binding */ readInt),\n/* harmony export */   ready: () => (/* binding */ ready),\n/* harmony export */   reply: () => (/* binding */ reply),\n/* harmony export */   riKey: () => (/* binding */ riKey),\n/* harmony export */   rotate: () => (/* binding */ rotate),\n/* harmony export */   serializeACDCAttachment: () => (/* binding */ serializeACDCAttachment),\n/* harmony export */   serializeIssExnAttachment: () => (/* binding */ serializeIssExnAttachment),\n/* harmony export */   siginput: () => (/* binding */ siginput),\n/* harmony export */   signature: () => (/* binding */ signature),\n/* harmony export */   sizeify: () => (/* binding */ sizeify),\n/* harmony export */   versify: () => (/* binding */ versify)\n/* harmony export */ });\n/* harmony import */ var libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! libsodium-wrappers-sumo */ \"(ssr)/./node_modules/libsodium-wrappers-sumo/dist/modules-sumo/libsodium-wrappers.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var ecdsa_secp256r1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ecdsa-secp256r1 */ \"(ssr)/./node_modules/ecdsa-secp256r1/index.js\");\n/* harmony import */ var _noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/blake3 */ \"(ssr)/./node_modules/@noble/hashes/esm/blake3.js\");\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mathjs */ \"(ssr)/./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var structured_headers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! structured-headers */ \"(ssr)/./node_modules/structured-headers/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/exports.ts\nvar exports_exports = {};\n__export(exports_exports, {\n  Agent: () => Agent,\n  Algos: () => Algos,\n  Authenticater: () => Authenticater,\n  B64ChrByIdx: () => B64ChrByIdx,\n  B64IdxByChr: () => B64IdxByChr,\n  BexCodex: () => BexCodex,\n  BexDex: () => BexDex,\n  CesrNumber: () => CesrNumber,\n  Challenges: () => Challenges,\n  Cigar: () => Cigar,\n  Cipher: () => Cipher,\n  Codex: () => Codex,\n  Contacts: () => Contacts,\n  Controller: () => Controller,\n  Counter: () => Counter,\n  CounterCodex: () => CounterCodex,\n  Creatory: () => Creatory,\n  CredentialTypes: () => CredentialTypes,\n  Credentials: () => Credentials,\n  CtrDex: () => CtrDex,\n  Decrypter: () => Decrypter,\n  Diger: () => Diger,\n  DigiCodex: () => DigiCodex,\n  DigiDex: () => DigiDex,\n  DipLabels: () => DipLabels,\n  DrtLabels: () => DrtLabels,\n  EmptyMaterialError: () => EmptyMaterialError,\n  Encrypter: () => Encrypter,\n  Escrows: () => Escrows,\n  EventResult: () => EventResult,\n  Exchanges: () => Exchanges,\n  FALSY: () => FALSY,\n  GroupKeeper: () => GroupKeeper,\n  Groups: () => Groups,\n  HEADER_SIG_INPUT: () => HEADER_SIG_INPUT,\n  HEADER_SIG_TIME: () => HEADER_SIG_TIME,\n  Hab: () => Hab,\n  Habery: () => Habery,\n  IcpLabels: () => IcpLabels,\n  Ident: () => Ident,\n  Identifier: () => Identifier,\n  IdrDex: () => IdrDex,\n  Ids: () => Ids,\n  IdxBthSigDex: () => IdxBthSigDex,\n  IdxCrtSigDex: () => IdxCrtSigDex,\n  IdxSigDex: () => IdxSigDex,\n  Ilks: () => Ilks,\n  IndexedBothSigCodex: () => IndexedBothSigCodex,\n  IndexedCurrentSigCodex: () => IndexedCurrentSigCodex,\n  IndexedSigCodex: () => IndexedSigCodex,\n  Indexer: () => Indexer,\n  IndexerCodex: () => IndexerCodex,\n  Inputage: () => Inputage,\n  Ipex: () => Ipex,\n  IxnLabels: () => IxnLabels,\n  KeyEvents: () => KeyEvents,\n  KeyManager: () => KeyManager,\n  KeyStates: () => KeyStates,\n  KsnLabels: () => KsnLabels,\n  LargeVrzDex: () => LargeVrzDex,\n  MINSIGSIZE: () => MINSIGSIZE,\n  MINSNIFFSIZE: () => MINSNIFFSIZE,\n  Manager: () => Manager,\n  Matter: () => Matter,\n  MatterCodex: () => MatterCodex,\n  MtrDex: () => MtrDex,\n  NonTransCodex: () => NonTransCodex,\n  NonTransDex: () => NonTransDex,\n  Notifications: () => Notifications,\n  NumCodex: () => NumCodex,\n  NumDex: () => NumDex,\n  Oobis: () => Oobis,\n  Operations: () => Operations,\n  Prefixer: () => Prefixer,\n  RandyCreator: () => RandyCreator,\n  RandyKeeper: () => RandyKeeper,\n  Registries: () => Registries,\n  RegistryResult: () => RegistryResult,\n  RotLabels: () => RotLabels,\n  RpyLabels: () => RpyLabels,\n  Saider: () => Saider,\n  Salter: () => Salter,\n  SaltyCreator: () => SaltyCreator,\n  SaltyKeeper: () => SaltyKeeper,\n  Schemas: () => Schemas,\n  Seqner: () => Seqner,\n  Serder: () => Serder,\n  Serials: () => Serials,\n  Siger: () => Siger,\n  Signage: () => Signage,\n  Signer: () => Signer,\n  SignifyClient: () => SignifyClient,\n  Sizage: () => Sizage,\n  SmallVrzDex: () => SmallVrzDex,\n  TRUTHY: () => TRUTHY,\n  Tholder: () => Tholder,\n  Tier: () => Tier,\n  TraitCodex: () => TraitCodex,\n  TraitDex: () => TraitDex,\n  Unqualified: () => Unqualified,\n  VEREX: () => VEREX,\n  VERFULLSIZE: () => VERFULLSIZE,\n  Verfer: () => Verfer,\n  Version: () => Version,\n  Versionage: () => Versionage,\n  Xizage: () => Xizage,\n  ample: () => ample,\n  arrayEquals: () => arrayEquals,\n  b: () => b,\n  b64ToInt: () => b64ToInt,\n  bytesToInt: () => bytesToInt,\n  concat: () => concat,\n  d: () => d,\n  desiginput: () => desiginput,\n  designature: () => designature,\n  deversify: () => deversify,\n  dumps: () => dumps,\n  exchange: () => exchange,\n  extractValues: () => extractValues,\n  incept: () => incept,\n  intToB64: () => intToB64,\n  intToB64b: () => intToB64b,\n  intToBytes: () => intToBytes,\n  interact: () => interact,\n  messagize: () => messagize,\n  normalize: () => normalize,\n  nowUTC: () => nowUTC,\n  openManager: () => openManager,\n  pad: () => pad,\n  parseRangeHeaders: () => parseRangeHeaders,\n  randomNonce: () => randomNonce,\n  randomPasscode: () => randomPasscode,\n  range: () => range,\n  readInt: () => readInt,\n  ready: () => ready,\n  reply: () => reply,\n  riKey: () => riKey,\n  rotate: () => rotate,\n  serializeACDCAttachment: () => serializeACDCAttachment,\n  serializeIssExnAttachment: () => serializeIssExnAttachment,\n  siginput: () => siginput,\n  signature: () => signature,\n  sizeify: () => sizeify,\n  versify: () => versify\n});\n\n// src/ready.ts\n\nvar ready = async () => {\n  await libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.ready;\n};\n\n// src/keri/core/encrypter.ts\n\n\n// src/keri/core/kering.ts\nvar EmptyMaterialError = class {\n  _err;\n  constructor(err) {\n    this._err = new Error(err);\n  }\n  get err() {\n    return this._err;\n  }\n};\n\n// src/keri/core/core.ts\nvar Serials = /* @__PURE__ */ ((Serials2) => {\n  Serials2[\"JSON\"] = \"JSON\";\n  return Serials2;\n})(Serials || {});\nvar Ident = /* @__PURE__ */ ((Ident2) => {\n  Ident2[\"KERI\"] = \"KERI\";\n  Ident2[\"ACDC\"] = \"ACDC\";\n  return Ident2;\n})(Ident || {});\nvar Version = class {\n  major;\n  minor;\n  constructor(major = 1, minor = 0) {\n    this.major = major;\n    this.minor = minor;\n  }\n};\nvar Versionage = new Version();\nvar Ilks = {\n  icp: \"icp\",\n  rot: \"rot\",\n  ixn: \"ixn\",\n  dip: \"dip\",\n  drt: \"drt\",\n  rct: \"rct\",\n  vrc: \"vrc\",\n  rpy: \"rpy\",\n  exn: \"exn\",\n  vcp: \"vcp\",\n  iss: \"iss\",\n  rev: \"rev\"\n};\nvar IcpLabels = [\n  \"v\",\n  \"i\",\n  \"s\",\n  \"t\",\n  \"kt\",\n  \"k\",\n  \"n\",\n  \"bt\",\n  \"b\",\n  \"c\",\n  \"a\"\n];\nvar DipLabels = [\n  \"v\",\n  \"i\",\n  \"s\",\n  \"t\",\n  \"kt\",\n  \"k\",\n  \"n\",\n  \"bt\",\n  \"b\",\n  \"c\",\n  \"a\",\n  \"di\"\n];\nvar RotLabels = [\n  \"v\",\n  \"i\",\n  \"s\",\n  \"t\",\n  \"p\",\n  \"kt\",\n  \"k\",\n  \"n\",\n  \"bt\",\n  \"br\",\n  \"ba\",\n  \"a\"\n];\nvar DrtLabels = [\n  \"v\",\n  \"i\",\n  \"s\",\n  \"t\",\n  \"p\",\n  \"kt\",\n  \"k\",\n  \"n\",\n  \"bt\",\n  \"br\",\n  \"ba\",\n  \"a\"\n];\nvar IxnLabels = [\"v\", \"i\", \"s\", \"t\", \"p\", \"a\"];\nvar KsnLabels = [\n  \"v\",\n  \"i\",\n  \"s\",\n  \"t\",\n  \"p\",\n  \"d\",\n  \"f\",\n  \"dt\",\n  \"et\",\n  \"kt\",\n  \"k\",\n  \"n\",\n  \"bt\",\n  \"b\",\n  \"c\",\n  \"ee\",\n  \"di\",\n  \"r\"\n];\nvar RpyLabels = [\"v\", \"t\", \"d\", \"dt\", \"r\", \"a\"];\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar VERFULLSIZE = 17;\nvar MINSNIFFSIZE = 12 + VERFULLSIZE;\nvar MINSIGSIZE = 4;\nvar VEREX = \"(KERI|ACDC)([0-9a-f])([0-9a-f])([A-Z]{4})([0-9a-f]{6})_\";\nfunction deversify(versionString) {\n  let kind;\n  let size;\n  let proto;\n  const version = Versionage;\n  const re = new RegExp(VEREX);\n  const match = re.exec(versionString);\n  if (match) {\n    [proto, version.major, version.minor, kind, size] = [\n      match[1],\n      +match[2],\n      +match[3],\n      match[4],\n      match[5]\n    ];\n    if (!Object.values(Serials).includes(kind)) {\n      throw new Error(`Invalid serialization kind = ${kind}`);\n    }\n    if (!Object.values(Ident).includes(proto)) {\n      throw new Error(`Invalid serialization kind = ${kind}`);\n    }\n    const ta = kind;\n    kind = Serials[ta];\n    const pa = proto;\n    proto = Ident[pa];\n    return [proto, kind, version, size];\n  }\n  throw new Error(`Invalid version string = ${versionString}`);\n}\nfunction versify(ident = \"KERI\" /* KERI */, version, kind = \"JSON\" /* JSON */, size = 0) {\n  version = version == void 0 ? Versionage : version;\n  return `${ident}${version.major.toString(\n    16\n  )}${version.minor.toString()}${kind}${size.toString(16).padStart(6, \"0\")}_`;\n}\nvar B64ChrByIdx = /* @__PURE__ */ new Map([\n  [0, \"A\"],\n  [1, \"B\"],\n  [2, \"C\"],\n  [3, \"D\"],\n  [4, \"E\"],\n  [5, \"F\"],\n  [6, \"G\"],\n  [7, \"H\"],\n  [8, \"I\"],\n  [9, \"J\"],\n  [10, \"K\"],\n  [11, \"L\"],\n  [12, \"M\"],\n  [13, \"N\"],\n  [14, \"O\"],\n  [15, \"P\"],\n  [16, \"Q\"],\n  [17, \"R\"],\n  [18, \"S\"],\n  [19, \"T\"],\n  [20, \"U\"],\n  [21, \"V\"],\n  [22, \"W\"],\n  [23, \"X\"],\n  [24, \"Y\"],\n  [25, \"Z\"],\n  [26, \"a\"],\n  [27, \"b\"],\n  [28, \"c\"],\n  [29, \"d\"],\n  [30, \"e\"],\n  [31, \"f\"],\n  [32, \"g\"],\n  [33, \"h\"],\n  [34, \"i\"],\n  [35, \"j\"],\n  [36, \"k\"],\n  [37, \"l\"],\n  [38, \"m\"],\n  [39, \"n\"],\n  [40, \"o\"],\n  [41, \"p\"],\n  [42, \"q\"],\n  [43, \"r\"],\n  [44, \"s\"],\n  [45, \"t\"],\n  [46, \"u\"],\n  [47, \"v\"],\n  [48, \"w\"],\n  [49, \"x\"],\n  [50, \"y\"],\n  [51, \"z\"],\n  [52, \"0\"],\n  [53, \"1\"],\n  [54, \"2\"],\n  [55, \"3\"],\n  [56, \"4\"],\n  [57, \"5\"],\n  [58, \"6\"],\n  [59, \"7\"],\n  [60, \"8\"],\n  [61, \"9\"],\n  [62, \"-\"],\n  [63, \"_\"]\n]);\nvar B64IdxByChr = new Map(\n  Array.from(B64ChrByIdx, (entry) => [entry[1], entry[0]])\n);\nfunction intToB64(i, l = 1) {\n  let out = \"\";\n  while (l != 0) {\n    out = B64ChrByIdx.get(i % 64) + out;\n    i = Math.floor(i / 64);\n    if (i == 0) {\n      break;\n    }\n  }\n  const x = l - out.length;\n  for (let i2 = 0; i2 < x; i2++) {\n    out = \"A\" + out;\n  }\n  return out;\n}\nfunction intToB64b(n, l = 1) {\n  const s = intToB64(n, l);\n  return b(s);\n}\nfunction b64ToInt(s) {\n  if (s.length == 0) {\n    throw new Error(\"Empty string, conversion undefined.\");\n  }\n  let i = 0;\n  const rev = s.split(\"\").reverse();\n  rev.forEach((c, e) => {\n    i |= B64IdxByChr.get(c) << e * 6;\n  });\n  return i;\n}\nfunction b(s) {\n  return encoder.encode(s);\n}\nfunction d(u) {\n  return decoder.decode(u);\n}\nfunction concat(one, two) {\n  const out = new Uint8Array(one.length + two.length);\n  out.set(one);\n  out.set(two, one.length);\n  return out;\n}\nfunction readInt(array) {\n  let value = 0;\n  for (let i = 0; i < array.length; i++) {\n    value = value * 256 + array[i];\n  }\n  return value;\n}\n\n// src/keri/core/matter.ts\n\n\n// src/keri/core/base64.ts\n\nfunction encodeBase64Url(buffer) {\n  if (!buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.isBuffer(buffer)) {\n    throw new TypeError(\"`buffer` must be a buffer.\");\n  }\n  return buffer.toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+/, \"\");\n}\nfunction decodeBase64Url(input) {\n  if (!(typeof input === \"string\")) {\n    throw new TypeError(\"`input` must be a string.\");\n  }\n  const n = input.length % 4;\n  const padded = input + \"=\".repeat(n > 0 ? 4 - n : n);\n  const base64String = padded.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(base64String, \"base64\");\n}\n\n// src/keri/core/matter.ts\nvar Codex = class {\n  has(prop) {\n    const m = new Map(\n      Array.from(Object.entries(this), (v) => [v[1], v[0]])\n    );\n    return m.has(prop);\n  }\n};\nvar MatterCodex = class extends Codex {\n  Ed25519_Seed = \"A\";\n  // Ed25519 256 bit random seed for private key\n  Ed25519N = \"B\";\n  // Ed25519 verification key non-transferable, basic derivation.\n  X25519 = \"C\";\n  // X25519 public encryption key, converted from Ed25519 or Ed25519N.\n  Ed25519 = \"D\";\n  // Ed25519 verification key basic derivation\n  Blake3_256 = \"E\";\n  // Blake3 256 bit digest self-addressing derivation.\n  SHA3_256 = \"H\";\n  // SHA3 256 bit digest self-addressing derivation.\n  SHA2_256 = \"I\";\n  // SHA2 256 bit digest self-addressing derivation.\n  ECDSA_256k1_Seed = \"J\";\n  // ECDSA secp256k1 256 bit random Seed for private key\n  X25519_Private = \"O\";\n  // X25519 private decryption key converted from Ed25519\n  X25519_Cipher_Seed = \"P\";\n  // X25519 124 char b64 Cipher of 44 char qb64 Seed\n  ECDSA_256r1_Seed = \"Q\";\n  // ECDSA secp256r1 256 bit random Seed for private key\n  Salt_128 = \"0A\";\n  // 128 bit random salt or 128 bit number (see Huge)\n  Ed25519_Sig = \"0B\";\n  // Ed25519 signature.\n  ECDSA_256k1_Sig = \"0C\";\n  // ECDSA secp256k1 signature.\n  ECDSA_256r1_Sig = \"0I\";\n  // ECDSA secp256r1 signature.\n  StrB64_L0 = \"4A\";\n  // String Base64 Only Lead Size 0\n  StrB64_L1 = \"5A\";\n  // String Base64 Only Lead Size 1\n  StrB64_L2 = \"6A\";\n  // String Base64 Only Lead Size 2\n  ECDSA_256k1N = \"1AAA\";\n  // ECDSA secp256k1 verification key non-transferable, basic derivation.\n  ECDSA_256k1 = \"1AAB\";\n  // ECDSA public verification or encryption key, basic derivation\n  X25519_Cipher_Salt = \"1AAH\";\n  // X25519 100 char b64 Cipher of 24 char qb64 Salt\n  ECDSA_256r1N = \"1AAI\";\n  // ECDSA secp256r1 verification key non-transferable, basic derivation.\n  ECDSA_256r1 = \"1AAJ\";\n  // ECDSA secp256r1 verification or encryption key, basic derivation\n  StrB64_Big_L0 = \"7AAA\";\n  // String Base64 Only Big Lead Size 0\n  StrB64_Big_L1 = \"8AAA\";\n  // String Base64 Only Big Lead Size 1\n  StrB64_Big_L2 = \"9AAA\";\n  // String Base64 Only Big Lead Size 2\n};\nvar MtrDex = new MatterCodex();\nvar NonTransCodex = class extends Codex {\n  Ed25519N = \"B\";\n  // Ed25519 verification key non-transferable, basic derivation.\n  ECDSA_256k1N = \"1AAA\";\n  // ECDSA secp256k1 verification key non-transferable, basic derivation.\n  Ed448N = \"1AAC\";\n  // Ed448 non-transferable prefix public signing verification key. Basic derivation.\n  ECDSA_256r1N = \"1AAI\";\n  // ECDSA secp256r1 verification key non-transferable, basic derivation.\n};\nvar NonTransDex = new NonTransCodex();\nvar DigiCodex = class extends Codex {\n  Blake3_256 = \"E\";\n  // Blake3 256 bit digest self-addressing derivation.\n  Blake2b_256 = \"F\";\n  // Blake2b 256 bit digest self-addressing derivation.\n  Blake2s_256 = \"G\";\n  // Blake2s 256 bit digest self-addressing derivation.\n  SHA3_256 = \"H\";\n  // SHA3 256 bit digest self-addressing derivation.\n  SHA2_256 = \"I\";\n  // SHA2 256 bit digest self-addressing derivation.\n  Blake3_512 = \"0D\";\n  // Blake3 512 bit digest self-addressing derivation.\n  Blake2b_512 = \"0E\";\n  // Blake2b 512 bit digest self-addressing derivation.\n  SHA3_512 = \"0F\";\n  // SHA3 512 bit digest self-addressing derivation.\n  SHA2_512 = \"0G\";\n  // SHA2 512 bit digest self-addressing derivation.\n};\nvar DigiDex = new DigiCodex();\nvar NumCodex = class extends Codex {\n  Short = \"M\";\n  // Short 2 byte b2 number\n  Long = \"0H\";\n  // Long 4 byte b2 number\n  Big = \"N\";\n  // Big 8 byte b2 number\n  Huge = \"0A\";\n  // Huge 16 byte b2 number (same as Salt_128)\n};\nvar NumDex = new NumCodex();\nvar BexCodex = class extends Codex {\n  StrB64_L0 = \"4A\";\n  // String Base64 Only Leader Size 0\n  StrB64_L1 = \"5A\";\n  // String Base64 Only Leader Size 1\n  StrB64_L2 = \"6A\";\n  // String Base64 Only Leader Size 2\n  StrB64_Big_L0 = \"7AAA\";\n  // String Base64 Only Big Leader Size 0\n  StrB64_Big_L1 = \"8AAA\";\n  // String Base64 Only Big Leader Size 1\n  StrB64_Big_L2 = \"9AAA\";\n  // String Base64 Only Big Leader Size 2\n};\nvar BexDex = new BexCodex();\nvar SmallVarRawSizeCodex = class extends Codex {\n  Lead0 = \"4\";\n  // First Selector Character for all ls == 0 codes\n  Lead1 = \"5\";\n  // First Selector Character for all ls == 1 codes\n  Lead2 = \"6\";\n  // First Selector Character for all ls == 2 codes\n};\nvar SmallVrzDex = new SmallVarRawSizeCodex();\nvar LargeVarRawSizeCodex = class extends Codex {\n  Lead0_Big = \"7\";\n  // First Selector Character for all ls == 0 codes\n  Lead1_Big = \"8\";\n  // First Selector Character for all ls == 1 codes\n  Lead2_Big = \"9\";\n  // First Selector Character for all ls == 2 codes\n};\nvar LargeVrzDex = new LargeVarRawSizeCodex();\nvar Sizage = class {\n  hs;\n  ss;\n  ls;\n  fs;\n  constructor(hs, ss, fs, ls) {\n    this.hs = hs;\n    this.ss = ss;\n    this.fs = fs;\n    this.ls = ls;\n  }\n};\nvar Matter = class _Matter {\n  static Sizes = new Map(\n    Object.entries({\n      A: new Sizage(1, 0, 44, 0),\n      B: new Sizage(1, 0, 44, 0),\n      C: new Sizage(1, 0, 44, 0),\n      D: new Sizage(1, 0, 44, 0),\n      E: new Sizage(1, 0, 44, 0),\n      F: new Sizage(1, 0, 44, 0),\n      G: new Sizage(1, 0, 44, 0),\n      H: new Sizage(1, 0, 44, 0),\n      I: new Sizage(1, 0, 44, 0),\n      J: new Sizage(1, 0, 44, 0),\n      K: new Sizage(1, 0, 76, 0),\n      L: new Sizage(1, 0, 76, 0),\n      M: new Sizage(1, 0, 4, 0),\n      N: new Sizage(1, 0, 12, 0),\n      O: new Sizage(1, 0, 44, 0),\n      P: new Sizage(1, 0, 124, 0),\n      Q: new Sizage(1, 0, 44, 0),\n      \"0A\": new Sizage(2, 0, 24, 0),\n      \"0B\": new Sizage(2, 0, 88, 0),\n      \"0C\": new Sizage(2, 0, 88, 0),\n      \"0D\": new Sizage(2, 0, 88, 0),\n      \"0E\": new Sizage(2, 0, 88, 0),\n      \"0F\": new Sizage(2, 0, 88, 0),\n      \"0G\": new Sizage(2, 0, 88, 0),\n      \"0H\": new Sizage(2, 0, 8, 0),\n      \"0I\": new Sizage(2, 0, 88, 0),\n      \"1AAA\": new Sizage(4, 0, 48, 0),\n      \"1AAB\": new Sizage(4, 0, 48, 0),\n      \"1AAC\": new Sizage(4, 0, 80, 0),\n      \"1AAD\": new Sizage(4, 0, 80, 0),\n      \"1AAE\": new Sizage(4, 0, 56, 0),\n      \"1AAF\": new Sizage(4, 0, 8, 0),\n      \"1AAG\": new Sizage(4, 0, 36, 0),\n      \"1AAH\": new Sizage(4, 0, 100, 0),\n      \"1AAI\": new Sizage(4, 0, 48, 0),\n      \"1AAJ\": new Sizage(4, 0, 48, 0),\n      \"2AAA\": new Sizage(4, 0, 8, 1),\n      \"3AAA\": new Sizage(4, 0, 8, 2),\n      \"4A\": new Sizage(2, 2, void 0, 0),\n      \"5A\": new Sizage(2, 2, void 0, 1),\n      \"6A\": new Sizage(2, 2, void 0, 2),\n      \"7AAA\": new Sizage(4, 4, void 0, 0),\n      \"8AAA\": new Sizage(4, 4, void 0, 1),\n      \"9AAA\": new Sizage(4, 4, void 0, 2),\n      \"4B\": new Sizage(2, 2, void 0, 0),\n      \"5B\": new Sizage(2, 2, void 0, 1),\n      \"6B\": new Sizage(2, 2, void 0, 2),\n      \"7AAB\": new Sizage(4, 4, void 0, 0),\n      \"8AAB\": new Sizage(4, 4, void 0, 1),\n      \"9AAB\": new Sizage(4, 4, void 0, 2)\n    })\n  );\n  static Hards = /* @__PURE__ */ new Map([\n    [\"A\", 1],\n    [\"B\", 1],\n    [\"C\", 1],\n    [\"D\", 1],\n    [\"E\", 1],\n    [\"F\", 1],\n    [\"G\", 1],\n    [\"H\", 1],\n    [\"I\", 1],\n    [\"J\", 1],\n    [\"K\", 1],\n    [\"L\", 1],\n    [\"M\", 1],\n    [\"N\", 1],\n    [\"O\", 1],\n    [\"P\", 1],\n    [\"Q\", 1],\n    [\"R\", 1],\n    [\"S\", 1],\n    [\"T\", 1],\n    [\"U\", 1],\n    [\"V\", 1],\n    [\"W\", 1],\n    [\"X\", 1],\n    [\"Y\", 1],\n    [\"Z\", 1],\n    [\"a\", 1],\n    [\"b\", 1],\n    [\"c\", 1],\n    [\"d\", 1],\n    [\"e\", 1],\n    [\"f\", 1],\n    [\"g\", 1],\n    [\"h\", 1],\n    [\"i\", 1],\n    [\"j\", 1],\n    [\"k\", 1],\n    [\"l\", 1],\n    [\"m\", 1],\n    [\"n\", 1],\n    [\"o\", 1],\n    [\"p\", 1],\n    [\"q\", 1],\n    [\"r\", 1],\n    [\"s\", 1],\n    [\"t\", 1],\n    [\"u\", 1],\n    [\"v\", 1],\n    [\"w\", 1],\n    [\"x\", 1],\n    [\"y\", 1],\n    [\"z\", 1],\n    [\"0\", 2],\n    [\"1\", 4],\n    [\"2\", 4],\n    [\"3\", 4],\n    [\"4\", 2],\n    [\"5\", 2],\n    [\"6\", 2],\n    [\"7\", 4],\n    [\"8\", 4],\n    [\"9\", 4]\n  ]);\n  _code = \"\";\n  _size = -1;\n  _raw = new Uint8Array(0);\n  constructor({\n    raw,\n    code = MtrDex.Ed25519N,\n    qb64b,\n    qb64,\n    qb2,\n    rize\n  }) {\n    let size = -1;\n    if (raw != void 0) {\n      if (code.length == 0) {\n        throw new Error(\n          \"Improper initialization need either (raw and code) or qb64b or qb64 or qb2.\"\n        );\n      }\n      if (SmallVrzDex.has(code[0]) || LargeVrzDex.has(code[0])) {\n        if (rize !== void 0) {\n          if (rize < 0)\n            throw new Error(\n              `missing var raw size for code=${code}`\n            );\n        } else {\n          rize = raw.length;\n        }\n        const ls = (3 - rize % 3) % 3;\n        size = Math.floor((rize + ls) / 3);\n        if (SmallVrzDex.has(code[0])) {\n          if (size <= 64 ** 2 - 1) {\n            const hs = 2;\n            const s = Object.values(SmallVrzDex)[ls];\n            code = `${s}${code.substring(1, hs)}`;\n          } else if (size <= 64 ** 4 - 1) {\n            const hs = 4;\n            const s = Object.values(LargeVrzDex)[ls];\n            code = `${s}${\"AAAA\".substring(0, hs - 2)}${code[1]}`;\n          } else {\n            throw new Error(\n              `Unsupported raw size for code=${code}`\n            );\n          }\n        } else {\n          if (size <= 64 ** 4 - 1) {\n            const hs = 4;\n            const s = Object.values(LargeVrzDex)[ls];\n            code = `${s}${code.substring(1, hs)}`;\n          } else {\n            throw new Error(\n              `Unsupported raw size for code=${code}`\n            );\n          }\n        }\n      } else {\n        const sizage = _Matter.Sizes.get(code);\n        if (sizage.fs == -1) {\n          throw new Error(`Unsupported variable size code=${code}`);\n        }\n        rize = _Matter._rawSize(code);\n      }\n      raw = raw.slice(0, rize);\n      if (raw.length != rize) {\n        throw new Error(\n          `Not enougth raw bytes for code=${code} expected ${rize} got ${raw.length}.`\n        );\n      }\n      this._code = code;\n      this._size = size;\n      this._raw = raw;\n    } else if (qb64 !== void 0) {\n      this._exfil(qb64);\n    } else if (qb64b !== void 0) {\n      const qb642 = d(qb64b);\n      this._exfil(qb642);\n    } else if (qb2 !== void 0) {\n      this._bexfil(qb2);\n    } else {\n      throw new EmptyMaterialError(\"EmptyMaterialError\");\n    }\n  }\n  get code() {\n    return this._code;\n  }\n  get size() {\n    return this._size;\n  }\n  get raw() {\n    return this._raw;\n  }\n  get qb64() {\n    return this._infil();\n  }\n  get qb64b() {\n    return b(this.qb64);\n  }\n  get transferable() {\n    return !NonTransDex.has(this.code);\n  }\n  get digestive() {\n    return DigiDex.has(this.code);\n  }\n  static _rawSize(code) {\n    const sizage = this.Sizes.get(code);\n    const cs = sizage.hs + sizage.ss;\n    if (sizage.fs === -1) {\n      throw Error(`Non-fixed raw size code ${code}.`);\n    }\n    return Math.floor((sizage.fs - cs) * 3 / 4) - sizage.ls;\n  }\n  static _leadSize(code) {\n    const sizage = this.Sizes.get(code);\n    return sizage.ls;\n  }\n  get both() {\n    const sizage = _Matter.Sizes.get(this.code);\n    return `${this.code}${intToB64(this.size, sizage.ss)}`;\n  }\n  _infil() {\n    const code = this.code;\n    const size = this.size;\n    const raw = this.raw;\n    const ps = (3 - raw.length % 3) % 3;\n    const sizage = _Matter.Sizes.get(code);\n    if (sizage.fs === void 0) {\n      const cs = sizage.hs + sizage.ss;\n      if (cs % 4) {\n        throw new Error(\n          `Whole code size not multiple of 4 for variable length material. cs=${cs}`\n        );\n      }\n      if (size < 0 || size > 64 ** sizage.ss - 1) {\n        throw new Error(`Invalid size=${size} for code=${code}.`);\n      }\n      const both = `${code}${intToB64(size, sizage.ss)}`;\n      if (both.length % 4 !== ps - sizage.ls) {\n        throw new Error(\n          `Invalid code=${both} for converted raw pad size=${ps}.`\n        );\n      }\n      const bytes = new Uint8Array(sizage.ls + raw.length);\n      for (let i = 0; i < sizage.ls; i++) {\n        bytes[i] = 0;\n      }\n      for (let i = 0; i < raw.length; i++) {\n        const odx = i + ps;\n        bytes[odx] = raw[i];\n      }\n      return both + encodeBase64Url(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(bytes));\n    } else {\n      const both = code;\n      const cs = both.length;\n      if (cs % 4 != ps - sizage.ls) {\n        throw new Error(\n          `Invalid code=${both} for converted raw pad size=${ps}, ${raw.length}.`\n        );\n      }\n      const bytes = new Uint8Array(ps + raw.length);\n      for (let i = 0; i < ps; i++) {\n        bytes[i] = 0;\n      }\n      for (let i = 0; i < raw.length; i++) {\n        const odx = i + ps;\n        bytes[odx] = raw[i];\n      }\n      return both + encodeBase64Url(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(bytes)).slice(cs % 4);\n    }\n  }\n  _exfil(qb64) {\n    if (qb64.length == 0) {\n      throw new Error(\"Empty Material\");\n    }\n    const first = qb64[0];\n    if (!Array.from(_Matter.Hards.keys()).includes(first)) {\n      throw new Error(`Unexpected code ${first}`);\n    }\n    const hs = _Matter.Hards.get(first);\n    if (qb64.length < hs) {\n      throw new Error(`Shortage Error`);\n    }\n    const hard = qb64.slice(0, hs);\n    if (!Array.from(_Matter.Sizes.keys()).includes(hard)) {\n      throw new Error(`Unsupported code ${hard}`);\n    }\n    const sizage = _Matter.Sizes.get(hard);\n    const cs = sizage.hs + sizage.ss;\n    let size = -1;\n    if (sizage.fs == -1) {\n      throw new Error(\"Variable size codes not supported yet\");\n    } else {\n      size = sizage.fs;\n    }\n    if (qb64.length < sizage.fs) {\n      throw new Error(`Need ${sizage.fs - qb64.length} more chars.`);\n    }\n    qb64 = qb64.slice(0, sizage.fs);\n    const ps = cs % 4;\n    const pbs = 2 * (ps == 0 ? sizage.ls : ps);\n    let raw;\n    if (ps != 0) {\n      const base = new Array(ps + 1).join(\"A\") + qb64.slice(cs);\n      const paw = decodeBase64Url(base);\n      const pi = readInt(paw.subarray(0, ps));\n      if (pi & 2 ** pbs - 1) {\n        throw new Error(\n          `Non zeroed prepad bits = {pi & (2 ** pbs - 1 ):<06b} in {qb64b[cs:cs+1]}.`\n        );\n      }\n      raw = paw.subarray(ps);\n    } else {\n      const base = qb64.slice(cs);\n      const paw = decodeBase64Url(base);\n      const li = readInt(paw.subarray(0, sizage.ls));\n      if (li != 0) {\n        if (li == 1) {\n          throw new Error(`Non zeroed lead byte = 0x{li:02x}.`);\n        } else {\n          throw new Error(`Non zeroed lead bytes = 0x{li:04x}`);\n        }\n      }\n      raw = paw.subarray(sizage.ls);\n    }\n    this._code = hard;\n    this._size = size;\n    this._raw = Uint8Array.from(raw);\n  }\n  _bexfil(qb2) {\n    throw new Error(`qb2 not yet supported: ${qb2}`);\n  }\n};\n\n// src/keri/core/verfer.ts\n\n\nvar Verfer = class extends Matter {\n  _verify;\n  constructor({ raw, code, qb64, qb64b, qb2 }) {\n    super({ raw, code, qb64, qb64b, qb2 });\n    if (Array.from([MtrDex.Ed25519N, MtrDex.Ed25519]).includes(this.code)) {\n      this._verify = this._ed25519;\n    } else if (Array.from([MtrDex.ECDSA_256r1N, MtrDex.ECDSA_256r1]).includes(\n      this.code\n    )) {\n      this._verify = this._secp256r1;\n    } else {\n      throw new Error(`Unsupported code = ${this.code} for verifier.`);\n    }\n  }\n  verify(sig, ser) {\n    return this._verify(sig, ser, this.raw);\n  }\n  _ed25519(sig, ser, key) {\n    try {\n      return libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_verify_detached(sig, ser, key);\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n  _secp256r1(sig, ser, key) {\n    try {\n      const publicKey = ecdsa_secp256r1__WEBPACK_IMPORTED_MODULE_2__.fromCompressedPublicKey(key);\n      return publicKey.verify(ser, sig);\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n};\n\n// src/keri/core/signer.ts\n\n\n// src/keri/core/cigar.ts\nvar Cigar = class extends Matter {\n  _verfer;\n  constructor({ raw, code, qb64, qb64b, qb2 }, verfer) {\n    super({ raw, code, qb64, qb64b, qb2 });\n    this._verfer = verfer;\n  }\n  get verfer() {\n    return this._verfer;\n  }\n  set verfer(verfer) {\n    this._verfer = verfer;\n  }\n};\n\n// src/keri/core/indexer.ts\n\nvar IndexerCodex = class {\n  Ed25519_Sig = \"A\";\n  // Ed25519 sig appears same in both lists if any.\n  Ed25519_Crt_Sig = \"B\";\n  // Ed25519 sig appears in current list only.\n  ECDSA_256k1_Sig = \"C\";\n  // ECDSA secp256k1 sig appears same in both lists if any.\n  ECDSA_256k1_Crt_Sig = \"D\";\n  // ECDSA secp256k1 sig appears in current list.\n  ECDSA_256r1_Sig = \"E\";\n  // ECDSA secp256r1 sig appears same in both lists if any.\n  ECDSA_256r1_Crt_Sig = \"F\";\n  // ECDSA secp256r1 sig appears in current list.\n  Ed448_Sig = \"0A\";\n  // Ed448 signature appears in both lists.\n  Ed448_Crt_Sig = \"0B\";\n  // Ed448 signature appears in current list only.\n  Ed25519_Big_Sig = \"2A\";\n  // Ed25519 sig appears in both lists.\n  Ed25519_Big_Crt_Sig = \"2B\";\n  // Ed25519 sig appears in current list only.\n  ECDSA_256k1_Big_Sig = \"2C\";\n  // ECDSA secp256k1 sig appears in both lists.\n  ECDSA_256k1_Big_Crt_Sig = \"2D\";\n  // ECDSA secp256k1 sig appears in current list only.\n  ECDSA_256r1_Big_Sig = \"2E\";\n  // ECDSA secp256r1 sig appears in both lists.\n  ECDSA_256r1_Big_Crt_Sig = \"2F\";\n  // ECDSA secp256r1 sig appears in current list only.\n  Ed448_Big_Sig = \"3A\";\n  // Ed448 signature appears in both lists.\n  Ed448_Big_Crt_Sig = \"3B\";\n  // Ed448 signature appears in current list only.\n};\nvar IdrDex = new IndexerCodex();\nvar IndexedSigCodex = class {\n  Ed25519_Sig = \"A\";\n  // Ed25519 sig appears same in both lists if any.\n  Ed25519_Crt_Sig = \"B\";\n  // Ed25519 sig appears in current list only.\n  ECDSA_256k1_Sig = \"C\";\n  // ECDSA secp256k1 sig appears same in both lists if any.\n  ECDSA_256k1_Crt_Sig = \"D\";\n  // ECDSA secp256k1 sig appears in current list.\n  ECDSA_256r1_Sig = \"E\";\n  // ECDSA secp256r1 sig appears same in both lists if any.\n  ECDSA_256r1_Crt_Sig = \"F\";\n  // ECDSA secp256r1 sig appears in current list.\n  Ed448_Sig = \"0A\";\n  // Ed448 signature appears in both lists.\n  Ed448_Crt_Sig = \"0B\";\n  // Ed448 signature appears in current list only.\n  Ed25519_Big_Sig = \"2A\";\n  // Ed25519 sig appears in both lists.\n  Ed25519_Big_Crt_Sig = \"2B\";\n  // Ed25519 sig appears in current list only.\n  ECDSA_256k1_Big_Sig = \"2C\";\n  // ECDSA secp256k1 sig appears in both lists.\n  ECDSA_256k1_Big_Crt_Sig = \"2D\";\n  // ECDSA secp256k1 sig appears in current list only.\n  ECDSA_256r1_Big_Sig = \"2E\";\n  // ECDSA secp256r1 sig appears in both lists.\n  ECDSA_256r1_Big_Crt_Sig = \"2F\";\n  // ECDSA secp256r1 sig appears in current list only.\n  Ed448_Big_Sig = \"3A\";\n  // Ed448 signature appears in both lists.\n  Ed448_Big_Crt_Sig = \"3B\";\n  // Ed448 signature appears in current list only.\n  has(prop) {\n    const m = new Map(\n      Array.from(Object.entries(this), (v) => [v[1], v[0]])\n    );\n    return m.has(prop);\n  }\n};\nvar IdxSigDex = new IndexedSigCodex();\nvar IndexedCurrentSigCodex = class {\n  Ed25519_Crt_Sig = \"B\";\n  // Ed25519 sig appears in current list only.\n  ECDSA_256k1_Crt_Sig = \"D\";\n  // ECDSA secp256k1 sig appears in current list only.\n  ECDSA_256r1_Crt_Sig = \"F\";\n  // ECDSA secp256r1 sig appears in current list.\n  Ed448_Crt_Sig = \"0B\";\n  // Ed448 signature appears in current list only.\n  Ed25519_Big_Crt_Sig = \"2B\";\n  // Ed25519 sig appears in current list only.\n  ECDSA_256k1_Big_Crt_Sig = \"2D\";\n  // ECDSA secp256k1 sig appears in current list only.\n  ECDSA_256r1_Big_Crt_Sig = \"2F\";\n  // ECDSA secp256r1 sig appears in current list only.\n  Ed448_Big_Crt_Sig = \"3B\";\n  // Ed448 signature appears in current list only.\n  has(prop) {\n    const m = new Map(\n      Array.from(Object.entries(this), (v) => [v[1], v[0]])\n    );\n    return m.has(prop);\n  }\n};\nvar IdxCrtSigDex = new IndexedCurrentSigCodex();\nvar IndexedBothSigCodex = class {\n  Ed25519_Sig = \"A\";\n  // Ed25519 sig appears same in both lists if any.\n  ECDSA_256k1_Sig = \"C\";\n  // ECDSA secp256k1 sig appears same in both lists if any.\n  Ed448_Sig = \"0A\";\n  // Ed448 signature appears in both lists.\n  Ed25519_Big_Sig = \"2A\";\n  // Ed25519 sig appears in both listsy.\n  ECDSA_256k1_Big_Sig = \"2C\";\n  // ECDSA secp256k1 sig appears in both lists.\n  Ed448_Big_Sig = \"3A\";\n  // Ed448 signature appears in both lists.\n  has(prop) {\n    const m = new Map(\n      Array.from(Object.entries(this), (v) => [v[1], v[0]])\n    );\n    return m.has(prop);\n  }\n};\nvar IdxBthSigDex = new IndexedBothSigCodex();\nvar Xizage = class {\n  hs;\n  ss;\n  os;\n  fs;\n  ls;\n  constructor(hs, ss, os, fs, ls) {\n    this.hs = hs;\n    this.ss = ss;\n    this.os = os;\n    this.fs = fs;\n    this.ls = ls;\n  }\n};\nvar Indexer = class _Indexer {\n  Codex = IdrDex;\n  static Hards = /* @__PURE__ */ new Map([\n    [\"A\", 1],\n    [\"B\", 1],\n    [\"C\", 1],\n    [\"D\", 1],\n    [\"E\", 1],\n    [\"F\", 1],\n    [\"G\", 1],\n    [\"H\", 1],\n    [\"I\", 1],\n    [\"J\", 1],\n    [\"K\", 1],\n    [\"L\", 1],\n    [\"M\", 1],\n    [\"N\", 1],\n    [\"O\", 1],\n    [\"P\", 1],\n    [\"Q\", 1],\n    [\"R\", 1],\n    [\"S\", 1],\n    [\"T\", 1],\n    [\"U\", 1],\n    [\"V\", 1],\n    [\"W\", 1],\n    [\"X\", 1],\n    [\"Y\", 1],\n    [\"Z\", 1],\n    [\"a\", 1],\n    [\"b\", 1],\n    [\"c\", 1],\n    [\"d\", 1],\n    [\"e\", 1],\n    [\"f\", 1],\n    [\"g\", 1],\n    [\"h\", 1],\n    [\"i\", 1],\n    [\"j\", 1],\n    [\"k\", 1],\n    [\"l\", 1],\n    [\"m\", 1],\n    [\"n\", 1],\n    [\"o\", 1],\n    [\"p\", 1],\n    [\"q\", 1],\n    [\"r\", 1],\n    [\"s\", 1],\n    [\"t\", 1],\n    [\"u\", 1],\n    [\"v\", 1],\n    [\"w\", 1],\n    [\"x\", 1],\n    [\"y\", 1],\n    [\"z\", 1],\n    [\"0\", 2],\n    [\"1\", 2],\n    [\"2\", 2],\n    [\"3\", 2],\n    [\"4\", 2]\n  ]);\n  static Sizes = new Map(\n    Object.entries({\n      A: new Xizage(1, 1, 0, 88, 0),\n      B: new Xizage(1, 1, 0, 88, 0),\n      C: new Xizage(1, 1, 0, 88, 0),\n      D: new Xizage(1, 1, 0, 88, 0),\n      E: new Xizage(1, 1, 0, 88, 0),\n      F: new Xizage(1, 1, 0, 88, 0),\n      \"0A\": new Xizage(2, 2, 1, 156, 0),\n      \"0B\": new Xizage(2, 2, 1, 156, 0),\n      \"2A\": new Xizage(2, 4, 2, 92, 0),\n      \"2B\": new Xizage(2, 4, 2, 92, 0),\n      \"2C\": new Xizage(2, 4, 2, 92, 0),\n      \"2D\": new Xizage(2, 4, 2, 92, 0),\n      \"2E\": new Xizage(2, 4, 2, 92, 0),\n      \"2F\": new Xizage(2, 4, 2, 92, 0),\n      \"3A\": new Xizage(2, 6, 3, 160, 0),\n      \"3B\": new Xizage(2, 6, 3, 160, 0),\n      \"0z\": new Xizage(2, 2, 0, void 0, 0),\n      \"1z\": new Xizage(2, 2, 1, 76, 1),\n      \"4z\": new Xizage(2, 6, 3, 80, 1)\n    })\n  );\n  _code = \"\";\n  _index = -1;\n  _ondex;\n  _raw = new Uint8Array(0);\n  constructor({\n    raw = void 0,\n    code = IdrDex.Ed25519_Sig,\n    index = 0,\n    ondex = void 0,\n    qb64b = void 0,\n    qb64 = void 0,\n    qb2 = void 0\n  }) {\n    if (raw != void 0) {\n      if (code == void 0) {\n        throw new EmptyMaterialError(\n          `Improper initialization need either (raw and code) or qb64b or qb64 or qb2.`\n        );\n      }\n      if (!_Indexer.Sizes.has(code)) {\n        throw new Error(`Unsupported code=${code}.`);\n      }\n      const xizage = _Indexer.Sizes.get(code);\n      const os = xizage.os;\n      const fs = xizage.fs;\n      const cs = xizage.hs + xizage.ss;\n      const ms = xizage.ss - xizage.os;\n      if (!Number.isInteger(index) || index < 0 || index > 64 ** ms - 1) {\n        throw new Error(`Invalid index=${index} for code=${code}.`);\n      }\n      if (ondex != void 0 && xizage.os != 0 && !(ondex >= 0 && ondex <= 64 ** os - 1)) {\n        throw new Error(`Invalid ondex=${ondex} for code=${code}.`);\n      }\n      if (IdxCrtSigDex.has(code) && ondex != void 0) {\n        throw new Error(`Non None ondex=${ondex} for code=${code}.`);\n      }\n      if (IdxBthSigDex.has(code)) {\n        if (ondex == void 0) {\n          ondex = index;\n        } else {\n          if (ondex != index && os == 0) {\n            throw new Error(\n              `Non matching ondex=${ondex} and index=${index} for code=${code}.`\n            );\n          }\n        }\n      }\n      if (fs == void 0) {\n        throw new Error(\"variable length unsupported\");\n      }\n      const rawsize = Math.floor((fs - cs) * 3 / 4);\n      raw = raw.slice(0, rawsize);\n      if (raw.length != rawsize) {\n        throw new Error(\n          `Not enougth raw bytes for code=${code} and index=${index} ,expected ${rawsize} got ${raw.length}.`\n        );\n      }\n      this._code = code;\n      this._index = index;\n      this._ondex = ondex;\n      this._raw = raw;\n    } else if (qb64b != void 0) {\n      const qb642 = d(qb64b);\n      this._exfil(qb642);\n    } else if (qb64 != void 0) {\n      this._exfil(qb64);\n    } else if (qb2 != void 0) {\n      this._bexfil(qb2);\n    } else {\n      throw new EmptyMaterialError(\n        `Improper initialization need either (raw and code and index) or qb64b or qb64 or qb2.`\n      );\n    }\n  }\n  _bexfil(qb2) {\n    throw new Error(`qb2 not yet supported: ${qb2}`);\n  }\n  static _rawSize(code) {\n    const xizage = _Indexer.Sizes.get(code);\n    return Math.floor(xizage.fs - (xizage.hs + xizage.ss) * 3 / 4);\n  }\n  get code() {\n    return this._code;\n  }\n  get raw() {\n    return this._raw;\n  }\n  get index() {\n    return this._index;\n  }\n  get ondex() {\n    return this._ondex;\n  }\n  get qb64() {\n    return this._infil();\n  }\n  get qb64b() {\n    return b(this.qb64);\n  }\n  _infil() {\n    const code = this.code;\n    const index = this.index;\n    const ondex = this.ondex;\n    const raw = this.raw;\n    const ps = (3 - raw.length % 3) % 3;\n    const xizage = _Indexer.Sizes.get(code);\n    const cs = xizage.hs + xizage.ss;\n    const ms = xizage.ss - xizage.os;\n    if (index < 0 || index > 64 ** ms - 1) {\n      throw new Error(`Invalid index=${index} for code=${code}.`);\n    }\n    if (ondex != void 0 && xizage.os != 0 && !(ondex >= 0 && ondex <= 64 ** xizage.os - 1)) {\n      throw new Error(\n        `Invalid ondex=${ondex} for os=${xizage.os} and code=${code}.`\n      );\n    }\n    const both = `${code}${intToB64(index, ms)}${intToB64(\n      ondex == void 0 ? 0 : ondex,\n      xizage.os\n    )}`;\n    if (both.length != cs) {\n      throw new Error(\n        `Mismatch code size = ${cs} with table = ${both.length}.`\n      );\n    }\n    if (cs % 4 != ps - xizage.ls) {\n      throw new Error(\n        `Invalid code=${both} for converted raw pad size=${ps}.`\n      );\n    }\n    const bytes = new Uint8Array(ps + raw.length);\n    for (let i = 0; i < ps; i++) {\n      bytes[i] = 0;\n    }\n    for (let i = 0; i < raw.length; i++) {\n      const odx = i + ps;\n      bytes[odx] = raw[i];\n    }\n    const full = both + encodeBase64Url(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(bytes)).slice(ps - xizage.ls);\n    if (full.length != xizage.fs) {\n      throw new Error(`Invalid code=${both} for raw size=${raw.length}.`);\n    }\n    return full;\n  }\n  _exfil(qb64) {\n    if (qb64.length == 0) {\n      throw new Error(\"Empty Material\");\n    }\n    const first = qb64[0];\n    if (!Array.from(_Indexer.Hards.keys()).includes(first)) {\n      throw new Error(`Unexpected code ${first}`);\n    }\n    const hs = _Indexer.Hards.get(first);\n    if (qb64.length < hs) {\n      throw new Error(`Need ${hs - qb64.length} more characters.`);\n    }\n    const hard = qb64.slice(0, hs);\n    if (!Array.from(_Indexer.Sizes.keys()).includes(hard)) {\n      throw new Error(`Unsupported code ${hard}`);\n    }\n    const xizage = _Indexer.Sizes.get(hard);\n    const cs = xizage.hs + xizage.ss;\n    const ms = xizage.ss - xizage.os;\n    if (qb64.length < cs) {\n      throw new Error(`Need ${cs - qb64.length} more characters.`);\n    }\n    const sindex = qb64.slice(hs, hs + ms);\n    const index = b64ToInt(sindex);\n    const sondex = qb64.slice(hs + ms, hs + ms + xizage.os);\n    let ondex;\n    if (IdxCrtSigDex.has(hard)) {\n      ondex = xizage.os != 0 ? b64ToInt(sondex) : void 0;\n      if (ondex != 0 && ondex != void 0) {\n        throw new Error(`Invalid ondex=${ondex} for code=${hard}.`);\n      } else {\n        ondex = void 0;\n      }\n    } else {\n      ondex = xizage.os != 0 ? b64ToInt(sondex) : index;\n    }\n    if (xizage.fs == void 0) {\n      throw new Error(\"variable length not supported\");\n    }\n    if (qb64.length < xizage.fs) {\n      throw new Error(`Need ${xizage.fs - qb64.length} more chars.`);\n    }\n    qb64 = qb64.slice(0, xizage.fs);\n    const ps = cs % 4;\n    const pbs = 2 * ps != 0 ? ps : xizage.ls;\n    let raw;\n    if (ps != 0) {\n      const base = new Array(ps + 1).join(\"A\") + qb64.slice(cs);\n      const paw = decodeBase64Url(base);\n      const pi = readInt(paw.slice(0, ps));\n      if (pi & 2 ** pbs - 1) {\n        throw new Error(\n          `Non zeroed prepad bits = {pi & (2 ** pbs - 1 ):<06b} in {qb64b[cs:cs+1]}.`\n        );\n      }\n      raw = paw.slice(ps);\n    } else {\n      const base = qb64.slice(cs);\n      const paw = decodeBase64Url(base);\n      const li = readInt(paw.slice(0, xizage.ls));\n      if (li != 0) {\n        if (li == 1) {\n          throw new Error(`Non zeroed lead byte = 0x{li:02x}.`);\n        } else {\n          throw new Error(`Non zeroed lead bytes = 0x{li:04x}`);\n        }\n      }\n      raw = paw.slice(xizage.ls);\n    }\n    if (raw.length != Math.floor((qb64.length - cs) * 3 / 4)) {\n      throw new Error(`Improperly qualified material = ${qb64}`);\n    }\n    this._code = hard;\n    this._index = index;\n    this._ondex = ondex;\n    this._raw = new Uint8Array(raw);\n  }\n};\n\n// src/keri/core/siger.ts\nvar Siger = class extends Indexer {\n  _verfer;\n  constructor({ raw, code, index, ondex, qb64, qb64b, qb2 }, verfer) {\n    super({ raw, code, index, ondex, qb64, qb64b, qb2 });\n    if (!IdxSigDex.has(this.code)) {\n      throw new Error(`Invalid code = ${this.code} for Siger.`);\n    }\n    this._verfer = verfer;\n  }\n  get verfer() {\n    return this._verfer;\n  }\n  set verfer(verfer) {\n    this._verfer = verfer;\n  }\n};\n\n// src/keri/core/signer.ts\n\nvar Signer = class extends Matter {\n  _sign;\n  _verfer;\n  constructor({\n    raw,\n    code = MtrDex.Ed25519_Seed,\n    qb64,\n    qb64b,\n    qb2,\n    transferable = true\n  }) {\n    try {\n      super({ raw, code, qb64, qb64b, qb2 });\n    } catch (e) {\n      if (e instanceof EmptyMaterialError) {\n        if (code == MtrDex.Ed25519_Seed) {\n          const raw2 = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.randombytes_buf(\n            libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_SEEDBYTES\n          );\n          super({ raw: raw2, code, qb64, qb64b, qb2 });\n        } else {\n          throw new Error(`Unsupported signer code = ${code}.`);\n        }\n      } else {\n        throw e;\n      }\n    }\n    let verfer;\n    if (this.code == MtrDex.Ed25519_Seed) {\n      this._sign = this._ed25519;\n      const keypair = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_seed_keypair(this.raw);\n      verfer = new Verfer({\n        raw: keypair.publicKey,\n        code: transferable ? MtrDex.Ed25519 : MtrDex.Ed25519N\n      });\n    } else {\n      throw new Error(`Unsupported signer code = ${this.code}.`);\n    }\n    this._verfer = verfer;\n  }\n  /**\n   * @description Property verfer:\n   Returns Verfer instance\n   Assumes ._verfer is correctly assigned\n   */\n  get verfer() {\n    return this._verfer;\n  }\n  sign(ser, index = null, only = false, ondex = void 0) {\n    return this._sign(ser, this.raw, this.verfer, index, only, ondex);\n  }\n  _ed25519(ser, seed, verfer, index, only = false, ondex) {\n    const sig = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_detached(\n      ser,\n      buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.concat([seed, verfer.raw])\n    );\n    if (index == null) {\n      return new Cigar({ raw: sig, code: MtrDex.Ed25519_Sig }, verfer);\n    } else {\n      let code;\n      if (only) {\n        ondex = void 0;\n        if (index <= 63) {\n          code = IdrDex.Ed25519_Crt_Sig;\n        } else {\n          code = IdrDex.Ed25519_Big_Crt_Sig;\n        }\n      } else {\n        if (ondex == void 0) {\n          ondex = index;\n        }\n        if (ondex == index && index <= 63)\n          code = IdrDex.Ed25519_Sig;\n        else\n          code = IdrDex.Ed25519_Big_Sig;\n      }\n      return new Siger(\n        { raw: sig, code, index, ondex },\n        verfer\n      );\n    }\n  }\n};\n\n// src/keri/core/decrypter.ts\n\n\n// src/keri/core/salter.ts\n\nvar Tier = /* @__PURE__ */ ((Tier3) => {\n  Tier3[\"low\"] = \"low\";\n  Tier3[\"med\"] = \"med\";\n  Tier3[\"high\"] = \"high\";\n  return Tier3;\n})(Tier || {});\nvar Salter = class extends Matter {\n  _tier;\n  constructor({\n    raw,\n    code = MtrDex.Salt_128,\n    tier = \"low\" /* low */,\n    qb64,\n    qb64b,\n    qb2\n  }) {\n    try {\n      super({ raw, code, qb64, qb64b, qb2 });\n    } catch (e) {\n      if (e instanceof EmptyMaterialError) {\n        if (code == MtrDex.Salt_128) {\n          const salt = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.randombytes_buf(\n            libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_pwhash_SALTBYTES\n          );\n          super({ raw: salt, code });\n        } else {\n          throw new Error(\n            \"invalid code for Salter, only Salt_128 accepted\"\n          );\n        }\n      } else {\n        throw e;\n      }\n    }\n    if (this.code != MtrDex.Salt_128) {\n      throw new Error(\"invalid code for Salter, only Salt_128 accepted\");\n    }\n    this._tier = tier !== null ? tier : \"low\" /* low */;\n  }\n  stretch(size = 32, path = \"\", tier = null, temp = false) {\n    tier = tier == null ? this.tier : tier;\n    let opslimit, memlimit;\n    if (temp) {\n      opslimit = 1;\n      memlimit = 8192;\n    } else {\n      switch (tier) {\n        case \"low\" /* low */:\n          opslimit = 2;\n          memlimit = 67108864;\n          break;\n        case \"med\" /* med */:\n          opslimit = 3;\n          memlimit = 268435456;\n          break;\n        case \"high\" /* high */:\n          opslimit = 4;\n          memlimit = 1073741824;\n          break;\n        default:\n          throw new Error(`Unsupported security tier = ${tier}.`);\n      }\n    }\n    return libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_pwhash(\n      size,\n      path,\n      this.raw,\n      opslimit,\n      memlimit,\n      libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_pwhash_ALG_ARGON2ID13\n    );\n  }\n  signer(code = MtrDex.Ed25519_Seed, transferable = true, path = \"\", tier = null, temp = false) {\n    const seed = this.stretch(Matter._rawSize(code), path, tier, temp);\n    return new Signer({\n      raw: seed,\n      code,\n      transferable\n    });\n  }\n  get tier() {\n    return this._tier;\n  }\n};\n\n// src/keri/core/decrypter.ts\nvar Decrypter = class extends Matter {\n  _decrypt;\n  constructor({ raw, code = MtrDex.X25519_Private, qb64, qb64b, qb2 }, seed = void 0) {\n    try {\n      super({ raw, code, qb64, qb64b, qb2 });\n    } catch (e) {\n      if (e instanceof EmptyMaterialError) {\n        if (seed != void 0) {\n          const signer = new Signer({ qb64b: seed });\n          if (signer.code != MtrDex.Ed25519_Seed) {\n            throw new Error(\n              `Unsupported signing seed derivation code ${signer.code}`\n            );\n          }\n          const sigkey = new Uint8Array(\n            signer.raw.length + signer.verfer.raw.length\n          );\n          sigkey.set(signer.raw);\n          sigkey.set(signer.verfer.raw, signer.raw.length);\n          raw = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_ed25519_sk_to_curve25519(sigkey);\n          super({ raw, code, qb64, qb64b, qb2 });\n        } else {\n          throw e;\n        }\n      } else {\n        throw e;\n      }\n    }\n    if (this.code == MtrDex.X25519_Private) {\n      this._decrypt = this._x25519;\n    } else {\n      throw new Error(`Unsupported decrypter code = ${this.code}.`);\n    }\n  }\n  decrypt(ser = null, cipher = null, transferable = false) {\n    if (ser == null && cipher == null) {\n      throw new EmptyMaterialError(\"Neither ser or cipher were provided\");\n    }\n    if (ser != null) {\n      cipher = new Cipher({ qb64b: ser });\n    }\n    return this._decrypt(cipher, this.raw, transferable);\n  }\n  _x25519(cipher, prikey, transferable = false) {\n    const pubkey = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_scalarmult_base(prikey);\n    const plain = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_box_seal_open(\n      cipher.raw,\n      pubkey,\n      prikey\n    );\n    if (cipher.code == MtrDex.X25519_Cipher_Salt) {\n      return new Salter({ qb64b: plain });\n    } else if (cipher.code == MtrDex.X25519_Cipher_Seed) {\n      return new Signer({ qb64b: plain, transferable });\n    } else {\n      throw new Error(`Unsupported cipher text code == ${cipher.code}`);\n    }\n  }\n};\n\n// src/keri/core/cipher.ts\nvar Cipher = class extends Matter {\n  constructor({ raw, code, qb64, qb64b, qb2 }) {\n    if (raw != void 0 && code == void 0) {\n      if (raw.length == Matter._rawSize(MtrDex.X25519_Cipher_Salt)) {\n        code = MtrDex.X25519_Cipher_Salt;\n      } else if (raw.length == Matter._rawSize(MtrDex.X25519_Cipher_Seed)) {\n        code = MtrDex.X25519_Cipher_Salt;\n      }\n    }\n    super({ raw, code, qb64b, qb64, qb2 });\n    if (!Array.from([\n      MtrDex.X25519_Cipher_Salt,\n      MtrDex.X25519_Cipher_Seed\n    ]).includes(this.code)) {\n      throw new Error(`Unsupported Cipher code == ${this.code}`);\n    }\n  }\n  decrypt(prikey = void 0, seed = void 0) {\n    const decrypter = new Decrypter({ qb64b: prikey }, seed);\n    return decrypter.decrypt(this.qb64b);\n  }\n};\n\n// src/keri/core/counter.ts\nvar CounterCodex = class extends Codex {\n  ControllerIdxSigs = \"-A\";\n  // Qualified Base64 Indexed Signature.\n  WitnessIdxSigs = \"-B\";\n  // Qualified Base64 Indexed Signature.\n  NonTransReceiptCouples = \"-C\";\n  // Composed Base64 Couple, pre+cig.\n  TransReceiptQuadruples = \"-D\";\n  // Composed Base64 Quadruple, pre+snu+dig+sig.\n  FirstSeenReplayCouples = \"-E\";\n  // Composed Base64 Couple, fnu+dts.\n  TransIdxSigGroups = \"-F\";\n  // Composed Base64 Group, pre+snu+dig+ControllerIdxSigs group.\n  SealSourceCouples = \"-G\";\n  // Composed Base64 couple, snu+dig of given delegators or issuers event\n  TransLastIdxSigGroups = \"-H\";\n  // Composed Base64 Group, pre+ControllerIdxSigs group.\n  SealSourceTriples = \"-I\";\n  // Composed Base64 triple, pre+snu+dig of anchoring source event\n  SadPathSig = \"-J\";\n  // Composed Base64 Group path+TransIdxSigGroup of SAID of content\n  SadPathSigGroup = \"-K\";\n  // Composed Base64 Group, root(path)+SaidPathCouples\n  PathedMaterialQuadlets = \"-L\";\n  // Composed Grouped Pathed Material Quadlet (4 char each)\n  AttachedMaterialQuadlets = \"-V\";\n  // Composed Grouped Attached Material Quadlet (4 char each)\n  BigAttachedMaterialQuadlets = \"-0V\";\n  // Composed Grouped Attached Material Quadlet (4 char each)\n  KERIProtocolStack = \"--AAA\";\n  // KERI ACDC Protocol Stack CESR Version\n};\nvar CtrDex = new CounterCodex();\nvar Counter = class _Counter {\n  static Sizes = new Map(\n    Object.entries({\n      \"-A\": new Sizage(2, 2, 4, 0),\n      \"-B\": new Sizage(2, 2, 4, 0),\n      \"-C\": new Sizage(2, 2, 4, 0),\n      \"-D\": new Sizage(2, 2, 4, 0),\n      \"-E\": new Sizage(2, 2, 4, 0),\n      \"-F\": new Sizage(2, 2, 4, 0),\n      \"-G\": new Sizage(2, 2, 4, 0),\n      \"-H\": new Sizage(2, 2, 4, 0),\n      \"-I\": new Sizage(2, 2, 4, 0),\n      \"-J\": new Sizage(2, 2, 4, 0),\n      \"-K\": new Sizage(2, 2, 4, 0),\n      \"-L\": new Sizage(2, 2, 4, 0),\n      \"-V\": new Sizage(2, 2, 4, 0),\n      \"-0V\": new Sizage(3, 5, 8, 0),\n      \"--AAA\": new Sizage(5, 3, 8, 0)\n    })\n  );\n  static Hards = /* @__PURE__ */ new Map([\n    [\"-A\", 2],\n    [\"-B\", 2],\n    [\"-C\", 2],\n    [\"-D\", 2],\n    [\"-E\", 2],\n    [\"-F\", 2],\n    [\"-G\", 2],\n    [\"-H\", 2],\n    [\"-I\", 2],\n    [\"-J\", 2],\n    [\"-K\", 2],\n    [\"-L\", 2],\n    [\"-M\", 2],\n    [\"-N\", 2],\n    [\"-O\", 2],\n    [\"-P\", 2],\n    [\"-Q\", 2],\n    [\"-R\", 2],\n    [\"-S\", 2],\n    [\"-T\", 2],\n    [\"-U\", 2],\n    [\"-V\", 2],\n    [\"-W\", 2],\n    [\"-X\", 2],\n    [\"-Y\", 2],\n    [\"-Z\", 2],\n    [\"-a\", 2],\n    [\"-b\", 2],\n    [\"-c\", 2],\n    [\"-d\", 2],\n    [\"-e\", 2],\n    [\"-f\", 2],\n    [\"-g\", 2],\n    [\"-h\", 2],\n    [\"-i\", 2],\n    [\"-j\", 2],\n    [\"-k\", 2],\n    [\"-l\", 2],\n    [\"-m\", 2],\n    [\"-n\", 2],\n    [\"-o\", 2],\n    [\"-p\", 2],\n    [\"-q\", 2],\n    [\"-r\", 2],\n    [\"-s\", 2],\n    [\"-t\", 2],\n    [\"-u\", 2],\n    [\"-v\", 2],\n    [\"-w\", 2],\n    [\"-x\", 2],\n    [\"-y\", 2],\n    [\"-z\", 2],\n    [\"-0\", 3],\n    [\"--\", 5]\n  ]);\n  _code = \"\";\n  _count = -1;\n  constructor({ code, count, countB64, qb64b, qb64, qb2 }) {\n    if (code != void 0) {\n      if (!_Counter.Sizes.has(code)) {\n        throw new Error(`\"Unsupported code=${code}.`);\n      }\n      const sizage = _Counter.Sizes.get(code);\n      const cs = sizage.hs + sizage.ss;\n      if (sizage.fs != cs || cs % 4 != 0) {\n        throw new Error(\n          `Whole code size not full size or not multiple of 4. cs=${cs} fs=${sizage.fs}.`\n        );\n      }\n      if (count == void 0) {\n        count = countB64 == void 0 ? 1 : b64ToInt(countB64);\n      }\n      if (count < 0 || count > 64 ** sizage.ss - 1) {\n        throw new Error(`Invalid count=${count} for code=${code}.`);\n      }\n      this._code = code;\n      this._count = count;\n    } else if (qb64b != void 0) {\n      const qb642 = d(qb64b);\n      this._exfil(qb642);\n    } else if (qb64 != void 0) {\n      this._exfil(qb64);\n    } else if (qb2 != void 0) {\n    } else {\n      throw new Error(\n        `Improper initialization need either (code and count) or qb64b or qb64 or qb2.`\n      );\n    }\n  }\n  get code() {\n    return this._code;\n  }\n  get count() {\n    return this._count;\n  }\n  get qb64() {\n    return this._infil();\n  }\n  get qb64b() {\n    return b(this.qb64);\n  }\n  countToB64(l) {\n    if (l == void 0) {\n      const sizage = _Counter.Sizes.get(this.code);\n      l = sizage.ss;\n    }\n    return intToB64(this.count, l);\n  }\n  static semVerToB64(version = \"\", major = 0, minor = 0, patch = 0) {\n    let parts = [major, minor, patch];\n    if (version != \"\") {\n      const ssplits = version.split(\".\");\n      const splits = ssplits.map((x2) => {\n        if (x2 == \"\")\n          return 0;\n        return parseInt(x2);\n      });\n      const off = splits.length;\n      const x = 3 - off;\n      for (let i = 0; i < x; i++) {\n        splits.push(parts[i + off]);\n      }\n      parts = splits;\n    }\n    parts.forEach((p) => {\n      if (p < 0 || p > 63) {\n        throw new Error(\n          `Out of bounds semantic version. Part=${p} is < 0 or > 63.`\n        );\n      }\n    });\n    return parts.map((p) => {\n      return intToB64(p, 1);\n    }).join(\"\");\n  }\n  _infil() {\n    const code = this.code;\n    const count = this.count;\n    const sizage = _Counter.Sizes.get(code);\n    const cs = sizage.hs + sizage.ss;\n    if (sizage.fs != cs || cs % 4 != 0) {\n      throw new Error(\n        `Whole code size not full size or not multiple of 4. cs=${cs} fs=${sizage.fs}.`\n      );\n    }\n    if (count < 0 || count > 64 ** sizage.ss - 1) {\n      throw new Error(`Invalid count=${count} for code=${code}.`);\n    }\n    const both = `${code}${intToB64(count, sizage.ss)}`;\n    if (both.length % 4) {\n      throw new Error(\n        `Invalid size = ${both.length} of ${both} not a multiple of 4.`\n      );\n    }\n    return both;\n  }\n  _exfil(qb64) {\n    if (qb64.length == 0) {\n      throw new Error(\"Empty Material\");\n    }\n    const first = qb64.slice(0, 2);\n    if (!_Counter.Hards.has(first)) {\n      throw new Error(`Unexpected code ${first}`);\n    }\n    const hs = _Counter.Hards.get(first);\n    if (qb64.length < hs) {\n      throw new Error(`Need ${hs - qb64.length} more characters.`);\n    }\n    const hard = qb64.slice(0, hs);\n    if (!_Counter.Sizes.has(hard)) {\n      throw new Error(`Unsupported code ${hard}`);\n    }\n    const sizage = _Counter.Sizes.get(hard);\n    const cs = sizage.hs + sizage.ss;\n    if (qb64.length < cs) {\n      throw new Error(`Need ${cs - qb64.length} more chars.`);\n    }\n    const scount = qb64.slice(sizage.hs, sizage.hs + sizage.ss);\n    const count = b64ToInt(scount);\n    this._code = hard;\n    this._count = count;\n  }\n};\n\n// src/keri/core/seqner.ts\nvar Seqner = class extends Matter {\n  constructor({\n    raw,\n    code = MtrDex.Salt_128,\n    qb64,\n    qb64b,\n    qb2,\n    sn,\n    snh,\n    ...kwa\n  }) {\n    if (!raw && !qb64b && !qb64 && !qb2) {\n      if (sn === void 0) {\n        if (snh === void 0) {\n          sn = 0;\n        } else {\n          sn = parseInt(snh, 16);\n        }\n      }\n      raw = intToBytes(sn, Matter._rawSize(MtrDex.Salt_128));\n    }\n    super({ raw, code, qb64, qb64b, qb2, ...kwa });\n    if (this.code !== MtrDex.Salt_128) {\n      throw new Error(`Invalid code = ${this.code} for Seqner.`);\n    }\n  }\n  get sn() {\n    return bytesToInt(this.raw);\n  }\n  get snh() {\n    return this.sn.toString(16);\n  }\n};\n\n// src/keri/core/diger.ts\n\n\nvar Diger = class _Diger extends Matter {\n  _verify;\n  // This constructor will assign digest verification function to ._verify\n  constructor({ raw, code = MtrDex.Blake3_256, qb64, qb64b, qb2 }, ser = null) {\n    try {\n      super({ raw, code, qb64, qb64b, qb2 });\n    } catch (error) {\n      if (ser == null) {\n        throw error;\n      }\n      if (code === MtrDex.Blake3_256) {\n        const dig = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(\n          _noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_3__.blake3.create({ dkLen: 32 }).update(ser).digest()\n        );\n        super({ raw: dig, code });\n      } else {\n        throw new Error(`Unsupported code = ${code} for digester.`);\n      }\n    }\n    if (code === MtrDex.Blake3_256) {\n      this._verify = this.blake3_256;\n    } else {\n      throw new Error(`Unsupported code = ${code} for digester.`);\n    }\n  }\n  /**\n   *\n   * @param {Uint8Array} ser  serialization bytes\n   * @description  This method will return true if digest of bytes serialization ser matches .raw\n   * using .raw as reference digest for ._verify digest algorithm determined\n   by .code\n   */\n  verify(ser) {\n    return this._verify(ser, this.raw);\n  }\n  compare(ser, dig = null, diger = null) {\n    if (dig != null) {\n      if (dig.toString() == this.qb64) {\n        return true;\n      }\n      diger = new _Diger({ qb64b: dig });\n    } else if (diger != null) {\n      if (diger.qb64b == this.qb64b) {\n        return true;\n      }\n    } else {\n      throw new Error(\"Both dig and diger may not be None.\");\n    }\n    if (diger.code == this.code) {\n      return false;\n    }\n    return diger.verify(ser) && this.verify(ser);\n  }\n  blake3_256(ser, dig) {\n    const digest = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(\n      _noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_3__.blake3.create({ dkLen: 32 }).update(ser).digest()\n    );\n    return digest.toString() === dig.toString();\n  }\n};\n\n// src/keri/core/number.ts\nvar CesrNumber = class extends Matter {\n  constructor({ raw, code, qb64b, qb64, qb2 }, num, numh) {\n    let _num;\n    if (raw == void 0 && qb64 == void 0 && qb64b == void 0 && qb2 == void 0) {\n      if (typeof num == \"number\") {\n        _num = num;\n      } else if (numh != void 0) {\n        _num = parseInt(numh, 16);\n      } else {\n        _num = 0;\n      }\n    }\n    if (_num == void 0) {\n      throw new Error(\"Invalid whole number\");\n    }\n    if (_num <= 256 ** 2 - 1) {\n      code = NumDex.Short;\n    } else if (_num <= 256 ** 4 - 1) {\n      code = code = NumDex.Long;\n    } else if (_num <= 256 ** 8 - 1) {\n      code = code = NumDex.Big;\n    } else if (_num <= 256 ** 16 - 1) {\n      code = code = NumDex.Huge;\n    } else {\n      throw new Error(`Invalid num = ${num}, too large to encode.`);\n    }\n    raw = intToBytes(_num, Matter._rawSize(code));\n    super({ raw, code, qb64b, qb64, qb2 });\n    if (!NumDex.has(this.code)) {\n      throw new Error(\"Invalid code \" + code + \" for Number\");\n    }\n  }\n  get num() {\n    return bytesToInt(this.raw);\n  }\n  get numh() {\n    return this.num.toString(16);\n  }\n  get positive() {\n    return this.num > 0;\n  }\n};\n\n// src/keri/core/serder.ts\nvar Serder = class {\n  _kind;\n  _raw = \"\";\n  _ked = {};\n  _ident = \"KERI\" /* KERI */;\n  _size = 0;\n  _version = Versionage;\n  _code;\n  constructor(ked, kind = \"JSON\" /* JSON */, code = MtrDex.Blake3_256) {\n    this._code = code;\n    this._kind = kind;\n    this.ked = ked;\n  }\n  set ked(ked) {\n    const [raw, ident, kind, kd, version] = this._exhale(ked, this._kind);\n    const size = raw.length;\n    this._raw = raw;\n    this._ident = ident;\n    this._ked = kd;\n    this._kind = kind;\n    this._size = size;\n    this._version = version;\n  }\n  get pre() {\n    return this._ked[\"i\"];\n  }\n  get ked() {\n    return this._ked;\n  }\n  get code() {\n    return this._code;\n  }\n  get raw() {\n    return this._raw;\n  }\n  get sner() {\n    return new CesrNumber({}, this.ked[\"s\"]);\n  }\n  get sn() {\n    return this.sner.num;\n  }\n  get kind() {\n    return this._kind;\n  }\n  _exhale(ked, kind) {\n    return sizeify(ked, kind);\n  }\n  get ident() {\n    return this._ident;\n  }\n  get size() {\n    return this._size;\n  }\n  get version() {\n    return this._version;\n  }\n  get verfers() {\n    let keys = [];\n    if (\"k\" in this._ked) {\n      keys = this._ked[\"k\"];\n    } else {\n      keys = [];\n    }\n    const verfers = [];\n    for (const key of keys) {\n      verfers.push(new Verfer({ qb64: key }));\n    }\n    return verfers;\n  }\n  get digers() {\n    let keys = [];\n    if (\"n\" in this._ked) {\n      keys = this._ked[\"n\"];\n    } else {\n      keys = [];\n    }\n    const digers = [];\n    for (const key of keys) {\n      digers.push(new Diger({ qb64: key }));\n    }\n    return digers;\n  }\n  pretty() {\n    return JSON.stringify(this._ked, void 0, 2);\n  }\n};\nfunction dumps(ked, kind) {\n  if (kind == \"JSON\" /* JSON */) {\n    return JSON.stringify(ked);\n  } else {\n    throw new Error(\"unsupported event encoding\");\n  }\n}\nfunction sizeify(ked, kind) {\n  if (!(\"v\" in ked)) {\n    throw new Error(\"Missing or empty version string\");\n  }\n  const [ident, knd, version] = deversify(ked[\"v\"]);\n  if (version != Versionage) {\n    throw new Error(`unsupported version ${version.toString()}`);\n  }\n  if (kind == void 0) {\n    kind = knd;\n  }\n  let raw = dumps(ked, kind);\n  const size = new TextEncoder().encode(raw).length;\n  ked[\"v\"] = versify(ident, version, kind, size);\n  raw = dumps(ked, kind);\n  return [raw, ident, kind, ked, version];\n}\n\n// src/keri/core/prefixer.ts\n\n\nvar Dummy = \"#\";\nvar Prefixer = class _Prefixer extends Matter {\n  _derive;\n  _verify;\n  constructor({ raw, code, qb64b, qb64, qb2 }, ked) {\n    try {\n      super({ raw, code, qb64b, qb64, qb2 });\n    } catch (e) {\n      if (e instanceof EmptyMaterialError) {\n        if (ked == void 0 || code == void 0 && !(\"i\" in ked)) {\n          throw e;\n        }\n        if (code == void 0) {\n          super({ qb64: ked[\"i\"], code });\n          code = this.code;\n        }\n        let _derive;\n        if (code == MtrDex.Ed25519N) {\n          _derive = _Prefixer._derive_ed25519N;\n        } else if (code == MtrDex.Ed25519) {\n          _derive = _Prefixer._derive_ed25519;\n        } else if (code == MtrDex.Blake3_256) {\n          _derive = _Prefixer._derive_blake3_256;\n        } else {\n          throw new Error(`Unsupported code = ${code} for prefixer.`);\n        }\n        [raw, code] = _derive(ked);\n        super({ raw, code });\n        this._derive = _derive;\n      } else {\n        throw e;\n      }\n    }\n    if (this.code == MtrDex.Ed25519N) {\n      this._verify = this._verify_ed25519N;\n    } else if (this.code == MtrDex.Ed25519) {\n      this._verify = this._verify_ed25519;\n    } else if (this.code == MtrDex.Blake3_256) {\n      this._verify = this._verify_blake3_256;\n    } else {\n      throw new Error(`Unsupported code = ${code} for prefixer.`);\n    }\n  }\n  derive(ked) {\n    if (ked[\"i\"] != Ilks.icp) {\n      throw new Error(\n        `Non-incepting ilk ${ked[\"i\"]} for prefix derivation`\n      );\n    }\n    return this._derive(ked);\n  }\n  verify(ked, prefixed = false) {\n    if (ked[\"i\"] != Ilks.icp) {\n      throw new Error(\n        `Non-incepting ilk ${ked[\"i\"]} for prefix derivation`\n      );\n    }\n    return this._verify(ked, this.qb64, prefixed);\n  }\n  static _derive_ed25519N(ked) {\n    let verfer;\n    const keys = ked[\"k\"];\n    if (keys.length != 1) {\n      throw new Error(\n        `Basic derivation needs at most 1 key got ${keys.length} keys instead`\n      );\n    }\n    try {\n      verfer = new Verfer({ qb64: keys[0] });\n    } catch (e) {\n      throw new Error(`Error extracting public key = ${e}`);\n    }\n    if (verfer.code != MtrDex.Ed25519N) {\n      throw new Error(`Mismatch derivation code = ${verfer.code}`);\n    }\n    const next = \"n\" in ked ? ked[\"n\"] : [];\n    if (verfer.code == MtrDex.Ed25519N && next.length > 0) {\n      throw new Error(\n        `Non-empty nxt = ${next} for non-transferable code = ${verfer.code}`\n      );\n    }\n    const backers = \"b\" in ked ? ked[\"b\"] : [];\n    if (verfer.code == MtrDex.Ed25519N && backers.length > 0) {\n      throw new Error(\n        `Non-empty b =${backers} for non-transferable code = ${verfer.code}`\n      );\n    }\n    const anchor = \"a\" in ked ? ked[\"a\"] : [];\n    if (verfer.code == MtrDex.Ed25519N && anchor.length > 0) {\n      throw new Error(\n        `Non-empty a = ${verfer.code} for non-transferable code = ${verfer.code}`\n      );\n    }\n    return [verfer.raw, verfer.code];\n  }\n  static _derive_ed25519(ked) {\n    let verfer;\n    const keys = ked[\"k\"];\n    if (keys.length != 1) {\n      throw new Error(\n        `Basic derivation needs at most 1 key got ${keys.length} keys instead`\n      );\n    }\n    try {\n      verfer = new Verfer({ qb64: keys[0] });\n    } catch (e) {\n      throw new Error(`Error extracting public key = ${e}`);\n    }\n    if (verfer.code in [MtrDex.Ed25519]) {\n      throw new Error(`Mismatch derivation code = ${verfer.code}`);\n    }\n    return [verfer.raw, verfer.code];\n  }\n  static _derive_blake3_256(ked) {\n    const kd = ked;\n    const ilk = ked[\"t\"];\n    if (![Ilks.icp, Ilks.dip, Ilks.vcp, Ilks.dip].includes(ilk)) {\n      throw new Error(`Invalid ilk = ${ilk} to derive pre.`);\n    }\n    kd[\"i\"] = \"\".padStart(Matter.Sizes.get(MtrDex.Blake3_256).fs, Dummy);\n    kd[\"d\"] = ked[\"i\"];\n    const [raw] = sizeify(ked);\n    const dig = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(\n      _noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_3__.blake3.create({ dkLen: 32 }).update(raw).digest()\n    );\n    return [dig, MtrDex.Blake3_256];\n  }\n  _verify_ed25519N(ked, pre, prefixed = false) {\n    try {\n      const keys = ked[\"k\"];\n      if (keys.length != 1) {\n        return false;\n      }\n      if (keys[0] != pre) {\n        return false;\n      }\n      if (prefixed && ked[\"i\"] != pre) {\n        return false;\n      }\n      const next = \"n\" in ked ? ked[\"n\"] : [];\n      if (next.length > 0) {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  _verify_ed25519(ked, pre, prefixed = false) {\n    try {\n      const keys = ked[\"k\"];\n      if (keys.length != 1) {\n        return false;\n      }\n      if (keys[0] != pre) {\n        return false;\n      }\n      if (prefixed && ked[\"i\"] != pre) {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  _verify_blake3_256(ked, pre, prefixed = false) {\n    try {\n      const [raw] = _Prefixer._derive_blake3_256(ked);\n      const crymat = new Matter({ raw, code: MtrDex.Blake3_256 });\n      if (crymat.qb64 != pre) {\n        return false;\n      }\n      if (prefixed && ked[\"i\"] != pre) {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/keri/core/saider.ts\n\n\nvar Dummy2 = \"#\";\nvar Ids = /* @__PURE__ */ ((Ids2) => {\n  Ids2[\"d\"] = \"d\";\n  return Ids2;\n})(Ids || {});\nvar Digestage = class {\n  klas = void 0;\n  size = 0;\n  length = 0;\n  constructor(klas, size, length) {\n    this.klas = klas;\n    this.size = size;\n    this.length = length;\n  }\n};\nvar Saider = class _Saider extends Matter {\n  static Digests = /* @__PURE__ */ new Map([\n    [\n      MtrDex.Blake3_256,\n      new Digestage(_Saider._derive_blake3_256, void 0, void 0)\n    ]\n  ]);\n  constructor({ raw, code, qb64b, qb64, qb2 }, sad, kind, label = \"d\" /* d */) {\n    try {\n      super({ raw, code, qb64b, qb64, qb2 });\n    } catch (e) {\n      if (e instanceof EmptyMaterialError) {\n        if (sad == void 0 || !(label in sad)) {\n          throw e;\n        }\n        if (code == void 0) {\n          if (sad[label] != \"\") {\n            super({ qb64: sad[label], code });\n            code = this.code;\n          } else {\n            code = MtrDex.Blake3_256;\n          }\n        }\n        if (!DigiDex.has(code)) {\n          throw new Error(`Unsupported digest code = ${code}`);\n        }\n        [raw] = _Saider._derive({ ...sad }, code, kind, label);\n        super({ raw, code });\n      } else {\n        throw e;\n      }\n    }\n    if (!this.digestive) {\n      throw new Error(`Unsupported digest code = ${this.code}.`);\n    }\n  }\n  static _derive_blake3_256(ser, _digest_size, _length) {\n    return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(_noble_hashes_blake3__WEBPACK_IMPORTED_MODULE_3__.blake3.create({ dkLen: 32 }).update(ser).digest());\n  }\n  static _derive(sad, code, kind, label) {\n    if (!DigiDex.has(code) || !_Saider.Digests.has(code)) {\n      throw new Error(`Unsupported digest code = ${code}.`);\n    }\n    sad = { ...sad };\n    sad[label] = \"\".padStart(Matter.Sizes.get(code).fs, Dummy2);\n    if (\"v\" in sad) {\n      [, , kind, sad] = sizeify(sad, kind);\n    }\n    const ser = { ...sad };\n    const digestage = _Saider.Digests.get(code);\n    const cpa = _Saider._serialze(ser, kind);\n    const args = [];\n    if (digestage.size != void 0) {\n      args.push(digestage.size);\n    }\n    if (digestage.length != void 0) {\n      args.push(digestage.length);\n    }\n    return [digestage.klas(cpa, ...args), sad];\n  }\n  derive(sad, code, kind, label) {\n    code = code != void 0 ? code : this.code;\n    return _Saider._derive(sad, code, kind, label);\n  }\n  verify(sad, prefixed = false, versioned = false, kind, label = \"d\" /* d */) {\n    try {\n      const [raw, dsad] = _Saider._derive(sad, this.code, kind, label);\n      const saider = new _Saider({ raw, code: this.code });\n      if (this.qb64 != saider.qb64) {\n        return false;\n      }\n      if (\"v\" in sad && versioned) {\n        if (sad[\"v\"] != dsad[\"v\"]) {\n          return false;\n        }\n      }\n      if (prefixed && sad[label] != this.qb64) {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  static _serialze(sad, kind) {\n    let knd = \"JSON\" /* JSON */;\n    if (\"v\" in sad) {\n      [, knd] = deversify(sad[\"v\"]);\n    }\n    if (kind == void 0) {\n      kind = knd;\n    }\n    return dumps(sad, kind);\n  }\n  static saidify(sad, code = MtrDex.Blake3_256, kind = \"JSON\" /* JSON */, label = \"d\" /* d */) {\n    if (!(label in sad)) {\n      throw new Error(`Missing id field labeled=${label} in sad.`);\n    }\n    let raw;\n    [raw, sad] = _Saider._derive(sad, code, kind, label);\n    const saider = new _Saider(\n      { raw, code },\n      void 0,\n      kind,\n      label\n    );\n    sad[label] = saider.qb64;\n    return [saider, sad];\n  }\n};\n\n// src/keri/core/utils.ts\nfunction pad(n, width = 3, z = 0) {\n  return (String(z).repeat(width) + String(n)).slice(String(n).length);\n}\nfunction extractValues(ked, labels) {\n  let values = [];\n  for (const label of labels) {\n    values = extractElementValues(ked[label], values);\n  }\n  return values;\n}\nfunction arrayEquals(ar1, ar2) {\n  return ar1.length === ar2.length && ar1.every((val, index) => val === ar2[index]);\n}\nfunction extractElementValues(element, values) {\n  let data = [];\n  try {\n    if (element instanceof Array && !(typeof element == \"string\")) {\n      for (const k in element)\n        extractElementValues(element[k], values);\n    } else if (typeof element == \"string\") {\n      values.push(element);\n    }\n    data = values;\n  } catch (error) {\n    throw new Error(error);\n  }\n  return data;\n}\nfunction nowUTC() {\n  return /* @__PURE__ */ new Date();\n}\nfunction range(start, stop, step) {\n  if (typeof stop == \"undefined\") {\n    stop = start;\n    start = 0;\n  }\n  if (typeof step == \"undefined\") {\n    step = 1;\n  }\n  if (step > 0 && start >= stop || step < 0 && start <= stop) {\n    return [];\n  }\n  const result = new Array();\n  for (let i = start; step > 0 ? i < stop : i > stop; i += step) {\n    result.push(i);\n  }\n  return result;\n}\nfunction intToBytes(value, length) {\n  const byteArray = new Uint8Array(length);\n  for (let index = byteArray.length - 1; index >= 0; index--) {\n    const byte = value & 255;\n    byteArray[index] = byte;\n    value = (value - byte) / 256;\n  }\n  return byteArray;\n}\nfunction bytesToInt(ar) {\n  let value = 0;\n  for (let i = 0; i < ar.length; i++) {\n    value = value * 256 + ar[i];\n  }\n  return value;\n}\nfunction serializeACDCAttachment(anc) {\n  const prefixer = new Prefixer({ qb64: anc.pre });\n  const seqner = new Seqner({ sn: anc.sn });\n  const saider = new Saider({ qb64: anc.ked[\"d\"] });\n  const craw = new Uint8Array();\n  const ctr = new Counter({ code: CtrDex.SealSourceTriples, count: 1 }).qb64b;\n  const prefix = prefixer.qb64b;\n  const seq = seqner.qb64b;\n  const said = saider.qb64b;\n  const newCraw = new Uint8Array(\n    craw.length + ctr.length + prefix.length + seq.length + said.length\n  );\n  newCraw.set(craw);\n  newCraw.set(ctr, craw.length);\n  newCraw.set(prefix, craw.length + ctr.length);\n  newCraw.set(seq, craw.length + ctr.length + prefix.length);\n  newCraw.set(said, craw.length + ctr.length + prefix.length + seq.length);\n  return newCraw;\n}\nfunction serializeIssExnAttachment(anc) {\n  const seqner = new Seqner({ sn: anc.sn });\n  const ancSaider = new Saider({ qb64: anc.ked[\"d\"] });\n  const coupleArray = new Uint8Array(\n    seqner.qb64b.length + ancSaider.qb64b.length\n  );\n  coupleArray.set(seqner.qb64b);\n  coupleArray.set(ancSaider.qb64b, seqner.qb64b.length);\n  const counter = new Counter({\n    code: CtrDex.SealSourceCouples,\n    count: 1\n  });\n  const counterQb64b = counter.qb64b;\n  const atc = new Uint8Array(counter.qb64b.length + coupleArray.length);\n  atc.set(counterQb64b);\n  atc.set(coupleArray, counterQb64b.length);\n  if (atc.length % 4 !== 0) {\n    throw new Error(\n      `Invalid attachments size: ${atc.length}, non-integral quadlets detected.`\n    );\n  }\n  const pcnt = new Counter({\n    code: CtrDex.AttachedMaterialQuadlets,\n    count: Math.floor(atc.length / 4)\n  });\n  const msg = new Uint8Array(pcnt.qb64b.length + atc.length);\n  msg.set(pcnt.qb64b);\n  msg.set(atc, pcnt.qb64b.length);\n  return msg;\n}\n\n// src/keri/core/encrypter.ts\nvar Encrypter = class extends Matter {\n  _encrypt;\n  constructor({ raw, code = MtrDex.X25519, qb64, qb64b, qb2 }, verkey = null) {\n    if (raw == void 0 && verkey != null) {\n      const verfer = new Verfer({ qb64b: verkey });\n      if (!Array.from([MtrDex.Ed25519N, MtrDex.Ed25519]).includes(\n        verfer.code\n      )) {\n        throw new Error(\n          `Unsupported verkey derivation code = ${verfer.code}.`\n        );\n      }\n      raw = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_ed25519_pk_to_curve25519(verfer.raw);\n    }\n    super({ raw, code, qb64, qb64b, qb2 });\n    if (this.code == MtrDex.X25519) {\n      this._encrypt = this._x25519;\n    } else {\n      throw new Error(`Unsupported encrypter code = ${this.code}.`);\n    }\n  }\n  verifySeed(seed) {\n    const signer = new Signer({ qb64b: seed });\n    const keypair = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_seed_keypair(signer.raw);\n    const pubkey = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_ed25519_pk_to_curve25519(\n      keypair.publicKey\n    );\n    return arrayEquals(pubkey, this.raw);\n  }\n  encrypt(ser = null, matter = null) {\n    if (ser == null && matter == null) {\n      throw new Error(\"Neither ser nor matter are provided.\");\n    }\n    if (ser != null) {\n      matter = new Matter({ qb64b: ser });\n    }\n    let code;\n    if (matter.code == MtrDex.Salt_128) {\n      code = MtrDex.X25519_Cipher_Salt;\n    } else {\n      code = MtrDex.X25519_Cipher_Seed;\n    }\n    return this._encrypt(matter.qb64, this.raw, code);\n  }\n  _x25519(ser, pubkey, code) {\n    const raw = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_box_seal(ser, pubkey);\n    return new Cipher({ raw, code });\n  }\n};\n\n// src/keri/core/manager.ts\nvar Algos = /* @__PURE__ */ ((Algos2) => {\n  Algos2[\"randy\"] = \"randy\";\n  Algos2[\"salty\"] = \"salty\";\n  Algos2[\"group\"] = \"group\";\n  Algos2[\"extern\"] = \"extern\";\n  return Algos2;\n})(Algos || {});\nvar PubLot = class {\n  pubs = new Array();\n  // list qb64 public keys.\n  ridx = 0;\n  //  index of rotation (est event) that uses public key set\n  kidx = 0;\n  //  index of key in sequence of public keys\n  dt = \"\";\n  // datetime ISO8601 when key set created\n};\nvar PreSit = class {\n  old = new PubLot();\n  //previous publot\n  new = new PubLot();\n  //newly current publot\n  nxt = new PubLot();\n  //next public publot\n};\nvar PrePrm = class {\n  pidx = 0;\n  // prefix index for this keypair sequence\n  algo = \"salty\" /* salty */;\n  // salty default uses indices and salt to create new key pairs\n  salt = \"\";\n  // empty salt  used for salty algo.\n  stem = \"\";\n  // default unique path stem for salty algo\n  tier = \"\";\n  // security tier for stretch index salty algo\n};\nvar PubSet = class {\n  pubs = new Array();\n  // list qb64 public keys.\n};\nvar PubPath = class {\n  path = \"\";\n  code = \"\";\n  tier = \"high\" /* high */;\n  temp = false;\n};\nvar Keys = class {\n  _signers;\n  _paths;\n  constructor(signers, paths) {\n    this._signers = signers;\n    if (paths != void 0) {\n      if (signers.length != paths.length) {\n        throw new Error(\n          \"If paths are provided, they must be the same length as signers\"\n        );\n      }\n    }\n    this._paths = paths;\n  }\n  get paths() {\n    return this._paths;\n  }\n  get signers() {\n    return this._signers;\n  }\n};\nvar RandyCreator = class {\n  create(codes = void 0, count = 1, code = MtrDex.Ed25519_Seed, transferable = true) {\n    const signers = new Array();\n    if (codes == void 0) {\n      codes = new Array(count).fill(code);\n    }\n    codes.forEach(function(code2) {\n      signers.push(\n        new Signer({ code: code2, transferable })\n      );\n    });\n    return new Keys(signers);\n  }\n  get salt() {\n    return \"\";\n  }\n  get stem() {\n    return \"\";\n  }\n  get tier() {\n    return \"\";\n  }\n};\nvar SaltyCreator = class {\n  salter;\n  _stem;\n  constructor(salt = void 0, tier = void 0, stem = void 0) {\n    this.salter = new Salter({ qb64: salt, tier });\n    this._stem = stem == void 0 ? \"\" : stem;\n  }\n  get salt() {\n    return this.salter.qb64;\n  }\n  get stem() {\n    return this._stem;\n  }\n  get tier() {\n    return this.salter.tier;\n  }\n  create(codes = void 0, count = 1, code = MtrDex.Ed25519_Seed, transferable = true, pidx = 0, ridx = 0, kidx = 0, temp = false) {\n    const signers = new Array();\n    const paths = new Array();\n    if (codes == void 0) {\n      codes = new Array(count).fill(code);\n    }\n    codes.forEach((code2, idx) => {\n      const path = this.stem == \"\" ? pidx.toString(16) : this.stem + ridx.toString(16) + (kidx + idx).toString(16);\n      signers.push(\n        this.salter.signer(code2, transferable, path, this.tier, temp)\n      );\n      paths.push(path);\n    });\n    return new Keys(signers, paths);\n  }\n};\nvar Creatory = class {\n  _make;\n  constructor(algo = \"salty\" /* salty */) {\n    switch (algo) {\n      case \"randy\" /* randy */:\n        this._make = this._makeRandy;\n        break;\n      case \"salty\" /* salty */:\n        this._make = this._makeSalty;\n        break;\n      default:\n        throw new Error(`unsupported algo=${algo}`);\n    }\n  }\n  make(...args) {\n    return this._make(...args);\n  }\n  _makeRandy() {\n    return new RandyCreator();\n  }\n  _makeSalty(...args) {\n    return new SaltyCreator(...args);\n  }\n};\nfunction openManager(passcode, salt) {\n  if (passcode.length < 21) {\n    throw new Error(\"Bran (passcode seed material) too short.\");\n  }\n  const bran = MtrDex.Salt_128 + \"A\" + passcode.substring(0, 21);\n  const signer = new Salter({ qb64: bran }).signer(\n    MtrDex.Ed25519_Seed,\n    false\n  );\n  const seed = signer.qb64;\n  const aeid = signer.verfer.qb64;\n  let algo;\n  const salter = salt != void 0 ? new Salter({ qb64: salt }) : void 0;\n  if (salt != void 0) {\n    algo = \"salty\" /* salty */;\n  } else {\n    algo = \"randy\" /* randy */;\n  }\n  return new Manager({ seed, aeid, algo, salter });\n}\nvar Manager = class {\n  _seed;\n  _salt;\n  _encrypter;\n  _decrypter;\n  _ks;\n  constructor({ ks, seed, aeid, pidx, algo, salter, tier }) {\n    this._ks = ks == void 0 ? new Keeper() : ks;\n    this._seed = seed;\n    this._encrypter = void 0;\n    this._decrypter = void 0;\n    aeid = aeid == void 0 ? void 0 : aeid;\n    pidx = pidx == void 0 ? 0 : pidx;\n    algo = algo == void 0 ? \"salty\" /* salty */ : algo;\n    const salt = salter?.qb64;\n    tier = tier == void 0 ? \"low\" /* low */ : tier;\n    if (this.pidx == void 0) {\n      this.pidx = pidx;\n    }\n    if (this.algo == void 0) {\n      this.algo = algo;\n    }\n    if (this.salt == void 0) {\n      this.salt = salt;\n    }\n    if (this.tier == void 0) {\n      this.tier = tier;\n    }\n    if (this.aeid == void 0) {\n      this.updateAeid(aeid, this._seed);\n    }\n  }\n  get ks() {\n    return this._ks;\n  }\n  get encrypter() {\n    return this._encrypter;\n  }\n  get decrypter() {\n    return this._decrypter;\n  }\n  get seed() {\n    return this._seed;\n  }\n  get aeid() {\n    return this.ks.getGbls(\"aeid\");\n  }\n  get pidx() {\n    const pidx = this.ks.getGbls(\"pidx\");\n    if (pidx != void 0) {\n      return parseInt(pidx, 16);\n    }\n    return void 0;\n  }\n  set pidx(pidx) {\n    this.ks.pinGbls(\"pidx\", pidx.toString(16));\n  }\n  get salt() {\n    if (this._decrypter == void 0) {\n      return this._salt;\n    } else {\n      const salt = this.ks.getGbls(\"salt\");\n      return this._decrypter.decrypt(b(salt)).qb64;\n    }\n  }\n  set salt(salt) {\n    if (this._encrypter == void 0) {\n      this._salt = salt;\n    } else {\n      salt = this._encrypter.encrypt(b(salt)).qb64;\n      this.ks.pinGbls(\"salt\", salt);\n    }\n  }\n  get tier() {\n    return this.ks.getGbls(\"tier\");\n  }\n  set tier(tier) {\n    this.ks.pinGbls(\"tier\", tier);\n  }\n  get algo() {\n    const a = this.ks.getGbls(\"algo\");\n    const ta = a;\n    return Algos[ta];\n  }\n  set algo(algo) {\n    this.ks.pinGbls(\"algo\", algo);\n  }\n  updateAeid(aeid, seed) {\n    if (this.aeid != void 0) {\n      const seed2 = b(this._seed);\n      if (this._seed == void 0 || !this._encrypter?.verifySeed(seed2)) {\n        throw new Error(`Last seed missing or provided last seed \"\n                                       \"not associated with last aeid=${this.aeid}.`);\n      }\n    }\n    if (aeid != \"\" && aeid != void 0) {\n      if (aeid != this.aeid) {\n        this._encrypter = new Encrypter({}, b(aeid));\n        if (seed == void 0 || !this._encrypter.verifySeed(b(seed))) {\n          throw new Error(`Seed missing or provided seed not associated\"\n                                           \"  with provided aeid=${aeid}.`);\n        }\n      }\n    } else if (this.algo == \"randy\" /* randy */) {\n      throw new Error(\n        \"Invalid Manager configuration, encryption must be used with Randy key creation.\"\n      );\n    } else {\n      this._encrypter = void 0;\n    }\n    const salt = this.salt;\n    if (salt != void 0) {\n      this.salt = salt;\n    }\n    if (this._decrypter != void 0) {\n      for (const [keys, data] of this.ks.prmsElements()) {\n        if (data.salt != void 0) {\n          const salter = this._decrypter.decrypt(b(data.salt));\n          data.salt = this._encrypter == void 0 ? salter.qb64 : this._encrypter.encrypt(null, salter);\n          this.ks.pinPrms(keys, data);\n        }\n      }\n      for (const [pubKey, signer] of this.ks.prisElements(\n        this._decrypter\n      )) {\n        this.ks.pinPris(pubKey, signer, this._encrypter);\n      }\n    }\n    this.ks.pinGbls(\"aeid\", aeid);\n    this._seed = seed;\n    this._decrypter = seed != void 0 ? new Decrypter({}, b(seed)) : void 0;\n  }\n  incept({\n    icodes = void 0,\n    icount = 1,\n    icode = MtrDex.Ed25519_Seed,\n    ncodes = void 0,\n    ncount = 1,\n    ncode = MtrDex.Ed25519_Seed,\n    dcode = MtrDex.Blake3_256,\n    algo = void 0,\n    salt = void 0,\n    stem = void 0,\n    tier = void 0,\n    rooted = true,\n    transferable = true,\n    temp = false\n  }) {\n    if (rooted && algo == void 0) {\n      algo = this.algo;\n    }\n    if (rooted && salt == void 0) {\n      salt = this.salt;\n    }\n    if (rooted && tier == void 0) {\n      tier = this.tier;\n    }\n    const pidx = this.pidx;\n    const ridx = 0;\n    const kidx = 0;\n    const creator = new Creatory(algo).make(salt, tier, stem);\n    if (icodes == void 0) {\n      if (icount < 0) {\n        throw new Error(`Invalid icount=${icount} must be >= 0.`);\n      }\n      icodes = new Array(icount).fill(icode);\n    }\n    const ikeys = creator.create(\n      icodes,\n      0,\n      MtrDex.Ed25519_Seed,\n      transferable,\n      pidx,\n      ridx,\n      kidx,\n      temp\n    );\n    const verfers = Array.from(\n      ikeys.signers,\n      (signer) => signer.verfer\n    );\n    if (ncodes == void 0) {\n      if (ncount < 0) {\n        throw new Error(`Invalid ncount=${ncount} must be >= 0.`);\n      }\n      ncodes = new Array(ncount).fill(ncode);\n    }\n    const nkeys = creator.create(\n      ncodes,\n      0,\n      MtrDex.Ed25519_Seed,\n      transferable,\n      pidx,\n      ridx + 1,\n      kidx + icodes.length,\n      temp\n    );\n    const digers = Array.from(\n      nkeys.signers,\n      (signer) => new Diger({ code: dcode }, signer.verfer.qb64b)\n    );\n    const pp = new PrePrm();\n    pp.pidx = pidx;\n    pp.algo = algo;\n    pp.salt = creator.salt.length == 0 || this.encrypter == void 0 ? \"\" : this.encrypter.encrypt(b(creator.salt)).qb64;\n    pp.stem = creator.stem;\n    pp.tier = creator.tier;\n    const dt = (/* @__PURE__ */ new Date()).toString();\n    const nw = new PubLot();\n    nw.pubs = Array.from(verfers, (verfer) => verfer.qb64);\n    nw.ridx = ridx;\n    nw.kidx = kidx;\n    nw.dt = dt;\n    const nt = new PubLot();\n    nt.pubs = Array.from(\n      nkeys.signers,\n      (signer) => signer.verfer.qb64\n    );\n    nt.ridx = ridx + 1;\n    nt.kidx = kidx + icodes.length;\n    nt.dt = dt;\n    const ps = new PreSit();\n    ps.new = nw;\n    ps.nxt = nt;\n    const pre = verfers[0].qb64;\n    if (!this.ks.putPres(pre, verfers[0].qb64b)) {\n      throw new Error(`Already incepted pre=${pre}.`);\n    }\n    if (!this.ks.putPrms(pre, pp)) {\n      throw new Error(`Already incepted prm for pre=${pre}.`);\n    }\n    this.pidx = pidx + 1;\n    if (!this.ks.putSits(pre, ps)) {\n      throw new Error(`Already incepted sit for pre=${pre}.`);\n    }\n    if (this.encrypter != void 0) {\n      ikeys.signers.forEach((signer) => {\n        this.ks.putPris(signer.verfer.qb64, signer, this.encrypter);\n      });\n      nkeys.signers.forEach((signer) => {\n        this.ks.putPris(signer.verfer.qb64, signer, this.encrypter);\n      });\n    } else if (this._encrypter == void 0 && ikeys.paths != void 0 && nkeys.paths != void 0) {\n      ikeys.paths.forEach((path, idx) => {\n        const signer = ikeys.signers[idx];\n        const ppt = new PubPath();\n        ppt.path = path;\n        ppt.code = icodes[idx];\n        ppt.tier = pp.tier;\n        ppt.temp = temp;\n        this.ks.putPths(signer.verfer.qb64, ppt);\n      });\n      nkeys.paths.forEach((path, idx) => {\n        const signer = nkeys.signers[idx];\n        const ppt = new PubPath();\n        ppt.path = path;\n        ppt.code = ncodes[idx];\n        ppt.tier = pp.tier;\n        ppt.temp = temp;\n        this.ks.putPths(signer.verfer.qb64, ppt);\n      });\n    } else {\n      throw new Error(\n        \"invalid configuration, randy keys without encryption\"\n      );\n    }\n    const pubSet = new PubSet();\n    pubSet.pubs = ps.new.pubs;\n    this.ks.putPubs(riKey(pre, ridx), pubSet);\n    const nxtPubSet = new PubSet();\n    nxtPubSet.pubs = ps.nxt.pubs;\n    this.ks.putPubs(riKey(pre, ridx + 1), nxtPubSet);\n    return [verfers, digers];\n  }\n  move(old, gnu) {\n    if (old == gnu) {\n      return;\n    }\n    if (this.ks.getPres(old) == void 0) {\n      throw new Error(`Nonexistent old pre=${old}, nothing to assign.`);\n    }\n    if (this.ks.getPres(gnu) != void 0) {\n      throw new Error(`Preexistent new pre=${gnu} may not clobber.`);\n    }\n    const oldprm = this.ks.getPrms(old);\n    if (oldprm == void 0) {\n      throw new Error(\n        `Nonexistent old prm for pre=${old}, nothing to move.`\n      );\n    }\n    if (this.ks.getPrms(gnu) != void 0) {\n      throw new Error(\n        `Preexistent new prm for pre=${gnu} may not clobber.`\n      );\n    }\n    const oldsit = this.ks.getSits(old);\n    if (oldsit == void 0) {\n      throw new Error(\n        `Nonexistent old sit for pre=${old}, nothing to move.`\n      );\n    }\n    if (this.ks.getSits(gnu) != void 0) {\n      throw new Error(\n        `Preexistent new sit for pre=${gnu} may not clobber.`\n      );\n    }\n    if (!this.ks.putPrms(gnu, oldprm)) {\n      throw new Error(\n        `Failed moving prm from old pre=${old} to new pre=${gnu}.`\n      );\n    } else {\n      this.ks.remPrms(old);\n    }\n    if (!this.ks.putSits(gnu, oldsit)) {\n      throw new Error(\n        `Failed moving sit from old pre=${old} to new pre=${gnu}.`\n      );\n    } else {\n      this.ks.remSits(old);\n    }\n    let i = 0;\n    while (true) {\n      const pl = this.ks.getPubs(riKey(old, i));\n      if (pl == void 0) {\n        break;\n      }\n      if (!this.ks.putPubs(riKey(gnu, i), pl)) {\n        throw new Error(\n          `Failed moving pubs at pre=${old} ri=${i} to new pre=${gnu}`\n        );\n      }\n      i = i + 1;\n    }\n    if (!this.ks.pinPres(old, b(gnu))) {\n      throw new Error(\n        `Failed assiging new pre=${gnu} to old pre=${old}.`\n      );\n    }\n    if (!this.ks.putPres(gnu, b(gnu))) {\n      throw new Error(`Failed assiging new pre=${gnu}.`);\n    }\n  }\n  rotate({\n    pre,\n    ncodes = void 0,\n    ncount = 1,\n    ncode = MtrDex.Ed25519_Seed,\n    dcode = MtrDex.Blake3_256,\n    transferable = true,\n    temp = false,\n    erase = true\n  }) {\n    const pp = this.ks.getPrms(pre);\n    if (pp == void 0) {\n      throw new Error(`Attempt to rotate nonexistent pre=${pre}.`);\n    }\n    const ps = this.ks.getSits(pre);\n    if (ps == void 0) {\n      throw new Error(`Attempt to rotate nonexistent pre=${pre}.`);\n    }\n    if (ps.nxt.pubs == void 0 || ps.nxt.pubs.length == 0) {\n      throw new Error(`Attempt to rotate nontransferable pre=${pre}.`);\n    }\n    const old = ps.old;\n    ps.old = ps.new;\n    ps.new = ps.nxt;\n    if (this.aeid != void 0 && this.decrypter == void 0) {\n      throw new Error(\n        \"Unauthorized decryption attempt.  Aeid but no decrypter.\"\n      );\n    }\n    const verfers = new Array();\n    ps.new.pubs.forEach((pub) => {\n      if (this.decrypter != void 0) {\n        const signer = this.ks.getPris(pub, this.decrypter);\n        if (signer == void 0) {\n          throw new Error(`Missing prikey in db for pubkey=${pub}`);\n        }\n        verfers.push(signer.verfer);\n      } else {\n        verfers.push(new Verfer({ qb64: pub }));\n      }\n    });\n    let salt = pp.salt;\n    if (salt != void 0 && salt != \"\") {\n      if (this.decrypter == void 0) {\n        throw new Error(\n          \"Invalid configuration: AID salt with no encryption\"\n        );\n      }\n      salt = this.decrypter.decrypt(b(salt)).qb64;\n    } else {\n      salt = this.salt;\n    }\n    const creator = new Creatory(pp.algo).make(salt, pp.tier, pp.stem);\n    if (ncodes == void 0) {\n      if (ncount < 0) {\n        throw new Error(`Invalid count=${ncount} must be >= 0`);\n      }\n      ncodes = new Array(ncount).fill(ncode);\n    }\n    const pidx = pp.pidx;\n    const ridx = ps.new.ridx + 1;\n    const kidx = ps.nxt.kidx + ps.new.pubs.length;\n    const keys = creator.create(\n      ncodes,\n      0,\n      \"\",\n      transferable,\n      pidx,\n      ridx,\n      kidx,\n      temp\n    );\n    const digers = Array.from(\n      keys.signers,\n      (signer) => new Diger({ code: dcode }, signer.verfer.qb64b)\n    );\n    const dt = (/* @__PURE__ */ new Date()).toString();\n    ps.nxt = new PubLot();\n    ps.nxt.pubs = Array.from(\n      keys.signers,\n      (signer) => signer.verfer.qb64\n    );\n    ps.nxt.ridx = ridx;\n    ps.nxt.kidx = kidx;\n    ps.nxt.dt = dt;\n    if (!this.ks.pinSits(pre, ps)) {\n      throw new Error(`Problem updating pubsit db for pre=${pre}.`);\n    }\n    if (this.encrypter != void 0) {\n      keys.signers.forEach((signer) => {\n        this.ks.putPris(signer.verfer.qb64, signer, this.encrypter);\n      });\n    } else if (this._encrypter == void 0 && keys.paths != void 0) {\n      keys.paths.forEach((path, idx) => {\n        const signer = keys.signers[idx];\n        const ppt = new PubPath();\n        ppt.path = path;\n        ppt.tier = pp.tier;\n        ppt.temp = temp;\n        this.ks.putPths(signer.verfer.qb64, ppt);\n      });\n    } else {\n      throw new Error(\n        \"invalid configuration, randy keys without encryption\"\n      );\n    }\n    const newPs = new PubSet();\n    newPs.pubs = ps.nxt.pubs;\n    this.ks.putPubs(riKey(pre, ps.nxt.ridx), newPs);\n    if (erase) {\n      old.pubs.forEach((pub) => {\n        this.ks.remPris(pub);\n      });\n    }\n    return [verfers, digers];\n  }\n  sign({\n    ser,\n    pubs = void 0,\n    verfers = void 0,\n    indexed = true,\n    indices = void 0,\n    ondices = void 0\n  }) {\n    const signers = new Array();\n    if (pubs == void 0 && verfers == void 0) {\n      throw new Error(\"pubs or verfers required\");\n    }\n    if (pubs != void 0) {\n      if (this.aeid != void 0 && this.decrypter == void 0) {\n        throw new Error(\n          \"Unauthorized decryption attempt.  Aeid but no decrypter.\"\n        );\n      }\n      pubs.forEach((pub) => {\n        if (this.decrypter != void 0) {\n          const signer = this.ks.getPris(pub, this.decrypter);\n          if (signer == void 0) {\n            throw new Error(\n              `Missing prikey in db for pubkey=${pub}`\n            );\n          }\n          signers.push(signer);\n        } else {\n          const verfer = new Verfer({ qb64: pub });\n          const ppt = this.ks.getPths(pub);\n          if (ppt == void 0) {\n            throw new Error(\n              `Missing prikey in db for pubkey=${pub}`\n            );\n          }\n          const salter = new Salter({ qb64: this.salt });\n          signers.push(\n            salter.signer(\n              ppt.code,\n              verfer.transferable,\n              ppt.path,\n              ppt.tier,\n              ppt.temp\n            )\n          );\n        }\n      });\n    } else {\n      verfers.forEach((verfer) => {\n        if (this.decrypter != void 0) {\n          const signer = this.ks.getPris(verfer.qb64, this.decrypter);\n          if (signer == void 0) {\n            throw new Error(\n              `Missing prikey in db for pubkey=${verfer.qb64}`\n            );\n          }\n          signers.push(signer);\n        } else {\n          const ppt = this.ks.getPths(verfer.qb64);\n          if (ppt == void 0) {\n            throw new Error(\n              `Missing prikey in db for pubkey=${verfer.qb64}`\n            );\n          }\n          const salter = new Salter({ qb64: this.salt });\n          signers.push(\n            salter.signer(\n              ppt.code,\n              verfer.transferable,\n              ppt.path,\n              ppt.tier,\n              ppt.temp\n            )\n          );\n        }\n      });\n    }\n    if (indices != void 0 && indices.length != signers.length) {\n      throw new Error(\n        `Mismatch indices length=${indices.length} and resultant signers length=${signers.length}`\n      );\n    }\n    if (ondices != void 0 && ondices.length != signers.length) {\n      throw new Error(\n        `Mismatch ondices length=${ondices.length} and resultant signers length=${signers.length}`\n      );\n    }\n    if (indexed) {\n      const sigers = new Array();\n      signers.forEach((signer, idx) => {\n        let i;\n        if (indices != void 0) {\n          i = indices[idx];\n          if (i < 0) {\n            throw new Error(\n              `Invalid signing index = ${i}, not whole number.`\n            );\n          }\n        } else {\n          i = idx;\n        }\n        let o;\n        if (ondices != void 0) {\n          o = ondices[idx];\n          if (o <= 0) {\n            throw new Error(\n              `Invalid other signing index = {o}, not None or not whole number.`\n            );\n          }\n        } else {\n          o = i;\n        }\n        const only = o == void 0;\n        sigers.push(signer.sign(ser, i, only, o));\n      });\n      return sigers;\n    } else {\n      const cigars = new Array();\n      signers.forEach((signer) => {\n        cigars.push(signer.sign(ser));\n      });\n      return cigars;\n    }\n  }\n};\nfunction riKey(pre, ridx) {\n  return pre + \".\" + ridx.toString(16).padStart(32, \"0\");\n}\nvar Keeper = class {\n  _gbls;\n  _pris;\n  _pths;\n  _pres;\n  _prms;\n  _sits;\n  _pubs;\n  constructor() {\n    this._gbls = /* @__PURE__ */ new Map();\n    this._pris = /* @__PURE__ */ new Map();\n    this._pths = /* @__PURE__ */ new Map();\n    this._pres = /* @__PURE__ */ new Map();\n    this._prms = /* @__PURE__ */ new Map();\n    this._sits = /* @__PURE__ */ new Map();\n    this._pubs = /* @__PURE__ */ new Map();\n  }\n  getGbls(key) {\n    return this._gbls.get(key);\n  }\n  pinGbls(key, val) {\n    this._gbls.set(key, val);\n  }\n  prmsElements() {\n    const out = new Array();\n    this._prms.forEach((value, key) => {\n      out.push([key, value]);\n    });\n    return out;\n  }\n  getPrms(keys) {\n    return this._prms.get(keys);\n  }\n  pinPrms(keys, data) {\n    this._prms.set(keys, data);\n  }\n  putPrms(keys, data) {\n    if (this._prms.has(keys)) {\n      return false;\n    }\n    this._prms.set(keys, data);\n    return true;\n  }\n  remPrms(keys) {\n    return this._prms.delete(keys);\n  }\n  prisElements(decrypter) {\n    const out = new Array();\n    this._pris.forEach(function(val, pubKey) {\n      const verfer = new Verfer({ qb64: pubKey });\n      const signer = decrypter.decrypt(val, null, verfer.transferable);\n      out.push([pubKey, signer]);\n    });\n    return out;\n  }\n  pinPris(pubKey, signer, encrypter) {\n    const cipher = encrypter.encrypt(null, signer);\n    this._pris.set(pubKey, cipher.qb64b);\n  }\n  putPris(pubKey, signer, encrypter) {\n    if (this._pris.has(pubKey)) {\n      return false;\n    }\n    const cipher = encrypter.encrypt(null, signer);\n    this._pris.set(pubKey, cipher.qb64b);\n    return true;\n  }\n  getPris(pubKey, decrypter) {\n    const val = this._pris.get(pubKey);\n    if (val == void 0) {\n      return void 0;\n    }\n    const verfer = new Verfer({ qb64: pubKey });\n    return decrypter.decrypt(val, null, verfer.transferable);\n  }\n  pinPths(pubKey, val) {\n    this._pths.set(pubKey, val);\n    return true;\n  }\n  putPths(pubKey, val) {\n    if (this._pths.has(pubKey)) {\n      return false;\n    }\n    this._pths.set(pubKey, val);\n    return true;\n  }\n  getPths(pubKey) {\n    return this._pths.get(pubKey);\n  }\n  remPris(pubKey) {\n    this._pris.delete(pubKey);\n  }\n  getPres(pre) {\n    return this._pres.get(pre);\n  }\n  pinPres(pre, val) {\n    this._pres.set(pre, val);\n    return true;\n  }\n  putPres(pre, val) {\n    if (this._pres.has(pre)) {\n      return false;\n    }\n    this._pres.set(pre, val);\n    return true;\n  }\n  getSits(keys) {\n    return this._sits.get(keys);\n  }\n  putSits(pre, val) {\n    if (this._sits.has(pre)) {\n      return false;\n    }\n    this._sits.set(pre, val);\n    return true;\n  }\n  pinSits(pre, val) {\n    this._sits.set(pre, val);\n    return true;\n  }\n  remSits(keys) {\n    return this._sits.delete(keys);\n  }\n  getPubs(keys) {\n    return this._pubs.get(keys);\n  }\n  putPubs(keys, data) {\n    if (this._pubs.has(keys)) {\n      return false;\n    }\n    this._pubs.set(keys, data);\n    return true;\n  }\n};\n\n// src/keri/core/tholder.ts\n\nvar Tholder = class {\n  _weighted = false;\n  _thold = void 0;\n  _size = 0;\n  _number = void 0;\n  _satisfy = void 0;\n  // private _bexter: any\n  constructor(kargs) {\n    if (kargs.thold !== void 0) {\n      this._processThold(kargs.thold);\n    } else if (kargs.limen != void 0) {\n      this._processLimen(kargs.limen);\n    } else if (kargs.sith !== void 0) {\n      this._processSith(kargs.sith);\n    } else {\n      throw new Error(\"Missing threshold expression\");\n    }\n  }\n  get weighted() {\n    return this._weighted;\n  }\n  get thold() {\n    return this._thold;\n  }\n  get size() {\n    return this._size;\n  }\n  get limen() {\n    return this._number?.qb64b;\n  }\n  get sith() {\n    if (this.weighted) {\n      let sith = this.thold.map((clause) => {\n        return clause.map((c) => {\n          if (0 < Number(c) && Number(c) < 1) {\n            return (0,mathjs__WEBPACK_IMPORTED_MODULE_4__.format)(c, { fraction: \"ratio\" });\n          } else {\n            return (0,mathjs__WEBPACK_IMPORTED_MODULE_4__.format)(c, { fraction: \"decimal\" });\n          }\n        });\n      });\n      if (sith.length == 1) {\n        sith = sith[0];\n      }\n      return sith;\n    } else {\n      return this.thold.toString(16);\n    }\n  }\n  get json() {\n    return JSON.stringify(this.sith);\n  }\n  get num() {\n    return this._weighted ? void 0 : this._thold;\n  }\n  _processThold(thold) {\n    if (typeof thold === \"number\") {\n      this._processUnweighted(thold);\n    } else {\n      this._processWeighted(thold);\n    }\n  }\n  _processLimen(limen) {\n    const matter = new Matter({ qb64: limen });\n    if (NumDex.has(matter.code)) {\n      const number = new CesrNumber({\n        raw: matter.raw,\n        code: matter.code\n      });\n      this._processUnweighted(number.num);\n    } else if (BexDex.has(matter.code)) {\n    } else {\n      throw new Error(\"Invalid code for limen=\" + matter.code);\n    }\n  }\n  _processSith(sith) {\n    if (typeof sith == \"number\") {\n      this._processUnweighted(sith);\n    } else if (typeof sith == \"string\" && sith.indexOf(\"[\") == -1) {\n      this._processUnweighted(parseInt(sith, 16));\n    } else {\n      let _sith = sith;\n      if (typeof sith == \"string\") {\n        _sith = JSON.parse(sith);\n      }\n      if (_sith.length == 0) {\n        throw new Error(\"Empty weight list\");\n      }\n      const mask = _sith.map((x) => {\n        return typeof x !== \"string\";\n      });\n      if (mask.length > 0 && !mask.every((x) => x)) {\n        _sith = [_sith];\n      }\n      for (const c of _sith) {\n        const mask2 = c.map((x) => {\n          return typeof x === \"string\";\n        });\n        if (mask2.length > 0 && !mask2.every((x) => x)) {\n          throw new Error(\n            \"Invalid sith, some weights in clause \" + mask2 + \" are non string\"\n          );\n        }\n      }\n      const thold = this._processClauses(_sith);\n      this._processWeighted(thold);\n    }\n  }\n  _processClauses(sith) {\n    const thold = new Array();\n    sith.forEach((clause) => {\n      thold.push(\n        clause.map((w) => {\n          return this.weight(w);\n        })\n      );\n    });\n    return thold;\n  }\n  _processUnweighted(thold) {\n    if (thold < 0) {\n      throw new Error(\"Non-positive int threshold = {thold}.\");\n    }\n    this._thold = thold;\n    this._weighted = false;\n    this._size = this._thold;\n    this._satisfy = this._satisfy_numeric;\n    this._number = new CesrNumber({}, thold);\n  }\n  _processWeighted(thold) {\n    for (const clause of thold) {\n      if (Number((0,mathjs__WEBPACK_IMPORTED_MODULE_4__.sum)(clause)) < 1) {\n        throw new Error(\n          \"Invalid sith clause: \" + thold + \"all clause weight sums must be >= 1\"\n        );\n      }\n    }\n    this._thold = thold;\n    this._weighted = true;\n    this._size = thold.reduce((acc, currentValue) => {\n      return acc + currentValue.length;\n    }, 0);\n    this._satisfy = this._satisfy_weighted;\n  }\n  weight(w) {\n    return (0,mathjs__WEBPACK_IMPORTED_MODULE_4__.fraction)(w);\n  }\n  _satisfy_numeric(indices) {\n    return this.thold > 0 && indices.length >= this.thold;\n  }\n  _satisfy_weighted(indices) {\n    if (indices.length === 0) {\n      return false;\n    }\n    const indexes = new Set(indices.sort());\n    const sats = new Array(indices.length).fill(false);\n    for (const idx of indexes) {\n      sats[idx] = true;\n    }\n    let wio = 0;\n    for (const clause of this.thold) {\n      let cw = 0;\n      for (const w of clause) {\n        if (sats[wio]) {\n          cw += Number(w);\n        }\n        wio += 1;\n      }\n      if (cw < 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  satisfy(indices) {\n    return this._satisfy(indices);\n  }\n};\n\n// src/keri/core/eventing.ts\nvar MaxIntThold = 2 ** 32 - 1;\nfunction rotate({\n  pre = void 0,\n  keys,\n  dig = void 0,\n  ilk = Ilks.rot,\n  sn = 1,\n  isith = void 0,\n  ndigs = void 0,\n  nsith = void 0,\n  wits = void 0,\n  cuts = void 0,\n  adds = void 0,\n  toad = void 0,\n  data = void 0,\n  version = void 0,\n  kind = void 0,\n  intive = true\n}) {\n  const vs = versify(\"KERI\" /* KERI */, version, kind, 0);\n  const _ilk = ilk;\n  if (_ilk != Ilks.rot && _ilk != Ilks.drt) {\n    throw new Error(`Invalid ilk = ${ilk} for rot or drt.`);\n  }\n  const sner = new CesrNumber({}, sn);\n  if (sner.num < 1) {\n    throw new Error(`Invalid sn = 0x${sner.numh} for rot or drt.`);\n  }\n  let _isit;\n  if (isith == void 0) {\n    _isit = Math.max(1, Math.ceil(keys.length / 2));\n  } else {\n    _isit = isith;\n  }\n  const tholder = new Tholder({ sith: _isit });\n  if (tholder.num != void 0 && tholder.num < 1) {\n    throw new Error(`Invalid sith = ${tholder.num} less than 1.`);\n  }\n  if (tholder.size > keys.length) {\n    throw new Error(`Invalid sith = ${tholder.num} for keys = ${keys}`);\n  }\n  let _ndigs;\n  if (ndigs === void 0) {\n    _ndigs = [];\n  } else {\n    _ndigs = ndigs;\n  }\n  let _nsith;\n  if (nsith === void 0) {\n    _nsith = Math.max(1, Math.ceil(_ndigs.length / 2));\n  } else {\n    _nsith = nsith;\n  }\n  const ntholder = new Tholder({ sith: _nsith });\n  if (ntholder.num != void 0 && ntholder.num < 1) {\n    throw new Error(`Invalid sith = ${ntholder.num} less than 1.`);\n  }\n  if (ntholder.size > _ndigs.length) {\n    throw new Error(`Invalid sith = ${ntholder.num} for ndigs = ${ndigs}`);\n  }\n  let _wits;\n  if (wits === void 0) {\n    _wits = [];\n  } else {\n    _wits = wits;\n  }\n  const witset = new Set(_wits);\n  if (witset.size != _wits.length) {\n    throw new Error(`Invalid wits = ${wits}, has duplicates.`);\n  }\n  let _cuts;\n  if (cuts === void 0) {\n    _cuts = [];\n  } else {\n    _cuts = cuts;\n  }\n  const cutset = new Set(_cuts);\n  if (cutset.size != _cuts.length) {\n    throw new Error(`Invalid cuts = ${cuts}, has duplicates.`);\n  }\n  let _adds;\n  if (adds === void 0) {\n    _adds = [];\n  } else {\n    _adds = adds;\n  }\n  const addset = new Set(_adds);\n  const witaddset = new Set([...witset].filter((x) => addset.has(x)));\n  if (witaddset.size > 0) {\n    throw new Error(\n      `Invalid member combination among wits = ${wits}, and adds = ${adds}.`\n    );\n  }\n  const cutaddset = new Set([...cutset].filter((x) => addset.has(x)));\n  if (cutaddset.size > 0) {\n    throw new Error(\n      `Invalid member combination among cuts = ${cuts}, and adds = ${adds}.`\n    );\n  }\n  const newitsetdiff = new Set(_wits);\n  _cuts.forEach(function(v) {\n    newitsetdiff.delete(v);\n  });\n  const newitset = new Set(\n    function* () {\n      yield* newitsetdiff;\n      yield* addset;\n    }()\n  );\n  if (newitset.size != witset.size - cutset.size + addset.size) {\n    throw new Error(\n      `Invalid member combination among wits = ${wits}, cuts = ${cuts}, and adds = ${adds}.`\n    );\n  }\n  let _toad;\n  if (toad === void 0) {\n    if (newitset.size == 0) {\n      _toad = 0;\n    } else {\n      _toad = ample(newitset.size);\n    }\n  } else {\n    _toad = toad;\n  }\n  if (newitset.size > 0) {\n    if (_toad < 1 || _toad > newitset.size) {\n      throw new Error(`Invalid toad = ${_toad} for wit = ${wits}`);\n    }\n  } else {\n    if (_toad != 0) {\n      throw new Error(`Invalid toad = ${_toad} for wit = ${wits}`);\n    }\n  }\n  const _ked = {\n    v: vs,\n    t: _ilk,\n    d: \"\",\n    i: pre,\n    s: sner.numh,\n    p: dig,\n    kt: tholder.num && intive && tholder.num !== void 0 && tholder.num <= MaxIntThold ? tholder.num.toString(16) : tholder.sith,\n    k: keys,\n    nt: ntholder.num && intive && ntholder.num !== void 0 && ntholder.num <= MaxIntThold ? ntholder.num.toString(16) : ntholder.sith,\n    n: _ndigs,\n    bt: _toad && intive && _toad !== void 0 && _toad <= MaxIntThold ? _toad : _toad.toString(16),\n    br: cuts,\n    ba: adds,\n    a: data != void 0 ? data : []\n  };\n  const [, ked] = Saider.saidify(_ked);\n  return new Serder(ked);\n}\nfunction ample(n, f, weak = true) {\n  n = Math.max(0, n);\n  let f1;\n  if (f == void 0) {\n    f1 = Math.max(1, Math.floor(Math.max(0, n - 1) / 3));\n    const f2 = Math.max(1, Math.ceil(Math.max(0, n - 1) / 3));\n    if (weak) {\n      return Math.min(\n        n,\n        Math.ceil((n + f1 + 1) / 2),\n        Math.ceil((n + f2 + 1) / 2)\n      );\n    } else {\n      return Math.min(\n        n,\n        Math.max(0, n - f1, Math.ceil((n + f1 + 1) / 2))\n      );\n    }\n  } else {\n    f = Math.max(0, f);\n    const m1 = Math.ceil((n + f + 1) / 2);\n    const m2 = Math.max(0, n - f);\n    if (m2 < m1 && n > 0) {\n      throw new Error(`Invalid f=${f} is too big for n=${n}.`);\n    }\n    if (weak) {\n      return Math.min(n, m1, m2);\n    } else {\n      return Math.min(n, Math.max(m1, m2));\n    }\n  }\n}\nfunction incept({\n  keys,\n  isith,\n  ndigs,\n  nsith,\n  toad,\n  wits,\n  cnfg,\n  data,\n  version = Versionage,\n  kind = \"JSON\" /* JSON */,\n  code,\n  intive = false,\n  delpre\n}) {\n  const vs = versify(\"KERI\" /* KERI */, version, kind, 0);\n  const ilk = delpre == void 0 ? Ilks.icp : Ilks.dip;\n  const sner = new CesrNumber({}, 0);\n  if (isith == void 0) {\n    isith = Math.max(1, Math.ceil(keys.length / 2));\n  }\n  const tholder = new Tholder({ sith: isith });\n  if (tholder.num != void 0 && tholder.num < 1) {\n    throw new Error(`Invalid sith = ${tholder.num} less than 1.`);\n  }\n  if (tholder.size > keys.length) {\n    throw new Error(`Invalid sith = ${tholder.num} for keys ${keys}`);\n  }\n  if (ndigs == void 0) {\n    ndigs = new Array();\n  }\n  if (nsith == void 0) {\n    nsith = Math.max(0, Math.ceil(ndigs.length / 2));\n  }\n  const ntholder = new Tholder({ sith: nsith });\n  if (ntholder.num != void 0 && ntholder.num < 0) {\n    throw new Error(`Invalid nsith = ${ntholder.num} less than 0.`);\n  }\n  if (ntholder.size > keys.length) {\n    throw new Error(`Invalid nsith = ${ntholder.num} for keys ${ndigs}`);\n  }\n  wits = wits == void 0 ? [] : wits;\n  if (new Set(wits).size != wits.length) {\n    throw new Error(`Invalid wits = ${wits}, has duplicates.`);\n  }\n  if (toad == void 0) {\n    if (wits.length == 0) {\n      toad = 0;\n    } else {\n      toad = ample(wits.length);\n    }\n  }\n  const toader = new CesrNumber({}, toad);\n  if (wits.length > 0) {\n    if (toader.num < 1 || toader.num > wits.length) {\n      throw new Error(`Invalid toad = ${toader.num} for wits = ${wits}`);\n    }\n  } else {\n    if (toader.num != 0) {\n      throw new Error(`Invalid toad = ${toader.num} for wits = ${wits}`);\n    }\n  }\n  cnfg = cnfg == void 0 ? new Array() : cnfg;\n  data = data == void 0 ? new Array() : data;\n  let ked = {\n    v: vs,\n    t: ilk,\n    d: \"\",\n    i: \"\",\n    s: sner.numh,\n    kt: intive && tholder.num != void 0 ? tholder.num : tholder.sith,\n    k: keys,\n    nt: intive && tholder.num != void 0 ? ntholder.num : ntholder.sith,\n    n: ndigs,\n    bt: intive ? toader.num : toader.numh,\n    b: wits,\n    c: cnfg,\n    a: data\n  };\n  if (delpre != void 0) {\n    ked[\"di\"] = delpre;\n    if (code == void 0) {\n      code = MtrDex.Blake3_256;\n    }\n  }\n  let prefixer;\n  if (delpre == void 0 && code == void 0 && keys.length == 1) {\n    prefixer = new Prefixer({ qb64: keys[0] });\n    if (prefixer.digestive) {\n      throw new Error(\n        `Invalid code, digestive=${prefixer.code}, must be derived from ked.`\n      );\n    }\n  } else {\n    prefixer = new Prefixer({ code }, ked);\n    if (delpre != void 0) {\n      if (!prefixer.digestive) {\n        throw new Error(\n          `Invalid derivation code = ${prefixer.code} for delegation. Must be digestive`\n        );\n      }\n    }\n  }\n  ked[\"i\"] = prefixer.qb64;\n  if (prefixer.digestive) {\n    ked[\"d\"] = prefixer.qb64;\n  } else {\n    [, ked] = Saider.saidify(ked);\n  }\n  return new Serder(ked);\n}\nfunction messagize(serder, sigers, seal, wigers, cigars, pipelined = false) {\n  let msg = new Uint8Array(b(serder.raw));\n  let atc = new Uint8Array();\n  if (sigers == void 0 && wigers == void 0 && cigars == void 0) {\n    throw new Error(\n      `Missing attached signatures on message = ${serder.ked}.`\n    );\n  }\n  if (sigers != void 0) {\n    if (seal != void 0) {\n      if (seal[0] == \"SealEvent\") {\n        atc = concat(\n          atc,\n          new Counter({ code: CtrDex.TransIdxSigGroups, count: 1 }).qb64b\n        );\n        atc = concat(atc, new TextEncoder().encode(seal[1].i));\n        atc = concat(\n          atc,\n          new Seqner({ sn: parseInt(seal[1].s) }).qb64b\n        );\n        atc = concat(atc, new TextEncoder().encode(seal[1].d));\n      } else if (seal[0] == \"SealLast\") {\n        atc = concat(\n          atc,\n          new Counter({\n            code: CtrDex.TransLastIdxSigGroups,\n            count: 1\n          }).qb64b\n        );\n        atc = concat(atc, new TextEncoder().encode(seal[1].i));\n      }\n    }\n    atc = concat(\n      atc,\n      new Counter({\n        code: CtrDex.ControllerIdxSigs,\n        count: sigers.length\n      }).qb64b\n    );\n    sigers.forEach((siger) => {\n      atc = concat(atc, siger.qb64b);\n    });\n  }\n  if (wigers != void 0) {\n    atc = concat(\n      atc,\n      new Counter({\n        code: CtrDex.ControllerIdxSigs,\n        count: wigers.length\n      }).qb64b\n    );\n    wigers.forEach((wiger) => {\n      if (wiger.verfer && !(wiger.verfer.code in NonTransDex)) {\n        throw new Error(\n          `Attempt to use tranferable prefix=${wiger.verfer.qb64} for receipt.`\n        );\n      }\n      atc = concat(atc, wiger.qb64b);\n    });\n  }\n  if (cigars != void 0) {\n    atc = concat(\n      atc,\n      new Counter({\n        code: CtrDex.ControllerIdxSigs,\n        count: cigars.length\n      }).qb64b\n    );\n    cigars.forEach((cigar) => {\n      if (cigar.verfer && !(cigar.verfer.code in NonTransDex)) {\n        throw new Error(\n          `Attempt to use tranferable prefix=${cigar.verfer.qb64} for receipt.`\n        );\n      }\n      atc = concat(atc, cigar.qb64b);\n    });\n  }\n  if (pipelined) {\n    if (atc.length % 4 != 0) {\n      throw new Error(\n        `Invalid attachments size=${atc.length}, nonintegral quadlets.`\n      );\n    }\n    msg = concat(\n      msg,\n      new Counter({\n        code: CtrDex.AttachedMaterialQuadlets,\n        count: Math.floor(atc.length / 4)\n      }).qb64b\n    );\n  }\n  msg = concat(msg, atc);\n  return msg;\n}\nfunction interact(args) {\n  let { pre, dig, sn, data, version, kind } = args;\n  const vs = versify(\"KERI\" /* KERI */, version, kind, 0);\n  const ilk = Ilks.ixn;\n  const sner = new CesrNumber({}, sn);\n  if (sner.num < 1) {\n    throw new Error(`Invalid sn = 0x${sner.numh} for ixn.`);\n  }\n  data = data == void 0 ? new Array() : data;\n  let ked = {\n    v: vs,\n    t: ilk,\n    d: \"\",\n    i: pre,\n    s: sner.numh,\n    p: dig,\n    a: data\n  };\n  [, ked] = Saider.saidify(ked);\n  return new Serder(ked);\n}\nfunction reply(route = \"\", data, stamp, version, kind = \"JSON\" /* JSON */) {\n  const vs = versify(\"KERI\" /* KERI */, version, kind, 0);\n  if (data == void 0) {\n    data = {};\n  }\n  const _sad = {\n    v: vs,\n    t: Ilks.rpy,\n    d: \"\",\n    dt: stamp ?? (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\"),\n    r: route,\n    a: data\n  };\n  const [, sad] = Saider.saidify(_sad);\n  const saider = new Saider({ qb64: sad[\"d\"] });\n  if (!saider.verify(sad, true, true, kind, \"d\"))\n    throw new Error(`Invalid said = ${saider.qb64} for reply msg=${sad}.`);\n  return new Serder(sad);\n}\n\n// src/keri/app/habery.ts\nvar TraitCodex = class {\n  EstOnly = \"EO\";\n  // Only allow establishment events\n  DoNotDelegate = \"DND\";\n  // Dot not allow delegated identifiers\n  NoBackers = \"NB\";\n  // Do not allow backers\n};\nvar TraitDex = new TraitCodex();\nvar Hab = class {\n  name;\n  serder;\n  constructor(name, icp) {\n    this.name = name;\n    this.serder = icp;\n  }\n  get pre() {\n    return this.serder.ked[\"i\"];\n  }\n};\nvar Habery = class {\n  _name;\n  _mgr;\n  _habs = /* @__PURE__ */ new Map();\n  constructor({ name, passcode, seed, aeid, pidx, salt }) {\n    this._name = name;\n    if (passcode != void 0 && seed == void 0) {\n      if (passcode.length < 21) {\n        throw new Error(\"Bran (passcode seed material) too short.\");\n      }\n      const bran = MtrDex.Salt_128 + \"A\" + passcode.substring(0, 21);\n      const signer = new Salter({ qb64: bran }).signer(\n        MtrDex.Ed25519_Seed,\n        false\n      );\n      seed = signer.qb64;\n      if (aeid == void 0) {\n        aeid = signer.verfer.qb64;\n      }\n    }\n    let algo;\n    const salter = salt != void 0 ? new Salter({ qb64: salt }) : void 0;\n    if (salt != void 0) {\n      algo = \"salty\" /* salty */;\n    } else {\n      algo = \"randy\" /* randy */;\n    }\n    this._mgr = new Manager({\n      seed,\n      aeid,\n      pidx,\n      algo,\n      salter\n    });\n  }\n  get mgr() {\n    return this._mgr;\n  }\n  get habs() {\n    return Array.from(this._habs.values());\n  }\n  habByName(name) {\n    return this._habs.get(name);\n  }\n  makeHab(name, {\n    code = MtrDex.Blake3_256,\n    transferable = true,\n    isith = void 0,\n    icount = 1,\n    nsith = void 0,\n    ncount = void 0,\n    toad = void 0,\n    wits = void 0,\n    delpre = void 0,\n    estOnly = false,\n    DnD = false,\n    data = void 0\n  }) {\n    if (nsith == void 0) {\n      nsith = isith;\n    }\n    if (ncount == void 0) {\n      ncount = icount;\n    }\n    if (!transferable) {\n      ncount = 0;\n      nsith = \"0\";\n      code = MtrDex.Ed25519N;\n    }\n    const [verfers, digers] = this._mgr.incept({\n      icount,\n      ncount,\n      stem: this.name,\n      transferable,\n      temp: false\n    });\n    icount = verfers.length;\n    ncount = digers != void 0 ? digers.length : 0;\n    if (isith == void 0) {\n      isith = `${Math.max(1, Math.ceil(icount / 2)).toString(16)}`;\n    }\n    if (nsith == void 0) {\n      nsith = `${Math.max(1, Math.ceil(ncount / 2)).toString(16)}`;\n    }\n    const cnfg = new Array();\n    if (estOnly) {\n      cnfg.push(TraitDex.EstOnly);\n    }\n    if (DnD) {\n      cnfg.push(TraitDex.DoNotDelegate);\n    }\n    const keys = Array.from(verfers, (verfer) => verfer.qb64);\n    const ndigs = Array.from(digers, (diger) => diger.qb64);\n    const icp = incept({\n      keys,\n      isith,\n      ndigs,\n      nsith,\n      toad,\n      wits,\n      cnfg,\n      data,\n      code,\n      delpre\n    });\n    const hab = new Hab(name, icp);\n    this._habs.set(name, hab);\n    return hab;\n  }\n  get name() {\n    return this._name;\n  }\n};\n\n// src/keri/app/controller.ts\nvar Agent = class {\n  pre;\n  anchor;\n  verfer;\n  state;\n  sn;\n  said;\n  constructor(agent) {\n    this.pre = \"\";\n    this.anchor = \"\";\n    this.verfer = null;\n    this.state = null;\n    this.sn = 0;\n    this.said = \"\";\n    this.parse(agent);\n  }\n  parse(agent) {\n    const [state, verfer] = this.event(agent);\n    this.sn = new CesrNumber({}, void 0, state[\"s\"]).num;\n    this.said = state[\"d\"];\n    if (state[\"et\"] !== Ilks.dip) {\n      throw new Error(`invalid inception event type ${state[\"et\"]}`);\n    }\n    this.pre = state[\"i\"];\n    if (!state[\"di\"]) {\n      throw new Error(\"no anchor to controller AID\");\n    }\n    this.anchor = state[\"di\"];\n    this.verfer = verfer;\n    this.state = state;\n  }\n  event(evt) {\n    if (evt[\"k\"].length !== 1) {\n      throw new Error(`agent inception event can only have one key`);\n    }\n    const verfer = new Verfer({ qb64: evt[\"k\"][0] });\n    if (evt[\"n\"].length !== 1) {\n      throw new Error(`agent inception event can only have one next key`);\n    }\n    const diger = new Diger({ qb64: evt[\"n\"][0] });\n    const tholder = new Tholder({ sith: evt[\"kt\"] });\n    if (tholder.num !== 1) {\n      throw new Error(`invalid threshold ${tholder.num}, must be 1`);\n    }\n    const ntholder = new Tholder({ sith: evt[\"nt\"] });\n    if (ntholder.num !== 1) {\n      throw new Error(\n        `invalid next threshold ${ntholder.num}, must be 1`\n      );\n    }\n    return [evt, verfer, diger];\n  }\n};\nvar Controller = class {\n  bran;\n  stem;\n  tier;\n  ridx;\n  salter;\n  signer;\n  nsigner;\n  serder;\n  keys;\n  ndigs;\n  constructor(bran, tier, ridx = 0, state = null) {\n    this.bran = MtrDex.Salt_128 + \"A\" + bran.substring(0, 21);\n    this.stem = \"signify:controller\";\n    this.tier = tier;\n    this.ridx = ridx;\n    this.salter = new Salter({ qb64: this.bran, tier: this.tier });\n    const creator = new SaltyCreator(\n      this.salter.qb64,\n      this.tier,\n      this.stem\n    );\n    this.signer = creator.create(\n      void 0,\n      1,\n      MtrDex.Ed25519_Seed,\n      true,\n      0,\n      this.ridx,\n      0,\n      false\n    ).signers.pop();\n    this.nsigner = creator.create(\n      void 0,\n      1,\n      MtrDex.Ed25519_Seed,\n      true,\n      0,\n      this.ridx + 1,\n      0,\n      false\n    ).signers.pop();\n    this.keys = [this.signer.verfer.qb64];\n    this.ndigs = [\n      new Diger({ code: MtrDex.Blake3_256 }, this.nsigner.verfer.qb64b).qb64\n    ];\n    if (state == null || state[\"ee\"][\"s\"] == 0) {\n      this.serder = incept({\n        keys: this.keys,\n        isith: \"1\",\n        nsith: \"1\",\n        ndigs: this.ndigs,\n        code: MtrDex.Blake3_256,\n        toad: \"0\",\n        wits: []\n      });\n    } else {\n      this.serder = new Serder(state[\"ee\"]);\n    }\n  }\n  approveDelegation(_agent) {\n    const seqner = new Seqner({ sn: _agent.sn });\n    const anchor = { i: _agent.pre, s: seqner.snh, d: _agent.said };\n    const sn = new CesrNumber({}, void 0, this.serder.ked[\"s\"]).num + 1;\n    this.serder = interact({\n      pre: this.serder.pre,\n      dig: this.serder.ked[\"d\"],\n      sn,\n      data: [anchor],\n      version: Versionage,\n      kind: \"JSON\" /* JSON */\n    });\n    return [this.signer.sign(this.serder.raw, 0).qb64];\n  }\n  get pre() {\n    return this.serder.pre;\n  }\n  get event() {\n    const siger = this.signer.sign(this.serder.raw, 0);\n    return [this.serder, siger];\n  }\n  get verfers() {\n    return this.signer.verfer();\n  }\n  derive(state) {\n    if (state != void 0 && state[\"ee\"][\"s\"] === \"0\") {\n      return incept({\n        keys: this.keys,\n        isith: \"1\",\n        nsith: \"1\",\n        ndigs: this.ndigs,\n        code: MtrDex.Blake3_256,\n        toad: \"0\",\n        wits: []\n      });\n    } else {\n      return new Serder({ ked: state.controller[\"ee\"] });\n    }\n  }\n  rotate(bran, aids) {\n    const nbran = MtrDex.Salt_128 + \"A\" + bran.substring(0, 21);\n    const nsalter = new Salter({ qb64: nbran, tier: this.tier });\n    const nsigner = this.salter.signer(void 0, false);\n    const creator = new SaltyCreator(\n      this.salter.qb64,\n      this.tier,\n      this.stem\n    );\n    const signer = creator.create(\n      void 0,\n      1,\n      MtrDex.Ed25519_Seed,\n      true,\n      0,\n      this.ridx + 1,\n      0,\n      false\n    ).signers.pop();\n    const ncreator = new SaltyCreator(nsalter.qb64, this.tier, this.stem);\n    this.signer = ncreator.create(\n      void 0,\n      1,\n      MtrDex.Ed25519_Seed,\n      true,\n      0,\n      this.ridx,\n      0,\n      false\n    ).signers.pop();\n    this.nsigner = ncreator.create(\n      void 0,\n      1,\n      MtrDex.Ed25519_Seed,\n      true,\n      0,\n      this.ridx + 1,\n      0,\n      false\n    ).signers.pop();\n    this.keys = [this.signer.verfer.qb64, signer?.verfer.qb64];\n    this.ndigs = [new Diger({}, this.nsigner.verfer.qb64b).qb64];\n    const rot = rotate({\n      pre: this.pre,\n      keys: this.keys,\n      dig: this.serder.ked[\"d\"],\n      isith: [\"1\", \"0\"],\n      nsith: \"1\",\n      ndigs: this.ndigs\n    });\n    const sigs = [\n      signer?.sign(b(rot.raw), 1, false, 0).qb64,\n      this.signer.sign(rot.raw, 0).qb64\n    ];\n    const encrypter = new Encrypter({}, b(nsigner.verfer.qb64));\n    const decrypter = new Decrypter({}, nsigner.qb64b);\n    const sxlt = encrypter.encrypt(b(this.bran)).qb64;\n    const keys = {};\n    for (const aid of aids) {\n      const pre = aid[\"prefix\"];\n      if (\"salty\" in aid) {\n        const salty = aid[\"salty\"];\n        const cipher = new Cipher({ qb64: salty[\"sxlt\"] });\n        const dnxt = decrypter.decrypt(null, cipher).qb64;\n        const acreator = new SaltyCreator(\n          dnxt,\n          salty[\"tier\"],\n          salty[\"stem\"]\n        );\n        const signers = acreator.create(\n          salty[\"icodes\"],\n          void 0,\n          MtrDex.Ed25519_Seed,\n          salty[\"transferable\"],\n          salty[\"pidx\"],\n          0,\n          salty[\"kidx\"],\n          false\n        );\n        const _signers = [];\n        for (const signer2 of signers.signers) {\n          _signers.push(signer2.verfer.qb64);\n        }\n        const pubs = aid[\"state\"][\"k\"];\n        if (pubs.join(\",\") != _signers.join(\",\")) {\n          throw new Error(\"Invalid Salty AID\");\n        }\n        const asxlt = encrypter.encrypt(b(dnxt)).qb64;\n        keys[pre] = {\n          sxlt: asxlt\n        };\n      } else if (\"randy\" in aid) {\n        const randy = aid[\"randy\"];\n        const prxs = randy[\"prxs\"];\n        const nxts = randy[\"nxts\"];\n        const nprxs = [];\n        const signers = [];\n        for (const prx of prxs) {\n          const cipher = new Cipher({ qb64: prx });\n          const dsigner = decrypter.decrypt(null, cipher, true);\n          signers.push(dsigner);\n          nprxs.push(encrypter.encrypt(b(dsigner.qb64)).qb64);\n        }\n        const pubs = aid[\"state\"][\"k\"];\n        const _signers = [];\n        for (const signer2 of signers) {\n          _signers.push(signer2.verfer.qb64);\n        }\n        if (pubs.join(\",\") != _signers.join(\",\")) {\n          throw new Error(\n            `unable to rotate, validation of encrypted public keys ${pubs} failed`\n          );\n        }\n        const nnxts = [];\n        for (const nxt of nxts) {\n          nnxts.push(this.recrypt(nxt, decrypter, encrypter));\n        }\n        keys[pre] = {\n          prxs: nprxs,\n          nxts: nnxts\n        };\n      } else {\n        throw new Error(\"invalid aid type \");\n      }\n    }\n    const data = {\n      rot: rot.ked,\n      sigs,\n      sxlt,\n      keys\n    };\n    return data;\n  }\n  recrypt(enc, decrypter, encrypter) {\n    const cipher = new Cipher({ qb64: enc });\n    const dnxt = decrypter.decrypt(null, cipher).qb64;\n    return encrypter.encrypt(b(dnxt)).qb64;\n  }\n};\n\n// src/keri/core/httping.ts\n\n\nvar HEADER_SIG_INPUT = normalize(\"Signature-Input\");\nvar HEADER_SIG_TIME = normalize(\"Signify-Timestamp\");\nfunction normalize(header) {\n  return header.trim();\n}\nfunction siginput(signer, {\n  name,\n  method,\n  path,\n  headers,\n  fields,\n  expires,\n  nonce,\n  alg,\n  keyid,\n  context\n}) {\n  const items = new Array();\n  const ifields = new Array();\n  fields.forEach((field) => {\n    if (field.startsWith(\"@\")) {\n      switch (field) {\n        case \"@method\":\n          items.push(`\"${field}\": ${method}`);\n          ifields.push([field, /* @__PURE__ */ new Map()]);\n          break;\n        case \"@path\":\n          items.push(`\"${field}\": ${path}`);\n          ifields.push([field, /* @__PURE__ */ new Map()]);\n          break;\n      }\n    } else {\n      if (!headers.has(field))\n        return;\n      ifields.push([field, /* @__PURE__ */ new Map()]);\n      const value = normalize(headers.get(field));\n      items.push(`\"${field}\": ${value}`);\n    }\n  });\n  const nameParams = /* @__PURE__ */ new Map();\n  const now = Math.floor(nowUTC().getTime() / 1e3);\n  nameParams.set(\"created\", now);\n  const values = [\n    `(${ifields.map((field) => field[0]).join(\" \")})`,\n    `created=${now}`\n  ];\n  if (expires != void 0) {\n    values.push(`expires=${expires}`);\n    nameParams.set(\"expires\", expires);\n  }\n  if (nonce != void 0) {\n    values.push(`nonce=${nonce}`);\n    nameParams.set(\"nonce\", nonce);\n  }\n  if (keyid != void 0) {\n    values.push(`keyid=${keyid}`);\n    nameParams.set(\"keyid\", keyid);\n  }\n  if (context != void 0) {\n    values.push(`context=${context}`);\n    nameParams.set(\"context\", context);\n  }\n  if (alg != void 0) {\n    values.push(`alg=${alg}`);\n    nameParams.set(\"alg\", alg);\n  }\n  const sid = /* @__PURE__ */ new Map([[name, [ifields, nameParams]]]);\n  const params = values.join(\";\");\n  items.push(`\"@signature-params: ${params}\"`);\n  const ser = items.join(\"\\n\");\n  const sig = signer.sign(b(ser));\n  return [\n    /* @__PURE__ */ new Map([\n      [HEADER_SIG_INPUT, `${(0,structured_headers__WEBPACK_IMPORTED_MODULE_5__.serializeDictionary)(sid)}`]\n    ]),\n    sig\n  ];\n}\nvar Unqualified = class {\n  _raw;\n  constructor(raw) {\n    this._raw = raw;\n  }\n  get qb64() {\n    return encodeBase64Url(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(this._raw));\n  }\n  get qb64b() {\n    return b(this.qb64);\n  }\n};\nvar Inputage = class {\n  name;\n  fields;\n  created;\n  expires;\n  nonce;\n  alg;\n  keyid;\n  context;\n};\nfunction desiginput(value) {\n  const sid = (0,structured_headers__WEBPACK_IMPORTED_MODULE_5__.parseDictionary)(value);\n  const siginputs = new Array();\n  sid.forEach((value2, key) => {\n    const siginput2 = new Inputage();\n    siginput2.name = key;\n    let list;\n    let params;\n    [list, params] = value2;\n    siginput2.fields = list.map((item) => item[0]);\n    if (!params.has(\"created\")) {\n      throw new Error(\n        \"missing required `created` field from signature input\"\n      );\n    }\n    siginput2.created = params.get(\"created\");\n    if (params.has(\"expires\")) {\n      siginput2.expires = params.get(\"expires\");\n    }\n    if (params.has(\"nonce\")) {\n      siginput2.nonce = params.get(\"nonce\");\n    }\n    if (params.has(\"alg\")) {\n      siginput2.alg = params.get(\"alg\");\n    }\n    if (params.has(\"keyid\")) {\n      siginput2.keyid = params.get(\"keyid\");\n    }\n    if (params.has(\"context\")) {\n      siginput2.context = params.get(\"context\");\n    }\n    siginputs.push(siginput2);\n  });\n  return siginputs;\n}\nfunction parseRangeHeaders(header, typ) {\n  if (header !== null) {\n    const data = header.replace(`${typ} `, \"\");\n    const values = data.split(\"/\");\n    const rng = values[0].split(\"-\");\n    return {\n      start: parseInt(rng[0]),\n      end: parseInt(rng[1]),\n      total: parseInt(values[1])\n    };\n  } else {\n    return { start: 0, end: 0, total: 0 };\n  }\n}\n\n// src/keri/app/aiding.ts\nvar Identifier = class {\n  client;\n  /**\n   * Identifier\n   * @param {IdentifierDeps} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * List managed identifiers\n   * @async\n   * @param {number} [start=0] Start index of list of notifications, defaults to 0\n   * @param {number} [end=24] End index of list of notifications, defaults to 24\n   * @returns {Promise<any>} A promise to the list of managed identifiers\n   */\n  async list(start = 0, end = 24) {\n    const extraHeaders = new Headers();\n    extraHeaders.append(\"Range\", `aids=${start}-${end}`);\n    const path = `/identifiers`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data, extraHeaders);\n    const cr = res.headers.get(\"content-range\");\n    const range2 = parseRangeHeaders(cr, \"aids\");\n    const aids = await res.json();\n    return {\n      start: range2.start,\n      end: range2.end,\n      total: range2.total,\n      aids\n    };\n  }\n  /**\n   * Get information for a managed identifier\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @returns {Promise<any>} A promise to the identifier information\n   */\n  async get(name) {\n    const path = `/identifiers/${encodeURIComponent(name)}`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Create a managed identifier\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {CreateIdentiferArgs} [kargs] Optional parameters to create the identifier\n   * @returns {EventResult} The inception result\n   */\n  async create(name, kargs = {}) {\n    const algo = kargs.algo == void 0 ? \"salty\" /* salty */ : kargs.algo;\n    const transferable = kargs.transferable ?? true;\n    const isith = kargs.isith ?? \"1\";\n    let nsith = kargs.nsith ?? \"1\";\n    let wits = kargs.wits ?? [];\n    const toad = kargs.toad ?? 0;\n    let dcode = kargs.dcode ?? MtrDex.Blake3_256;\n    const proxy = kargs.proxy;\n    const delpre = kargs.delpre;\n    const data = kargs.data != void 0 ? [kargs.data] : [];\n    const pre = kargs.pre;\n    const states = kargs.states;\n    const rstates = kargs.rstates;\n    const prxs = kargs.prxs;\n    const nxts = kargs.nxts;\n    const mhab = kargs.mhab;\n    const _keys = kargs.keys;\n    const _ndigs = kargs.ndigs;\n    const bran = kargs.bran;\n    const count = kargs.count;\n    let ncount = kargs.ncount;\n    const tier = kargs.tier;\n    const extern_type = kargs.extern_type;\n    const extern = kargs.extern;\n    if (!transferable) {\n      ncount = 0;\n      nsith = 0;\n      dcode = MtrDex.Ed25519N;\n    }\n    const xargs = {\n      transferable,\n      isith,\n      nsith,\n      wits,\n      toad,\n      proxy,\n      delpre,\n      dcode,\n      data,\n      algo,\n      pre,\n      prxs,\n      nxts,\n      mhab,\n      states,\n      rstates,\n      keys: _keys,\n      ndigs: _ndigs,\n      bran,\n      count,\n      ncount,\n      tier,\n      extern_type,\n      extern\n    };\n    const keeper = this.client.manager.new(algo, this.client.pidx, xargs);\n    const [keys, ndigs] = await keeper.incept(transferable);\n    wits = wits !== void 0 ? wits : [];\n    let serder = void 0;\n    if (delpre == void 0) {\n      serder = incept({\n        keys,\n        isith,\n        ndigs,\n        nsith,\n        toad,\n        wits,\n        cnfg: [],\n        data,\n        version: Versionage,\n        kind: \"JSON\" /* JSON */,\n        code: dcode,\n        intive: false\n      });\n    } else {\n      serder = incept({\n        keys,\n        isith,\n        ndigs,\n        nsith,\n        toad,\n        wits,\n        cnfg: [],\n        data,\n        version: Versionage,\n        kind: \"JSON\" /* JSON */,\n        code: dcode,\n        intive: false,\n        delpre\n      });\n    }\n    const sigs = await keeper.sign(b(serder.raw));\n    const jsondata = {\n      name,\n      icp: serder.ked,\n      sigs,\n      proxy,\n      smids: states != void 0 ? states.map((state) => state.i) : void 0,\n      rmids: rstates != void 0 ? rstates.map((state) => state.i) : void 0\n    };\n    jsondata[algo] = keeper.params();\n    this.client.pidx = this.client.pidx + 1;\n    const res = this.client.fetch(\"/identifiers\", \"POST\", jsondata);\n    return new EventResult(serder, sigs, res);\n  }\n  /**\n   * Generate an interaction event in a managed identifier\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {any} [data] Option data to be anchored in the interaction event\n   * @returns {Promise<EventResult>} A promise to the interaction event result\n   */\n  async interact(name, data) {\n    const hab = await this.get(name);\n    const pre = hab.prefix;\n    const state = hab.state;\n    const sn = parseInt(state.s, 16);\n    const dig = state.d;\n    data = Array.isArray(data) ? data : [data];\n    const serder = interact({\n      pre,\n      sn: sn + 1,\n      data,\n      dig,\n      version: void 0,\n      kind: void 0\n    });\n    const keeper = this.client.manager.get(hab);\n    const sigs = await keeper.sign(b(serder.raw));\n    const jsondata = {\n      ixn: serder.ked,\n      sigs\n    };\n    jsondata[keeper.algo] = keeper.params();\n    const res = await this.client.fetch(\n      \"/identifiers/\" + name + \"?type=ixn\",\n      \"PUT\",\n      jsondata\n    );\n    return new EventResult(serder, sigs, res);\n  }\n  /**\n   * Generate a rotation event in a managed identifier\n   * @param {string} name Name or alias of the identifier\n   * @param {RotateIdentifierArgs} [kargs] Optional parameters requiered to generate the rotation event\n   * @returns {Promise<EventResult>} A promise to the rotation event result\n   */\n  async rotate(name, kargs = {}) {\n    const transferable = kargs.transferable ?? true;\n    const ncode = kargs.ncode ?? MtrDex.Ed25519_Seed;\n    const ncount = kargs.ncount ?? 1;\n    const hab = await this.get(name);\n    const pre = hab.prefix;\n    const delegated = hab.state.di !== \"\";\n    const state = hab.state;\n    const count = state.k.length;\n    const dig = state.d;\n    const ridx = parseInt(state.s, 16) + 1;\n    const wits = state.b;\n    let isith = state.nt;\n    let nsith = kargs.nsith ?? isith;\n    if (isith == void 0)\n      isith = `${Math.max(1, Math.ceil(count / 2)).toString(16)}`;\n    if (nsith == void 0)\n      nsith = `${Math.max(1, Math.ceil(ncount / 2)).toString(16)}`;\n    const cst = new Tholder({ sith: isith }).sith;\n    const nst = new Tholder({ sith: nsith }).sith;\n    const keeper = this.client.manager.get(hab);\n    const ncodes = kargs.ncodes ?? new Array(ncount).fill(ncode);\n    const states = kargs.states == void 0 ? [] : kargs.states;\n    const rstates = kargs.rstates == void 0 ? [] : kargs.rstates;\n    const [keys, ndigs] = await keeper.rotate(\n      ncodes,\n      transferable,\n      states,\n      rstates\n    );\n    const cuts = kargs.cuts ?? [];\n    const adds = kargs.adds ?? [];\n    const data = kargs.data != void 0 ? [kargs.data] : [];\n    const toad = kargs.toad;\n    const ilk = delegated ? Ilks.drt : Ilks.rot;\n    const serder = rotate({\n      pre,\n      ilk,\n      keys,\n      dig,\n      sn: ridx,\n      isith: cst,\n      nsith: nst,\n      ndigs,\n      toad,\n      wits,\n      cuts,\n      adds,\n      data\n    });\n    const sigs = await keeper.sign(b(serder.raw));\n    const jsondata = {\n      rot: serder.ked,\n      sigs,\n      smids: states != void 0 ? states.map((state2) => state2.i) : void 0,\n      rmids: rstates != void 0 ? rstates.map((state2) => state2.i) : void 0\n    };\n    jsondata[keeper.algo] = keeper.params();\n    const res = await this.client.fetch(\n      \"/identifiers/\" + name,\n      \"PUT\",\n      jsondata\n    );\n    return new EventResult(serder, sigs, res);\n  }\n  /**\n   * Authorize an endpoint provider in a given role for a managed identifier\n   * @remarks\n   * Typically used to authorize the agent to be the endpoint provider for the identifier in the role of `agent`\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} role Authorized role for eid\n   * @param {string} [eid] Optional qb64 of endpoint provider to be authorized\n   * @param {string} [stamp=now] Optional date-time-stamp RFC-3339 profile of iso8601 datetime. Now is the default if not provided\n   * @returns {Promise<EventResult>} A promise to the result of the authorization\n   */\n  async addEndRole(name, role, eid, stamp) {\n    const hab = await this.get(name);\n    const pre = hab.prefix;\n    const rpy = this.makeEndRole(pre, role, eid, stamp);\n    const keeper = this.client.manager.get(hab);\n    const sigs = await keeper.sign(b(rpy.raw));\n    const jsondata = {\n      rpy: rpy.ked,\n      sigs\n    };\n    const res = this.client.fetch(\n      \"/identifiers/\" + name + \"/endroles\",\n      \"POST\",\n      jsondata\n    );\n    return new EventResult(rpy, sigs, res);\n  }\n  /**\n   * Generate an /end/role/add reply message\n   * @param {string} pre Prefix of the identifier\n   * @param {string} role Authorized role for eid\n   * @param {string} [eid] Optional qb64 of endpoint provider to be authorized\n   * @param {string} [stamp=now] Optional date-time-stamp RFC-3339 profile of iso8601 datetime. Now is the default if not provided\n   * @returns {Serder} The reply message\n   */\n  makeEndRole(pre, role, eid, stamp) {\n    const data = {\n      cid: pre,\n      role\n    };\n    if (eid != void 0) {\n      data.eid = eid;\n    }\n    const route = \"/end/role/add\";\n    return reply(route, data, stamp, void 0, \"JSON\" /* JSON */);\n  }\n  /**\n   * Get the members of a group identifier\n   * @async\n   * @param {string} name - Name or alias of the identifier\n   * @returns {Promise<any>} - A promise to the list of members\n   */\n  async members(name) {\n    const res = await this.client.fetch(\n      \"/identifiers/\" + name + \"/members\",\n      \"GET\",\n      void 0\n    );\n    return await res.json();\n  }\n};\nvar EventResult = class {\n  _serder;\n  _sigs;\n  promise;\n  constructor(serder, sigs, promise) {\n    this._serder = serder;\n    this._sigs = sigs;\n    this.promise = promise;\n  }\n  get serder() {\n    return this._serder;\n  }\n  get sigs() {\n    return this._sigs;\n  }\n  async op() {\n    const res = await this.promise;\n    return await res.json();\n  }\n};\n\n// src/keri/end/ending.ts\nvar FALSY = [false, 0, \"?0\", \"no\", \"false\", \"False\", \"off\"];\nvar TRUTHY = [true, 1, \"?1\", \"yes\", \"true\", \"True\", \"on\"];\nvar Signage = class {\n  constructor(markers, indexed, signer, ordinal, digest, kind) {\n    this.markers = markers;\n    this.indexed = indexed;\n    this.signer = signer;\n    this.ordinal = ordinal;\n    this.digest = digest;\n    this.kind = kind;\n  }\n  markers;\n  indexed = false;\n  signer;\n  ordinal;\n  digest;\n  kind;\n};\nfunction signature(signages) {\n  const values = new Array();\n  for (const signage of signages) {\n    let markers;\n    let indexed = signage.indexed;\n    const signer = signage.signer;\n    const ordinal = signage.ordinal;\n    const digest = signage.digest;\n    const kind = signage.kind;\n    let tags;\n    if (signage.markers instanceof Map) {\n      tags = Array.from(signage.markers.keys());\n      markers = Array.from(signage.markers.values());\n    } else {\n      markers = signage.markers;\n      tags = new Array();\n    }\n    if (indexed == void 0) {\n      indexed = markers[0] instanceof Siger;\n    }\n    const items = new Array();\n    const tag = \"indexed\";\n    let val = indexed ? \"?1\" : \"?0\";\n    items.push(`${tag}=\"${val}\"`);\n    if (signer != void 0) {\n      items.push(`signer=\"${signer}\"`);\n    }\n    if (ordinal != void 0) {\n      items.push(`ordinal=\"${ordinal}\"`);\n    }\n    if (digest != void 0) {\n      items.push(`digest=\"${digest}\"`);\n    }\n    if (kind != void 0) {\n      items.push(`kind=\"${kind}\"`);\n    }\n    markers.forEach((marker, idx) => {\n      let tag2;\n      if (tags != void 0 && tags.length > idx) {\n        tag2 = tags[idx];\n      } else if (marker instanceof Siger) {\n        if (!indexed)\n          throw new Error(\n            `Indexed signature marker ${marker} when indexed False.`\n          );\n        tag2 = marker.index.toString();\n      } else {\n        if (indexed)\n          throw new Error(\n            `Unindexed signature marker ${marker} when indexed True.`\n          );\n        tag2 = marker.verfer.qb64;\n      }\n      val = marker.qb64;\n      items.push(`${tag2}=\"${val}\"`);\n    });\n    values.push(items.join(\";\"));\n  }\n  return new Headers([[\"Signature\", values.join(\",\")]]);\n}\nfunction designature(value) {\n  const values = value.replace(\" \", \"\").split(\",\");\n  const signages = new Array();\n  values.forEach((val) => {\n    const dict = /* @__PURE__ */ new Map();\n    val.split(\";\").forEach((v) => {\n      const splits = v.split(\"=\", 2);\n      dict.set(splits[0], splits[1].replaceAll('\"', \"\"));\n    });\n    if (!dict.has(\"indexed\")) {\n      throw new Error(\n        \"Missing indexed field in Signature header signage.\"\n      );\n    }\n    const item = dict.get(\"indexed\");\n    const indexed = !FALSY.includes(item);\n    dict.delete(\"indexed\");\n    let signer;\n    if (dict.has(\"signer\")) {\n      signer = dict.get(\"signer\");\n      dict.delete(\"signer\");\n    }\n    let ordinal;\n    if (dict.has(\"ordinal\")) {\n      ordinal = dict.get(\"ordinal\");\n      dict.delete(\"ordinal\");\n    }\n    let digest;\n    if (dict.has(\"digest\")) {\n      digest = dict.get(\"digest\");\n      dict.delete(\"digest\");\n    }\n    let kind;\n    if (dict.has(\"kind\")) {\n      kind = dict.get(\"kind\");\n      dict.delete(\"kind\");\n    } else {\n      kind = \"CESR\";\n    }\n    let markers;\n    if (kind == \"CESR\") {\n      markers = /* @__PURE__ */ new Map();\n      dict.forEach((val2, key) => {\n        if (indexed) {\n          markers.set(key, new Siger({ qb64: val2 }));\n        } else {\n          markers.set(key, new Cigar({ qb64: val2 }));\n        }\n      });\n    } else {\n      markers = dict;\n    }\n    signages.push(\n      new Signage(markers, indexed, signer, ordinal, digest, kind)\n    );\n  });\n  return signages;\n}\n\n// src/keri/core/authing.ts\nvar Authenticater = class _Authenticater {\n  static DefaultFields = [\n    \"@method\",\n    \"@path\",\n    \"signify-resource\",\n    HEADER_SIG_TIME.toLowerCase()\n  ];\n  _verfer;\n  _csig;\n  constructor(csig, verfer) {\n    this._csig = csig;\n    this._verfer = verfer;\n  }\n  verify(headers, method, path) {\n    const siginput2 = headers.get(HEADER_SIG_INPUT);\n    if (siginput2 == null) {\n      return false;\n    }\n    const signature2 = headers.get(\"Signature\");\n    if (signature2 == null) {\n      return false;\n    }\n    let inputs = desiginput(siginput2);\n    inputs = inputs.filter((input) => input.name == \"signify\");\n    if (inputs.length == 0) {\n      return false;\n    }\n    inputs.forEach((input) => {\n      const items = new Array();\n      input.fields.forEach((field) => {\n        if (field.startsWith(\"@\")) {\n          if (field == \"@method\") {\n            items.push(`\"${field}\": ${method}`);\n          } else if (field == \"@path\") {\n            items.push(`\"${field}\": ${path}`);\n          }\n        } else {\n          if (headers.has(field)) {\n            const value = normalize(headers.get(field));\n            items.push(`\"${field}\": ${value}`);\n          }\n        }\n      });\n      const values = new Array();\n      values.push(`(${input.fields.join(\" \")})`);\n      values.push(`created=${input.created}`);\n      if (input.expires != void 0) {\n        values.push(`expires=${input.expires}`);\n      }\n      if (input.nonce != void 0) {\n        values.push(`nonce=${input.nonce}`);\n      }\n      if (input.keyid != void 0) {\n        values.push(`keyid=${input.keyid}`);\n      }\n      if (input.context != void 0) {\n        values.push(`context=${input.context}`);\n      }\n      if (input.alg != void 0) {\n        values.push(`alg=${input.alg}`);\n      }\n      const params = values.join(\";\");\n      items.push(`\"@signature-params: ${params}\"`);\n      const ser = items.join(\"\\n\");\n      const signage = designature(signature2);\n      const cig = signage[0].markers.get(input.name);\n      if (!this._verfer.verify(cig.raw, ser)) {\n        throw new Error(`Signature for ${input.keyid} invalid.`);\n      }\n    });\n    return true;\n  }\n  sign(headers, method, path, fields) {\n    if (fields == void 0) {\n      fields = _Authenticater.DefaultFields;\n    }\n    const [header, sig] = siginput(this._csig, {\n      name: \"signify\",\n      method,\n      path,\n      headers,\n      fields,\n      alg: \"ed25519\",\n      keyid: this._csig.verfer.qb64\n    });\n    header.forEach((value, key) => {\n      headers.append(key, value);\n    });\n    const markers = /* @__PURE__ */ new Map();\n    markers.set(\"signify\", sig);\n    const signage = new Signage(markers, false);\n    const signed = signature([signage]);\n    signed.forEach((value, key) => {\n      headers.append(key, value);\n    });\n    return headers;\n  }\n};\n\n// src/keri/core/keeping.ts\nvar KeyManager = class {\n  constructor(salter, externalModules = []) {\n    this.salter = salter;\n    this.salter = salter;\n    for (const mod of externalModules) {\n      this.modules[mod.type] = mod.module;\n    }\n  }\n  modules = {};\n  new(algo, pidx, kargs) {\n    switch (algo) {\n      case \"salty\" /* salty */:\n        return new SaltyKeeper(\n          this.salter,\n          pidx,\n          kargs[\"kidx\"],\n          kargs[\"tier\"],\n          kargs[\"transferable\"],\n          kargs[\"stem\"],\n          kargs[\"code\"],\n          kargs[\"count\"],\n          kargs[\"icodes\"],\n          kargs[\"ncode\"],\n          kargs[\"ncount\"],\n          kargs[\"ncodes\"],\n          kargs[\"dcode\"],\n          kargs[\"bran\"],\n          kargs[\"sxlt\"]\n        );\n      case \"randy\" /* randy */:\n        return new RandyKeeper(\n          this.salter,\n          kargs[\"code\"],\n          kargs[\"count\"],\n          kargs[\"icodes\"],\n          kargs[\"transferable\"],\n          kargs[\"ncode\"],\n          kargs[\"ncount\"],\n          kargs[\"ncodes\"],\n          kargs[\"dcode\"],\n          kargs[\"prxs\"],\n          kargs[\"nxts\"]\n        );\n      case \"group\" /* group */:\n        return new GroupKeeper(\n          this,\n          kargs[\"mhab\"],\n          kargs[\"states\"],\n          kargs[\"rstates\"],\n          kargs[\"keys\"],\n          kargs[\"ndigs\"]\n        );\n      case \"extern\" /* extern */: {\n        const ModuleConstructor = this.modules[kargs.extern_type];\n        if (!ModuleConstructor) {\n          throw new Error(\n            `unsupported external module type ${kargs.extern_type}`\n          );\n        }\n        return new ModuleConstructor(pidx, kargs);\n      }\n      default:\n        throw new Error(\"Unknown algo\");\n    }\n  }\n  get(aid) {\n    if (aid[\"salty\" /* salty */]) {\n      const kargs = aid[\"salty\" /* salty */];\n      return new SaltyKeeper(\n        this.salter,\n        kargs[\"pidx\"],\n        kargs[\"kidx\"],\n        kargs[\"tier\"],\n        kargs[\"transferable\"],\n        kargs[\"stem\"],\n        void 0,\n        void 0,\n        kargs[\"icodes\"],\n        void 0,\n        void 0,\n        kargs[\"ncodes\"],\n        kargs[\"dcode\"],\n        void 0,\n        kargs[\"sxlt\"]\n      );\n    } else if (aid[\"randy\" /* randy */]) {\n      const pre = new Prefixer({ qb64: aid[\"prefix\"] });\n      const kargs = aid[\"randy\" /* randy */];\n      return new RandyKeeper(\n        this.salter,\n        void 0,\n        void 0,\n        void 0,\n        pre.transferable,\n        void 0,\n        void 0,\n        [],\n        void 0,\n        kargs[\"prxs\"],\n        kargs[\"nxts\"]\n      );\n    } else if (aid[\"group\" /* group */]) {\n      const kargs = aid[\"group\" /* group */];\n      return new GroupKeeper(\n        this,\n        kargs[\"mhab\"],\n        void 0,\n        void 0,\n        kargs[\"keys\"],\n        kargs[\"ndigs\"]\n      );\n    } else if (aid[\"extern\" /* extern */]) {\n      const kargs = aid[\"extern\" /* extern */];\n      const typ = kargs.extern_type;\n      if (typ in this.modules) {\n        const mod = new this.modules[typ](kargs[\"pidx\"], kargs);\n        return mod;\n      } else {\n        throw new Error(`unsupported external module type ${typ}`);\n      }\n    } else {\n      throw new Error(`Algo not allowed yet`);\n    }\n  }\n};\nvar SaltyKeeper = class {\n  aeid;\n  encrypter;\n  decrypter;\n  salter;\n  pidx;\n  kidx;\n  tier;\n  transferable;\n  stem;\n  code;\n  count;\n  icodes;\n  ncode;\n  ncount;\n  ncodes;\n  dcode;\n  sxlt;\n  bran;\n  creator;\n  algo = \"salty\" /* salty */;\n  signers;\n  constructor(salter, pidx, kidx = 0, tier = \"low\" /* low */, transferable = false, stem = void 0, code = MtrDex.Ed25519_Seed, count = 1, icodes = void 0, ncode = MtrDex.Ed25519_Seed, ncount = 1, ncodes = void 0, dcode = MtrDex.Blake3_256, bran = void 0, sxlt = void 0) {\n    this.salter = salter;\n    const signer = this.salter.signer(void 0, transferable = false);\n    this.aeid = signer.verfer.qb64;\n    this.encrypter = new Encrypter({}, b(this.aeid));\n    this.decrypter = new Decrypter({}, signer.qb64b);\n    this.code = code;\n    this.ncode = ncode;\n    this.tier = tier;\n    this.icodes = icodes == void 0 ? new Array(count).fill(code) : icodes;\n    this.ncodes = ncodes == void 0 ? new Array(ncount).fill(ncode) : ncodes;\n    this.dcode = dcode;\n    this.pidx = pidx;\n    this.kidx = kidx;\n    this.transferable = transferable;\n    this.count = count;\n    this.ncount = ncount;\n    this.stem = stem == void 0 ? \"signify:aid\" : stem;\n    if (bran != void 0) {\n      this.bran = MtrDex.Salt_128 + \"A\" + bran.slice(0, 21);\n      this.creator = new SaltyCreator(this.bran, this.tier, this.stem);\n      this.sxlt = this.encrypter.encrypt(b(this.creator.salt)).qb64;\n    } else if (sxlt == void 0) {\n      this.creator = new SaltyCreator(void 0, this.tier, this.stem);\n      this.sxlt = this.encrypter.encrypt(b(this.creator.salt)).qb64;\n    } else {\n      this.sxlt = sxlt;\n      const ciph = new Cipher({ qb64: this.sxlt });\n      this.creator = new SaltyCreator(\n        this.decrypter.decrypt(null, ciph).qb64,\n        tier,\n        this.stem\n      );\n    }\n    this.signers = this.creator.create(\n      this.icodes,\n      this.ncount,\n      this.ncode,\n      this.transferable,\n      this.pidx,\n      0,\n      this.kidx,\n      false\n    ).signers;\n  }\n  params() {\n    return {\n      sxlt: this.sxlt,\n      pidx: this.pidx,\n      kidx: this.kidx,\n      stem: this.stem,\n      tier: this.tier,\n      icodes: this.icodes,\n      ncodes: this.ncodes,\n      dcode: this.dcode,\n      transferable: this.transferable\n    };\n  }\n  async incept(transferable) {\n    this.transferable = transferable;\n    this.kidx = 0;\n    const signers = this.creator.create(\n      this.icodes,\n      this.count,\n      this.code,\n      this.transferable,\n      this.pidx,\n      0,\n      this.kidx,\n      false\n    );\n    const verfers = signers.signers.map((signer) => signer.verfer.qb64);\n    const nsigners = this.creator.create(\n      this.ncodes,\n      this.ncount,\n      this.ncode,\n      this.transferable,\n      this.pidx,\n      0,\n      this.icodes?.length,\n      false\n    );\n    const digers = nsigners.signers.map(\n      (nsigner) => new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n    );\n    return [verfers, digers];\n  }\n  async rotate(ncodes, transferable) {\n    this.ncodes = ncodes;\n    this.transferable = transferable;\n    const signers = this.creator.create(\n      this.ncodes,\n      this.ncount,\n      this.ncode,\n      this.transferable,\n      this.pidx,\n      0,\n      this.kidx + this.icodes.length,\n      false\n    );\n    const verfers = signers.signers.map((signer) => signer.verfer.qb64);\n    this.kidx = this.kidx + this.icodes.length;\n    const nsigners = this.creator.create(\n      this.ncodes,\n      this.ncount,\n      this.ncode,\n      this.transferable,\n      this.pidx,\n      0,\n      this.kidx + this.icodes.length,\n      false\n    );\n    const digers = nsigners.signers.map(\n      (nsigner) => new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n    );\n    return [verfers, digers];\n  }\n  async sign(ser, indexed = true, indices = void 0, ondices = void 0) {\n    const signers = this.creator.create(\n      this.icodes,\n      this.ncount,\n      this.ncode,\n      this.transferable,\n      this.pidx,\n      0,\n      this.kidx,\n      false\n    );\n    if (indexed) {\n      const sigers = [];\n      let i = 0;\n      for (const [j, signer] of signers.signers.entries()) {\n        if (indices != void 0) {\n          i = indices[j];\n          if (typeof i != \"number\" || i < 0) {\n            throw new Error(\n              `Invalid signing index = ${i}, not whole number.`\n            );\n          }\n        } else {\n          i = j;\n        }\n        let o = 0;\n        if (ondices != void 0) {\n          o = ondices[j];\n          if (o == void 0 || typeof o == \"number\" && typeof o != \"number\" && o >= 0) {\n            throw new Error(\n              `Invalid ondex = ${o}, not whole number.`\n            );\n          }\n        } else {\n          o = i;\n        }\n        sigers.push(\n          signer.sign(ser, i, o == void 0 ? true : false, o)\n        );\n      }\n      return sigers.map((siger) => siger.qb64);\n    } else {\n      const cigars = [];\n      for (const [, signer] of signers.signers.entries()) {\n        cigars.push(signer.sign(ser));\n      }\n      return cigars.map((cigar) => cigar.qb64);\n    }\n  }\n};\nvar RandyKeeper = class {\n  salter;\n  code;\n  count;\n  icodes;\n  transferable;\n  ncount;\n  ncodes;\n  ncode;\n  dcode;\n  prxs;\n  nxts;\n  aeid;\n  encrypter;\n  decrypter;\n  creator;\n  algo = \"randy\" /* randy */;\n  signers;\n  constructor(salter, code = MtrDex.Ed25519_Seed, count = 1, icodes = void 0, transferable = false, ncode = MtrDex.Ed25519_Seed, ncount = 1, ncodes, dcode = MtrDex.Blake3_256, prxs = void 0, nxts = void 0) {\n    this.salter = salter;\n    this.icodes = icodes == void 0 ? new Array(count).fill(code) : icodes;\n    this.ncodes = ncodes == void 0 ? new Array(ncount).fill(ncode) : ncodes;\n    this.code = code;\n    this.ncode = ncode;\n    this.count = count;\n    this.ncount = ncount;\n    const signer = this.salter.signer(void 0, transferable = false);\n    this.aeid = signer.verfer.qb64;\n    this.encrypter = new Encrypter({}, b(this.aeid));\n    this.decrypter = new Decrypter({}, signer.qb64b);\n    this.nxts = nxts ?? [];\n    this.prxs = prxs ?? [];\n    this.transferable = transferable;\n    this.icodes = icodes;\n    this.ncodes = ncodes;\n    this.dcode = dcode;\n    this.creator = new RandyCreator();\n    this.signers = this.prxs.map(\n      (prx) => this.decrypter.decrypt(\n        new Cipher({ qb64: prx }).qb64b,\n        void 0,\n        this.transferable\n      )\n    );\n  }\n  params() {\n    return {\n      nxts: this.nxts,\n      prxs: this.prxs,\n      transferable: this.transferable\n    };\n  }\n  async incept(transferable) {\n    this.transferable = transferable;\n    const signers = this.creator.create(\n      this.icodes,\n      this.count,\n      this.code,\n      this.transferable\n    );\n    this.prxs = signers.signers.map(\n      (signer) => this.encrypter.encrypt(void 0, signer).qb64\n    );\n    const verfers = signers.signers.map((signer) => signer.verfer.qb64);\n    const nsigners = this.creator.create(\n      this.ncodes,\n      this.ncount,\n      this.ncode,\n      this.transferable\n    );\n    this.nxts = nsigners.signers.map(\n      (signer) => this.encrypter.encrypt(void 0, signer).qb64\n    );\n    const digers = nsigners.signers.map(\n      (nsigner) => new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n    );\n    return [verfers, digers];\n  }\n  async rotate(ncodes, transferable) {\n    this.ncodes = ncodes;\n    this.transferable = transferable;\n    this.prxs = this.nxts;\n    const signers = this.nxts.map(\n      (nxt) => this.decrypter.decrypt(\n        void 0,\n        new Cipher({ qb64: nxt }),\n        this.transferable\n      )\n    );\n    const verfers = signers.map((signer) => signer.verfer.qb64);\n    const nsigners = this.creator.create(\n      this.ncodes,\n      this.ncount,\n      this.ncode,\n      this.transferable\n    );\n    this.nxts = nsigners.signers.map(\n      (signer) => this.encrypter.encrypt(void 0, signer).qb64\n    );\n    const digers = nsigners.signers.map(\n      (nsigner) => new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n    );\n    return [verfers, digers];\n  }\n  async sign(ser, indexed = true, indices = void 0, ondices = void 0) {\n    const signers = this.prxs.map(\n      (prx) => this.decrypter.decrypt(\n        new Cipher({ qb64: prx }).qb64b,\n        void 0,\n        this.transferable\n      )\n    );\n    if (indexed) {\n      const sigers = [];\n      let i = 0;\n      for (const [j, signer] of signers.entries()) {\n        if (indices != void 0) {\n          i = indices[j];\n          if (typeof i != \"number\" || i < 0) {\n            throw new Error(\n              `Invalid signing index = ${i}, not whole number.`\n            );\n          }\n        } else {\n          i = j;\n        }\n        let o = 0;\n        if (ondices != void 0) {\n          o = ondices[j];\n          if (o == void 0 || typeof o == \"number\" && typeof o != \"number\" && o >= 0) {\n            throw new Error(\n              `Invalid ondex = ${o}, not whole number.`\n            );\n          }\n        } else {\n          o = i;\n        }\n        sigers.push(\n          signer.sign(ser, i, o == void 0 ? true : false, o)\n        );\n      }\n      return sigers.map((siger) => siger.qb64);\n    } else {\n      const cigars = [];\n      for (const [, signer] of signers.entries()) {\n        cigars.push(signer.sign(ser));\n      }\n      return cigars.map((cigar) => cigar.qb64);\n    }\n  }\n};\nvar GroupKeeper = class {\n  manager;\n  mhab;\n  gkeys = [];\n  gdigs = [];\n  algo = \"group\" /* group */;\n  signers;\n  constructor(manager, mhab, states = void 0, rstates = void 0, keys = [], ndigs = []) {\n    this.manager = manager;\n    if (states != void 0) {\n      keys = states.map((state) => state[\"k\"][0]);\n    }\n    if (rstates != void 0) {\n      ndigs = rstates.map((state) => state[\"n\"][0]);\n    }\n    this.gkeys = states?.map((state) => state[\"k\"][0]) ?? keys;\n    this.gdigs = rstates?.map((state) => state[\"n\"][0]) ?? ndigs;\n    this.mhab = mhab;\n    this.signers = [];\n  }\n  async incept() {\n    return [this.gkeys, this.gdigs];\n  }\n  async rotate(_ncodes, _transferable, states, rstates) {\n    this.gkeys = states.map((state) => state[\"k\"][0]);\n    this.gdigs = rstates.map((state) => state[\"n\"][0]);\n    return [this.gkeys, this.gdigs];\n  }\n  async sign(ser, indexed = true) {\n    if (!this.mhab.state) {\n      throw new Error(`No state in mhab`);\n    }\n    const key = this.mhab[\"state\"][\"k\"][0];\n    const ndig = this.mhab[\"state\"][\"n\"][0];\n    const csi = this.gkeys.indexOf(key);\n    const pni = this.gdigs.indexOf(ndig);\n    const mkeeper = this.manager.get(this.mhab);\n    return await mkeeper.sign(ser, indexed, [csi], [pni]);\n  }\n  params() {\n    return {\n      mhab: this.mhab,\n      keys: this.gkeys,\n      ndigs: this.gdigs\n    };\n  }\n};\n\n// src/keri/app/contacting.ts\nvar Contacts = class {\n  client;\n  /**\n   * Contacts\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * List contacts\n   * @async\n   * @param {string} [group] Optional group name to filter contacts\n   * @param {string} [filterField] Optional field name to filter contacts\n   * @param {string} [filterValue] Optional field value to filter contacts\n   * @returns {Promise<any>} A promise to the list of contacts\n   */\n  async list(group, filterField, filterValue) {\n    const params = new URLSearchParams();\n    if (group !== void 0) {\n      params.append(\"group\", group);\n    }\n    if (filterField !== void 0 && filterValue !== void 0) {\n      params.append(\"filter_field\", filterField);\n      params.append(\"filter_value\", filterValue);\n    }\n    const path = `/contacts?` + params.toString();\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * Get a contact\n   * @async\n   * @param {string} pre Prefix of the contact\n   * @returns {Promise<any>} A promise to the contact\n   */\n  async get(pre) {\n    const path = `/contacts/` + pre;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * Add a contact\n   * @async\n   * @param {string} pre Prefix of the contact\n   * @param {any} info Information about the contact\n   * @returns {Promise<any>} A promise to the result of the addition\n   */\n  async add(pre, info) {\n    const path = `/contacts/` + pre;\n    const method = \"POST\";\n    const res = await this.client.fetch(path, method, info);\n    return await res.json();\n  }\n  /**\n   * Delete a contact\n   * @async\n   * @param {string} pre Prefix of the contact\n   * @returns {Promise<void>}\n   */\n  async delete(pre) {\n    const path = `/contacts/` + pre;\n    const method = \"DELETE\";\n    await this.client.fetch(path, method, null);\n  }\n  /**\n   * Update a contact\n   * @async\n   * @param {string} pre Prefix of the contact\n   * @param {any} info Updated information about the contact\n   * @returns {Promise<any>} A promise to the result of the update\n   */\n  async update(pre, info) {\n    const path = `/contacts/` + pre;\n    const method = \"PUT\";\n    const res = await this.client.fetch(path, method, info);\n    return await res.json();\n  }\n};\nvar Challenges = class {\n  client;\n  /**\n   * Challenges\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Generate a random challenge word list based on BIP39\n   * @async\n   * @param {number} strength Integer representing the strength of the challenge. Typically 128 or 256\n   * @returns {Promise<any>} A promise to the list of random words\n   */\n  async generate(strength = 128) {\n    const path = `/challenges?strength=${strength.toString()}`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * Respond to a challenge by signing a message with the list of words\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} recipient Prefix of the recipient of the response\n   * @param {Array<string>} words List of words to embed in the signed response\n   * @returns {Promise<Response>} A promise to the result of the response\n   */\n  async respond(name, recipient, words) {\n    const hab = await this.client.identifiers().get(name);\n    const exchanges = this.client.exchanges();\n    const resp = await exchanges.send(\n      name,\n      \"challenge\",\n      hab,\n      \"/challenge/response\",\n      { words },\n      {},\n      [recipient]\n    );\n    return resp;\n  }\n  /**\n   * Ask Agent to verify a given sender signed the provided words\n   * @param {string} source Prefix of the identifier that was challenged\n   * @param {Array<string>} words List of challenge words to check for\n   * @returns A promise to the long running operation\n   */\n  async verify(source, words) {\n    const path = `/challenges_verify/${source}`;\n    const method = \"POST\";\n    const data = {\n      words\n    };\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Mark challenge response as signed and accepted\n   * @param {string} source Prefix of the identifier that was challenged\n   * @param {string} said qb64 AID of exn message representing the signed response\n   * @returns {Promise<Response>} A promise to the result\n   */\n  async responded(source, said) {\n    const path = `/challenges_verify/${source}`;\n    const method = \"PUT\";\n    const data = {\n      said\n    };\n    const res = await this.client.fetch(path, method, data);\n    return res;\n  }\n};\n\n// src/keri/app/coring.ts\n\nfunction randomPasscode() {\n  const raw = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.randombytes_buf(16);\n  const salter = new Salter({ raw });\n  return salter.qb64.substring(2, 23);\n}\nfunction randomNonce() {\n  const seed = libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.randombytes_buf(libsodium_wrappers_sumo__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_SEEDBYTES);\n  const seedqb64 = new Matter({ raw: seed, code: MtrDex.Ed25519_Seed });\n  return seedqb64.qb64;\n}\nvar Oobis = class {\n  client;\n  /**\n   * Oobis\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Get the OOBI(s) for a managed indentifier for a given role\n   * @param {string} name Name or alias of the identifier\n   * @param {string} role Authorized role\n   * @returns {Promise<any>} A promise to the OOBI(s)\n   */\n  async get(name, role = \"agent\") {\n    const path = `/identifiers/${name}/oobis?role=${role}`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * Resolve an OOBI\n   * @async\n   * @param {string} oobi The OOBI to be resolver\n   * @param {string} [alias] Optional name or alias to link the OOBI resolution to a contact\n   * @returns {Promise<any>} A promise to the long-running operation\n   */\n  async resolve(oobi, alias) {\n    const path = `/oobis`;\n    const data = {\n      url: oobi\n    };\n    if (alias !== void 0) {\n      data.oobialias = alias;\n    }\n    const method = \"POST\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n};\nvar Operations = class {\n  client;\n  /**\n   * Operations\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Get operation status\n   * @async\n   * @param {string} name Name of the operation\n   * @returns {Promise<Operation>} A promise to the status of the operation\n   */\n  async get(name) {\n    const path = `/operations/${name}`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * List operations\n   * @async\n   * @param {string} type Select operations by type\n   * @returns {Promise<Operation[]>} A list of operations\n   */\n  async list(type) {\n    const params = new URLSearchParams();\n    if (type !== void 0) {\n      params.append(\"type\", type);\n    }\n    const path = `/operations?${params.toString()}`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Delete operation\n   * @async\n   * @param {string} name Name of the operation\n   */\n  async delete(name) {\n    const path = `/operations/${name}`;\n    const data = null;\n    const method = \"DELETE\";\n    await this.client.fetch(path, method, data);\n  }\n  /**\n   * Poll for operation to become completed.\n   */\n  async wait(op, options = {}) {\n    const minSleep = options.minSleep ?? 10;\n    const maxSleep = options.maxSleep ?? 1e4;\n    const increaseFactor = options.increaseFactor ?? 50;\n    if (op.metadata?.depends?.done === false) {\n      await this.wait(op.metadata.depends, options);\n    }\n    if (op.done === true) {\n      return op;\n    }\n    let retries = 0;\n    while (true) {\n      op = await this.get(op.name);\n      const delay = Math.max(\n        minSleep,\n        Math.min(maxSleep, 2 ** retries * increaseFactor)\n      );\n      retries++;\n      if (op.done === true) {\n        return op;\n      }\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      options.signal?.throwIfAborted();\n    }\n  }\n};\nvar KeyEvents = class {\n  client;\n  /**\n   * KeyEvents\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Retrieve key events for an identifier\n   * @async\n   * @param {string} pre Identifier prefix\n   * @returns {Promise<any>} A promise to the key events\n   */\n  async get(pre) {\n    const path = `/events?pre=${pre}`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n};\nvar KeyStates = class {\n  client;\n  /**\n   * KeyStates\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Retriene the key state for an identifier\n   * @async\n   * @param {string} pre Identifier prefix\n   * @returns {Promise<any>} A promise to the key states\n   */\n  async get(pre) {\n    const path = `/states?pre=${pre}`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Retrieve the key state for a list of identifiers\n   * @async\n   * @param {Array<string>} pres List of identifier prefixes\n   * @returns {Promise<any>} A promise to the key states\n   */\n  async list(pres) {\n    const path = `/states?${pres.map((pre) => `pre=${pre}`).join(\"&\")}`;\n    const data = null;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Query the key state of an identifier for a given sequence number or anchor\n   * @async\n   * @param {string} pre Identifier prefix\n   * @param {number} [sn] Optional sequence number\n   * @param {any} [anchor] Optional anchor\n   * @returns {Promise<any>} A promise to the long-running operation\n   */\n  async query(pre, sn, anchor) {\n    const path = `/queries`;\n    const data = {\n      pre\n    };\n    if (sn !== void 0) {\n      data.sn = sn;\n    }\n    if (anchor !== void 0) {\n      data.anchor = anchor;\n    }\n    const method = \"POST\";\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n};\n\n// src/keri/core/vdring.ts\nvar vdr;\n((vdr2) => {\n  function incept2({\n    pre,\n    toad,\n    nonce = randomNonce(),\n    baks = [],\n    cnfg = [],\n    version = Versionage,\n    kind = \"JSON\" /* JSON */,\n    code = MtrDex.Blake3_256\n  }) {\n    const vs = versify(\"KERI\" /* KERI */, version, kind, 0);\n    const isn = 0;\n    const ilk = Ilks.vcp;\n    if (cnfg.includes(TraitDex.NoBackers) && baks.length > 0) {\n      throw new Error(\n        `${baks.length} backers specified for NB vcp, 0 allowed`\n      );\n    }\n    if (new Set(baks).size < baks.length) {\n      throw new Error(`Invalid baks ${baks} has duplicates`);\n    }\n    let _toad;\n    if (toad === void 0) {\n      if (baks.length === 0) {\n        _toad = 0;\n      } else {\n        _toad = ample(baks.length);\n      }\n    } else {\n      _toad = +toad;\n    }\n    if (baks.length > 0) {\n      if (_toad < 1 || _toad > baks.length) {\n        throw new Error(`Invalid toad ${_toad} for baks in ${baks}`);\n      }\n    } else {\n      if (_toad != 0) {\n        throw new Error(`Invalid toad ${_toad} for no baks`);\n      }\n    }\n    const ked = {\n      v: vs,\n      t: ilk,\n      d: \"\",\n      i: \"\",\n      ii: pre,\n      s: \"\" + isn,\n      c: cnfg,\n      bt: _toad.toString(16),\n      b: baks,\n      n: nonce\n    };\n    const prefixer = new Prefixer({ code }, ked);\n    ked.i = prefixer.qb64;\n    ked.d = prefixer.qb64;\n    return new Serder(ked);\n  }\n  vdr2.incept = incept2;\n})(vdr || (vdr = {}));\n\n// src/keri/app/credentialing.ts\nvar CredentialTypes = class {\n  static issued = \"issued\";\n  static received = \"received\";\n};\nvar Credentials = class {\n  client;\n  /**\n   * Credentials\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * List credentials\n   * @async\n   * @param {CredentialFilter} [kargs] Optional parameters to filter the credentials\n   * @returns {Promise<any>} A promise to the list of credentials\n   */\n  async list(kargs = {}) {\n    const path = `/credentials/query`;\n    const filtr = kargs.filter === void 0 ? {} : kargs.filter;\n    const sort = kargs.sort === void 0 ? [] : kargs.sort;\n    const limit = kargs.limit === void 0 ? 25 : kargs.limit;\n    const skip = kargs.skip === void 0 ? 0 : kargs.skip;\n    const data = {\n      filter: filtr,\n      sort,\n      skip,\n      limit\n    };\n    const method = \"POST\";\n    const res = await this.client.fetch(path, method, data, void 0);\n    return await res.json();\n  }\n  /**\n   * Get a credential\n   * @async\n   * @param {string} said - SAID of the credential\n   * @param {boolean} [includeCESR=false] - Optional flag export the credential in CESR format\n   * @returns {Promise<any>} A promise to the credential\n   */\n  async get(said, includeCESR = false) {\n    const path = `/credentials/${said}`;\n    const method = \"GET\";\n    const headers = includeCESR ? new Headers({ Accept: \"application/json+cesr\" }) : new Headers({ Accept: \"application/json\" });\n    const res = await this.client.fetch(path, method, null, headers);\n    return includeCESR ? await res.text() : await res.json();\n  }\n  /**\n   * Issue a credential\n   */\n  async issue(name, args) {\n    const hab = await this.client.identifiers().get(name);\n    const estOnly = hab.state.c !== void 0 && hab.state.c.includes(\"EO\");\n    if (estOnly) {\n      throw new Error(\"Establishment only not implemented\");\n    }\n    if (!this.client.manager) {\n      throw new Error(\"No manager on client\");\n    }\n    const keeper = this.client.manager.get(hab);\n    const [, subject] = Saider.saidify({\n      d: \"\",\n      ...args.a,\n      dt: args.a.dt ?? (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\")\n    });\n    const [, acdc] = Saider.saidify({\n      v: versify(\"ACDC\" /* ACDC */, void 0, \"JSON\" /* JSON */, 0),\n      d: \"\",\n      u: args.u,\n      i: args.i ?? hab.prefix,\n      ri: args.ri,\n      s: args.s,\n      a: subject,\n      e: args.e,\n      r: args.r\n    });\n    const [, iss] = Saider.saidify({\n      v: versify(\"KERI\" /* KERI */, void 0, \"JSON\" /* JSON */, 0),\n      t: Ilks.iss,\n      d: \"\",\n      i: acdc.d,\n      s: \"0\",\n      ri: args.ri,\n      dt: subject.dt\n    });\n    const sn = parseInt(hab.state.s, 16);\n    const anc = interact({\n      pre: hab.prefix,\n      sn: sn + 1,\n      data: [\n        {\n          i: iss.i,\n          s: iss.s,\n          d: iss.d\n        }\n      ],\n      dig: hab.state.d,\n      version: void 0,\n      kind: void 0\n    });\n    const sigs = await keeper.sign(b(anc.raw));\n    const path = `/identifiers/${hab.name}/credentials`;\n    const method = \"POST\";\n    const body = {\n      acdc,\n      iss,\n      ixn: anc.ked,\n      sigs,\n      [keeper.algo]: keeper.params()\n    };\n    const headers = new Headers({\n      Accept: \"application/json+cesr\"\n    });\n    const res = await this.client.fetch(path, method, body, headers);\n    const op = await res.json();\n    return {\n      acdc: new Serder(acdc),\n      iss: new Serder(iss),\n      anc,\n      op\n    };\n  }\n  /**\n   * Revoke credential\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} said SAID of the credential\n   * @param {string} datetime date time of revocation\n   * @returns {Promise<any>} A promise to the long-running operation\n   */\n  async revoke(name, said, datetime) {\n    const hab = await this.client.identifiers().get(name);\n    const pre = hab.prefix;\n    const vs = versify(\"KERI\" /* KERI */, void 0, \"JSON\" /* JSON */, 0);\n    const dt = datetime ?? (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\");\n    const cred = await this.get(said);\n    const _rev = {\n      v: vs,\n      t: Ilks.rev,\n      d: \"\",\n      i: said,\n      s: \"1\",\n      ri: cred.sad.ri,\n      p: cred.status.d,\n      dt\n    };\n    const [, rev] = Saider.saidify(_rev);\n    let ixn = {};\n    let sigs = [];\n    const state = hab.state;\n    if (state.c !== void 0 && state.c.includes(\"EO\")) {\n      var estOnly = true;\n    } else {\n      var estOnly = false;\n    }\n    const sn = parseInt(state.s, 16);\n    const dig = state.d;\n    const data = [\n      {\n        i: rev.i,\n        s: rev.s,\n        d: rev.d\n      }\n    ];\n    const keeper = this.client.manager.get(hab);\n    if (estOnly) {\n      throw new Error(\"Establishment only not implemented\");\n    } else {\n      const serder = interact({\n        pre,\n        sn: sn + 1,\n        data,\n        dig,\n        version: void 0,\n        kind: void 0\n      });\n      sigs = await keeper.sign(b(serder.raw));\n      ixn = serder.ked;\n    }\n    const body = {\n      rev,\n      ixn,\n      sigs,\n      [keeper.algo]: keeper.params()\n    };\n    const path = `/identifiers/${name}/credentials/${said}`;\n    const method = \"DELETE\";\n    const headers = new Headers({\n      Accept: \"application/json+cesr\"\n    });\n    const res = await this.client.fetch(path, method, body, headers);\n    const op = await res.json();\n    return {\n      rev: new Serder(rev),\n      anc: new Serder(ixn),\n      op\n    };\n  }\n  /**\n   * Present a credential\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} said SAID of the credential\n   * @param {string} recipient Identifier prefix of the receiver of the presentation\n   * @param {boolean} [include=true] Flag to indicate whether to stream credential alongside presentation exchange message\n   * @returns {Promise<string>} A promise to the long-running operation\n   */\n  async present(name, said, recipient, include = true) {\n    const hab = await this.client.identifiers().get(name);\n    const pre = hab.prefix;\n    const cred = await this.get(said);\n    const data = {\n      i: cred.sad.i,\n      s: cred.sad.s,\n      n: said\n    };\n    const vs = versify(\"KERI\" /* KERI */, void 0, \"JSON\" /* JSON */, 0);\n    const _sad = {\n      v: vs,\n      t: Ilks.exn,\n      d: \"\",\n      dt: (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\"),\n      r: \"/presentation\",\n      q: {},\n      a: data\n    };\n    const [, sad] = Saider.saidify(_sad);\n    const exn = new Serder(sad);\n    const keeper = this.client.manager.get(hab);\n    const sig = await keeper.sign(b(exn.raw), true);\n    const siger = new Siger({ qb64: sig[0] });\n    const seal = [\"SealLast\", { i: pre }];\n    let ims = messagize(exn, [siger], seal, void 0, void 0, true);\n    ims = ims.slice(JSON.stringify(exn.ked).length);\n    const body = {\n      exn: exn.ked,\n      sig: new TextDecoder().decode(ims),\n      recipient,\n      include\n    };\n    const path = `/identifiers/${name}/credentials/${said}/presentations`;\n    const method = \"POST\";\n    const headers = new Headers({\n      Accept: \"application/json+cesr\"\n    });\n    const res = await this.client.fetch(path, method, body, headers);\n    return await res.text();\n  }\n  /**\n   * Request a presentation of a credential\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} recipient Identifier prefix of the receiver of the presentation\n   * @param {string} schema SAID of the schema\n   * @param {string} [issuer] Optional prefix of the issuer of the credential\n   * @returns {Promise<string>} A promise to the long-running operation\n   */\n  async request(name, recipient, schema, issuer) {\n    const hab = await this.client.identifiers().get(name);\n    const pre = hab.prefix;\n    const data = {\n      s: schema\n    };\n    if (issuer !== void 0) {\n      data[\"i\"] = issuer;\n    }\n    const vs = versify(\"KERI\" /* KERI */, void 0, \"JSON\" /* JSON */, 0);\n    const _sad = {\n      v: vs,\n      t: Ilks.exn,\n      d: \"\",\n      dt: (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\"),\n      r: \"/presentation/request\",\n      q: {},\n      a: data\n    };\n    const [, sad] = Saider.saidify(_sad);\n    const exn = new Serder(sad);\n    const keeper = this.client.manager.get(hab);\n    const sig = await keeper.sign(b(exn.raw), true);\n    const siger = new Siger({ qb64: sig[0] });\n    const seal = [\"SealLast\", { i: pre }];\n    let ims = messagize(exn, [siger], seal, void 0, void 0, true);\n    ims = ims.slice(JSON.stringify(exn.ked).length);\n    const body = {\n      exn: exn.ked,\n      sig: new TextDecoder().decode(ims),\n      recipient\n    };\n    const path = `/identifiers/${name}/requests`;\n    const method = \"POST\";\n    const headers = new Headers({\n      Accept: \"application/json+cesr\"\n    });\n    const res = await this.client.fetch(path, method, body, headers);\n    return await res.text();\n  }\n};\nvar RegistryResult = class {\n  _regser;\n  _serder;\n  _sigs;\n  promise;\n  constructor(regser, serder, sigs, promise) {\n    this._regser = regser;\n    this._serder = serder;\n    this._sigs = sigs;\n    this.promise = promise;\n  }\n  get regser() {\n    return this._regser;\n  }\n  get serder() {\n    return this._serder;\n  }\n  get sigs() {\n    return this._sigs;\n  }\n  async op() {\n    const res = await this.promise;\n    return await res.json();\n  }\n};\nvar Registries = class {\n  client;\n  /**\n   * Registries\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * List registries\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @returns {Promise<any>} A promise to the list of registries\n   */\n  async list(name) {\n    const path = `/identifiers/${name}/registries`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * Create a registry\n   * @async\n   * @param {CreateRegistryArgs}\n   * @returns {Promise<[any, Serder, any[], object]> } A promise to the long-running operation\n   */\n  async create({\n    name,\n    registryName,\n    noBackers = true,\n    toad = 0,\n    baks = [],\n    nonce\n  }) {\n    const hab = await this.client.identifiers().get(name);\n    const pre = hab.prefix;\n    const cnfg = [];\n    if (noBackers) {\n      cnfg.push(TraitDex.NoBackers);\n    }\n    const state = hab.state;\n    const estOnly = state.c !== void 0 && state.c.includes(\"EO\");\n    if (estOnly) {\n      cnfg.push(TraitDex.EstOnly);\n    }\n    const regser = vdr.incept({ pre, baks, toad, nonce, cnfg });\n    if (estOnly) {\n      throw new Error(\"establishment only not implemented\");\n    } else {\n      const state2 = hab.state;\n      const sn = parseInt(state2.s, 16);\n      const dig = state2.d;\n      const data = [\n        {\n          i: regser.pre,\n          s: \"0\",\n          d: regser.pre\n        }\n      ];\n      const serder = interact({\n        pre,\n        sn: sn + 1,\n        data,\n        dig,\n        version: Versionage,\n        kind: \"JSON\" /* JSON */\n      });\n      const keeper = this.client.manager.get(hab);\n      const sigs = await keeper.sign(b(serder.raw));\n      const res = this.createFromEvents(\n        hab,\n        name,\n        registryName,\n        regser.ked,\n        serder.ked,\n        sigs\n      );\n      return new RegistryResult(regser, serder, sigs, res);\n    }\n  }\n  createFromEvents(hab, name, registryName, vcp, ixn, sigs) {\n    const path = `/identifiers/${name}/registries`;\n    const method = \"POST\";\n    const data = {\n      name: registryName,\n      vcp,\n      ixn,\n      sigs\n    };\n    const keeper = this.client.manager.get(hab);\n    data[keeper.algo] = keeper.params();\n    return this.client.fetch(path, method, data);\n  }\n  /**\n   * Rename a registry\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} registryName Current registry name\n   * @param {string} newName New registry name\n   * @returns {Promise<any>} A promise to the registry record\n   */\n  async rename(name, registryName, newName) {\n    const path = `/identifiers/${name}/registries/${registryName}`;\n    const method = \"PUT\";\n    const data = {\n      name: newName\n    };\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n};\nvar Schemas = class {\n  client;\n  /**\n   * Schemas\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Get a schema\n   * @async\n   * @param {string} said SAID of the schema\n   * @returns {Promise<any>} A promise to the schema\n   */\n  async get(said) {\n    const path = `/schema/${said}`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * List schemas\n   * @async\n   * @returns {Promise<any>} A promise to the list of schemas\n   */\n  async list() {\n    const path = `/schema`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n};\nvar Ipex = class {\n  client;\n  /**\n   * Schemas\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Create an IPEX grant EXN message\n   */\n  async grant(args) {\n    const hab = await this.client.identifiers().get(args.senderName);\n    const data = {\n      m: args.message ?? \"\",\n      i: args.recipient\n    };\n    let atc = args.ancAttachment;\n    if (atc === void 0) {\n      const keeper = this.client.manager.get(hab);\n      const sigs = await keeper.sign(b(args.anc.raw));\n      const sigers = sigs.map((sig) => new Siger({ qb64: sig }));\n      const ims = d(messagize(args.anc, sigers));\n      atc = ims.substring(args.anc.size);\n    }\n    const acdcAtc = args.acdcAttachment === void 0 ? d(serializeACDCAttachment(args.iss)) : args.acdcAttachment;\n    const issAtc = args.issAttachment === void 0 ? d(serializeIssExnAttachment(args.anc)) : args.issAttachment;\n    const embeds = {\n      acdc: [args.acdc, acdcAtc],\n      iss: [args.iss, issAtc],\n      anc: [args.anc, atc]\n    };\n    return this.client.exchanges().createExchangeMessage(\n      hab,\n      \"/ipex/grant\",\n      data,\n      embeds,\n      void 0,\n      args.datetime,\n      args.agree\n    );\n  }\n  async submitGrant(name, exn, sigs, atc, recp) {\n    const body = {\n      exn: exn.ked,\n      sigs,\n      atc,\n      rec: recp\n    };\n    const response = await this.client.fetch(\n      `/identifiers/${name}/ipex/grant`,\n      \"POST\",\n      body\n    );\n    return response.json();\n  }\n  /**\n   * Create an IPEX admit EXN message\n   * @async\n   * @param {string} name Name or alias of the identifier\n   * @param {string} message accompany human readable description of the credential being admitted\n   * @param {string} grant qb64 SAID of grant message this admit is responding to\n   * @param {string} datetime Optional datetime to set for the credential\n   * @returns {Promise<[Serder, string[], string]>} A promise to the long-running operation\n   */\n  async admit(name, message, grant, datetime) {\n    const hab = await this.client.identifiers().get(name);\n    const data = {\n      m: message\n    };\n    return this.client.exchanges().createExchangeMessage(\n      hab,\n      \"/ipex/admit\",\n      data,\n      {},\n      void 0,\n      datetime,\n      grant\n    );\n  }\n  async submitAdmit(name, exn, sigs, atc, recp) {\n    const body = {\n      exn: exn.ked,\n      sigs,\n      atc,\n      rec: recp\n    };\n    const response = await this.client.fetch(\n      `/identifiers/${name}/ipex/admit`,\n      \"POST\",\n      body\n    );\n    return response.json();\n  }\n};\n\n// src/keri/app/escrowing.ts\nvar Escrows = class {\n  client;\n  /**\n   * Escrows\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * List replay messages\n   * @async\n   * @param {string} [route] Optional route in the replay message\n   * @returns {Promise<any>} A promise to the list of replay messages\n   */\n  async listReply(route) {\n    const params = new URLSearchParams();\n    if (route !== void 0) {\n      params.append(\"route\", route);\n    }\n    const path = `/escrows/rpy?` + params.toString();\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n};\n\n// src/keri/core/bexter.ts\n\nvar B64REX = \"^[A-Za-z0-9\\\\-_]*$\";\nvar Reb64 = new RegExp(B64REX);\nvar Bexter = class _Bexter extends Matter {\n  constructor({ raw, code = MtrDex.StrB64_L0, qb64b, qb64, qb2 }, bext) {\n    if (raw === void 0 && qb64b === void 0 && qb64 === void 0 && qb2 === void 0) {\n      if (bext === void 0)\n        throw new EmptyMaterialError(\"Missing bext string.\");\n      const match = Reb64.exec(bext);\n      if (!match)\n        throw new Error(\"Invalid Base64.\");\n      raw = _Bexter._rawify(bext);\n    }\n    super({ raw, code, qb64b, qb64, qb2 });\n    if (!BexDex.has(this.code))\n      throw new Error(`Invalid code = ${this.code} for Bexter.`);\n  }\n  static _rawify(bext) {\n    const ts = bext.length % 4;\n    const ws = (4 - ts) % 4;\n    const ls = (3 - ts) % 3;\n    const wad = new Array(ws);\n    wad.fill(\"A\");\n    const base = wad.join(\"\") + bext;\n    const raw = decodeBase64Url(base);\n    return Uint8Array.from(raw).subarray(ls);\n  }\n  get bext() {\n    const sizage = Matter.Sizes.get(this.code);\n    const wad = Uint8Array.from(new Array(sizage?.ls).fill(0));\n    const bext = encodeBase64Url(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from([...wad, ...this.raw]));\n    let ws = 0;\n    if (sizage?.ls === 0 && bext !== void 0) {\n      if (bext[0] === \"A\") {\n        ws = 1;\n      }\n    } else {\n      ws = (sizage?.ls + 1) % 4;\n    }\n    return bext.substring(ws);\n  }\n};\n\n// src/keri/core/pather.ts\nvar Pather = class _Pather extends Bexter {\n  constructor({ raw, code = MtrDex.StrB64_L0, qb64b, qb64, qb2 }, bext, path) {\n    if (raw === void 0 && bext === void 0 && qb64b === void 0 && qb64 === void 0 && qb2 === void 0) {\n      if (path === void 0)\n        throw new EmptyMaterialError(\"Missing bext string.\");\n      bext = _Pather._bextify(path);\n    }\n    super({ raw, code, qb64b, qb64, qb2 }, bext);\n  }\n  // TODO: implement SAD access methods like resolve, root, strip, startswith and tail\n  get path() {\n    if (!this.bext.startsWith(\"-\")) {\n      throw new Error(\"invalid SAD ptr\");\n    }\n    let path = this.bext;\n    while (path.charAt(0) === \"-\") {\n      path = path.substring(1);\n    }\n    const apath = path.split(\"-\");\n    if (apath[0] !== \"\") {\n      return apath;\n    } else {\n      return [];\n    }\n  }\n  static _bextify(path) {\n    const vath = [];\n    for (const p of path) {\n      let sp = \"\";\n      if (typeof p === \"number\") {\n        sp = p.toString();\n      } else {\n        sp = p;\n      }\n      const match = Reb64.exec(sp);\n      if (!match) {\n        throw new Error(`\"Non Base64 path component = ${p}.`);\n      }\n      vath.push(sp);\n    }\n    return \"-\" + vath.join(\"-\");\n  }\n};\n\n// src/keri/app/exchanging.ts\nvar Exchanges = class {\n  client;\n  /**\n   * Exchanges\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Create exn message\n   * @async\n   * @returns {Promise<any>} A promise to the list of replay messages\n   * @param sender\n   * @param route\n   * @param payload\n   * @param embeds\n   * @param recipient\n   * @param datetime\n   * @param dig\n   */\n  async createExchangeMessage(sender, route, payload, embeds, recipient, datetime, dig) {\n    const keeper = this.client.manager.get(sender);\n    const [exn, end] = exchange(\n      route,\n      payload,\n      sender[\"prefix\"],\n      recipient,\n      datetime,\n      dig,\n      void 0,\n      embeds\n    );\n    const sigs = await keeper.sign(b(exn.raw));\n    return [exn, sigs, d(end)];\n  }\n  /**\n   * Send exn messages to list of recipients\n   * @async\n   * @returns {Promise<any>} A promise to the list of replay messages\n   * @param name\n   * @param topic\n   * @param sender\n   * @param route\n   * @param payload\n   * @param embeds\n   * @param recipients\n   */\n  async send(name, topic, sender, route, payload, embeds, recipients) {\n    const [exn, sigs, atc] = await this.createExchangeMessage(\n      sender,\n      route,\n      payload,\n      embeds\n    );\n    return await this.sendFromEvents(\n      name,\n      topic,\n      exn,\n      sigs,\n      atc,\n      recipients\n    );\n  }\n  /**\n   * Send exn messaget to list of recipients\n   * @async\n   * @returns {Promise<any>} A promise to the list of replay messages\n   * @param name\n   * @param topic\n   * @param exn\n   * @param sigs\n   * @param atc\n   * @param recipients\n   */\n  async sendFromEvents(name, topic, exn, sigs, atc, recipients) {\n    const path = `/identifiers/${name}/exchanges`;\n    const method = \"POST\";\n    const data = {\n      tpc: topic,\n      exn: exn.ked,\n      sigs,\n      atc,\n      rec: recipients\n    };\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Get exn message by said\n   * @async\n   * @returns A promise to the exn message\n   * @param said The said of the exn message\n   */\n  async get(said) {\n    const path = `/exchanges/${said}`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n};\nfunction exchange(route, payload, sender, recipient, date, dig, modifiers, embeds) {\n  const vs = versify(\"KERI\" /* KERI */, void 0, \"JSON\" /* JSON */, 0);\n  const ilk = Ilks.exn;\n  const dt = date !== void 0 ? date : nowUTC().toISOString().replace(\"Z\", \"000+00:00\");\n  const p = dig !== void 0 ? dig : \"\";\n  const q = modifiers !== void 0 ? modifiers : {};\n  const ems = embeds != void 0 ? embeds : {};\n  let e = {};\n  let end = \"\";\n  Object.entries(ems).forEach(([key, value]) => {\n    const serder = value[0];\n    const atc = value[1];\n    e[key] = serder.ked;\n    if (atc == void 0) {\n      return;\n    }\n    let pathed = \"\";\n    const pather = new Pather({}, void 0, [\"e\", key]);\n    pathed += pather.qb64;\n    pathed += atc;\n    const counter = new Counter({\n      code: CtrDex.PathedMaterialQuadlets,\n      count: Math.floor(pathed.length / 4)\n    });\n    end += counter.qb64;\n    end += pathed;\n  });\n  if (Object.keys(e).length > 0) {\n    e[\"d\"] = \"\";\n    [, e] = Saider.saidify(e);\n  }\n  const attrs = {};\n  if (recipient !== void 0) {\n    attrs[\"i\"] = recipient;\n  }\n  const a = {\n    ...attrs,\n    ...payload\n  };\n  const _ked = {\n    v: vs,\n    t: ilk,\n    d: \"\",\n    i: sender,\n    p,\n    dt,\n    r: route,\n    q,\n    a,\n    e\n  };\n  const [, ked] = Saider.saidify(_ked);\n  const exn = new Serder(ked);\n  return [exn, b(end)];\n}\n\n// src/keri/app/grouping.ts\nvar Groups = class {\n  client;\n  /**\n   * Groups\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Get group request messages\n   * @async\n   * @param {string} [said] SAID of exn message to load\n   * @returns {Promise<any>} A promise to the list of replay messages\n   */\n  async getRequest(said) {\n    const path = `/multisig/request/` + said;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.json();\n  }\n  /**\n   * Send multisig exn request  messages to other group members\n   * @async\n   * @param {string} [name] human readable name of group AID\n   * @param {Dict<any>} [exn] exn message to send to other members\n   * @param {string[]} [sigs] signature of the participant over the exn\n   * @param {string} [atc] additional attachments from embedded events in exn\n   * @returns {Promise<any>} A promise to the list of replay messages\n   */\n  async sendRequest(name, exn, sigs, atc) {\n    const path = `/identifiers/${name}/multisig/request`;\n    const method = \"POST\";\n    const data = {\n      exn,\n      sigs,\n      atc\n    };\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n  /**\n   * Join multisig group using rotation event.\n   * This can be used by participants being asked to contribute keys to a rotation event to join an existing group.\n   * @async\n   * @param {string} [name] human readable name of group AID\n   * @param {any} [rot] rotation event\n   * @param {any} [sigs] signatures\n   * @param {string} [gid] prefix\n   * @param {string[]} [smids] array of particpants\n   * @param {string[]} [rmids] array of particpants\n   * @returns {Promise<any>} A promise to the list of replay messages\n   */\n  async join(name, rot, sigs, gid, smids, rmids) {\n    const path = `/identifiers/${name}/multisig/join`;\n    const method = \"POST\";\n    const data = {\n      tpc: \"multisig\",\n      rot: rot.ked,\n      sigs,\n      gid,\n      smids,\n      rmids\n    };\n    const res = await this.client.fetch(path, method, data);\n    return await res.json();\n  }\n};\n\n// src/keri/app/notifying.ts\nvar Notifications = class {\n  client;\n  /**\n   * Notifications\n   * @param {SignifyClient} client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * List notifications\n   * @async\n   * @param {number} [start=0] Start index of list of notifications, defaults to 0\n   * @param {number} [end=24] End index of list of notifications, defaults to 24\n   * @returns {Promise<any>} A promise to the list of notifications\n   */\n  async list(start = 0, end = 24) {\n    const extraHeaders = new Headers();\n    extraHeaders.append(\"Range\", `notes=${start}-${end}`);\n    const path = `/notifications`;\n    const method = \"GET\";\n    const res = await this.client.fetch(path, method, null, extraHeaders);\n    const cr = res.headers.get(\"content-range\");\n    const range2 = parseRangeHeaders(cr, \"notes\");\n    const notes = await res.json();\n    return {\n      start: range2.start,\n      end: range2.end,\n      total: range2.total,\n      notes\n    };\n  }\n  /**\n   * Mark a notification as read\n   * @async\n   * @param {string} said SAID of the notification\n   * @returns {Promise<string>} A promise to the result of the marking\n   */\n  async mark(said) {\n    const path = `/notifications/` + said;\n    const method = \"PUT\";\n    const res = await this.client.fetch(path, method, null);\n    return await res.text();\n  }\n  /**\n   * Delete a notification\n   * @async\n   * @param {string} said SAID of the notification\n   * @returns {Promise<any>} A promise to the result of the deletion\n   */\n  async delete(said) {\n    const path = `/notifications/` + said;\n    const method = \"DELETE\";\n    await this.client.fetch(path, method, null);\n  }\n};\n\n// src/keri/app/clienting.ts\nvar DEFAULT_BOOT_URL = \"http://localhost:3903\";\nvar State = class {\n  agent;\n  controller;\n  ridx;\n  pidx;\n  constructor() {\n    this.agent = null;\n    this.controller = null;\n    this.pidx = 0;\n    this.ridx = 0;\n  }\n};\nvar SignifyClient = class {\n  controller;\n  url;\n  bran;\n  pidx;\n  agent;\n  authn;\n  manager;\n  tier;\n  bootUrl;\n  exteralModules;\n  /**\n   * SignifyClient constructor\n   * @param {string} url KERIA admin interface URL\n   * @param {string} bran Base64 21 char string that is used as base material for seed of the client AID\n   * @param {Tier} tier Security tier for generating keys of the client AID (high | mewdium | low)\n   * @param {string} bootUrl KERIA boot interface URL\n   * @param {ExternalModule[]} externalModules list of external modules to load\n   */\n  constructor(url, bran, tier = \"low\" /* low */, bootUrl = DEFAULT_BOOT_URL, externalModules = []) {\n    this.url = url;\n    if (bran.length < 21) {\n      throw Error(\"bran must be 21 characters\");\n    }\n    this.bran = bran;\n    this.pidx = 0;\n    this.controller = new Controller(bran, tier);\n    this.authn = null;\n    this.agent = null;\n    this.manager = null;\n    this.tier = tier;\n    this.bootUrl = bootUrl;\n    this.exteralModules = externalModules;\n  }\n  get data() {\n    return [this.url, this.bran, this.pidx, this.authn];\n  }\n  /**\n   * Boot a KERIA agent\n   * @async\n   * @returns {Promise<Response>} A promise to the result of the boot\n   */\n  async boot() {\n    const [evt, sign] = this.controller?.event ?? [];\n    const data = {\n      icp: evt.ked,\n      sig: sign.qb64,\n      stem: this.controller?.stem,\n      pidx: 1,\n      tier: this.controller?.tier\n    };\n    return await fetch(this.bootUrl + \"/boot\", {\n      method: \"POST\",\n      body: JSON.stringify(data),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  /**\n   * Get state of the agent and the client\n   * @async\n   * @returns {Promise<Response>} A promise to the state\n   */\n  async state() {\n    const caid = this.controller?.pre;\n    const res = await fetch(this.url + `/agent/${caid}`);\n    if (res.status == 404) {\n      throw new Error(`agent does not exist for controller ${caid}`);\n    }\n    const data = await res.json();\n    const state = new State();\n    state.agent = data.agent ?? {};\n    state.controller = data.controller ?? {};\n    state.ridx = data.ridx ?? 0;\n    state.pidx = data.pidx ?? 0;\n    return state;\n  }\n  /**  Connect to a KERIA agent\n   * @async\n   */\n  async connect() {\n    const state = await this.state();\n    this.pidx = state.pidx;\n    this.controller = new Controller(\n      this.bran,\n      this.tier,\n      0,\n      state.controller\n    );\n    this.controller.ridx = state.ridx !== void 0 ? state.ridx : 0;\n    this.agent = new Agent(state.agent);\n    if (this.agent.anchor != this.controller.pre) {\n      throw Error(\n        \"commitment to controller AID missing in agent inception event\"\n      );\n    }\n    if (this.controller.serder.ked.s == 0) {\n      await this.approveDelegation();\n    }\n    this.manager = new KeyManager(\n      this.controller.salter,\n      this.exteralModules\n    );\n    this.authn = new Authenticater(\n      this.controller.signer,\n      this.agent.verfer\n    );\n  }\n  /**\n   * Fetch a resource from the KERIA agent\n   * @async\n   * @param {string} path Path to the resource\n   * @param {string} method HTTP method\n   * @param {any} data Data to be sent in the body of the resource\n   * @param {Headers} [extraHeaders] Optional extra headers to be sent with the request\n   * @returns {Promise<Response>} A promise to the result of the fetch\n   */\n  async fetch(path, method, data, extraHeaders) {\n    const headers = new Headers();\n    let signed_headers = new Headers();\n    const final_headers = new Headers();\n    headers.set(\"Signify-Resource\", this.controller.pre);\n    headers.set(\n      HEADER_SIG_TIME,\n      (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\")\n    );\n    headers.set(\"Content-Type\", \"application/json\");\n    const _body = method == \"GET\" ? null : JSON.stringify(data);\n    if (this.authn) {\n      signed_headers = this.authn.sign(\n        headers,\n        method,\n        path.split(\"?\")[0]\n      );\n    } else {\n      throw new Error(\"client need to call connect first\");\n    }\n    signed_headers.forEach((value, key) => {\n      final_headers.set(key, value);\n    });\n    if (extraHeaders !== void 0) {\n      extraHeaders.forEach((value, key) => {\n        final_headers.append(key, value);\n      });\n    }\n    const res = await fetch(this.url + path, {\n      method,\n      body: _body,\n      headers: final_headers\n    });\n    if (!res.ok) {\n      const error = await res.text();\n      const message = `HTTP ${method} ${path} - ${res.status} ${res.statusText} - ${error}`;\n      throw new Error(message);\n    }\n    const isSameAgent = this.agent?.pre === res.headers.get(\"signify-resource\");\n    if (!isSameAgent) {\n      throw new Error(\"message from a different remote agent\");\n    }\n    const verification = this.authn.verify(\n      res.headers,\n      method,\n      path.split(\"?\")[0]\n    );\n    if (verification) {\n      return res;\n    } else {\n      throw new Error(\"response verification failed\");\n    }\n  }\n  /**\n   * Create a Signed Request to fetch a resource from an external URL with headers signed by an AID\n   * @async\n   * @param {string} aidName Name or alias of the AID to be used for signing\n   * @param {string} url URL of the requested resource\n   * @param {RequestInit} req Request options should include:\n   *     - method: HTTP method\n   *     - data Data to be sent in the body of the resource.\n   *              If the data is a CESR JSON string then you should also set contentType to 'application/json+cesr'\n   *              If the data is a FormData object then you should not set the contentType and the browser will set it to 'multipart/form-data'\n   *              If the data is an object then you should use JSON.stringify to convert it to a string and set the contentType to 'application/json'\n   *     - contentType Content type of the request.\n   * @returns {Promise<Request>} A promise to the created Request\n   */\n  async createSignedRequest(aidName, url, req) {\n    const hab = await this.identifiers().get(aidName);\n    const keeper = this.manager.get(hab);\n    const authenticator = new Authenticater(\n      keeper.signers[0],\n      keeper.signers[0].verfer\n    );\n    const headers = new Headers(req.headers);\n    headers.set(\"Signify-Resource\", hab[\"prefix\"]);\n    headers.set(\n      HEADER_SIG_TIME,\n      (/* @__PURE__ */ new Date()).toISOString().replace(\"Z\", \"000+00:00\")\n    );\n    const signed_headers = authenticator.sign(\n      new Headers(headers),\n      req.method ?? \"GET\",\n      new URL(url).pathname\n    );\n    req.headers = signed_headers;\n    return new Request(url, req);\n  }\n  /**\n   * Approve the delegation of the client AID to the KERIA agent\n   * @async\n   * @returns {Promise<Response>} A promise to the result of the approval\n   */\n  async approveDelegation() {\n    const sigs = this.controller.approveDelegation(this.agent);\n    const data = {\n      ixn: this.controller.serder.ked,\n      sigs\n    };\n    return await fetch(\n      this.url + \"/agent/\" + this.controller.pre + \"?type=ixn\",\n      {\n        method: \"PUT\",\n        body: JSON.stringify(data),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  /**\n   * Save old client passcode in KERIA agent\n   * @async\n   * @param {string} passcode Passcode to be saved\n   * @returns {Promise<Response>} A promise to the result of the save\n   */\n  async saveOldPasscode(passcode) {\n    const caid = this.controller?.pre;\n    const body = { salt: passcode };\n    return await fetch(this.url + \"/salt/\" + caid, {\n      method: \"PUT\",\n      body: JSON.stringify(body),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  /**\n   * Delete a saved passcode from KERIA agent\n   * @async\n   * @returns {Promise<Response>} A promise to the result of the deletion\n   */\n  async deletePasscode() {\n    const caid = this.controller?.pre;\n    return await fetch(this.url + \"/salt/\" + caid, {\n      method: \"DELETE\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  /**\n   * Rotate the client AID\n   * @async\n   * @param {string} nbran Base64 21 char string that is used as base material for the new seed\n   * @param {Array<string>} aids List of managed AIDs to be rotated\n   * @returns {Promise<Response>} A promise to the result of the rotation\n   */\n  async rotate(nbran, aids) {\n    const data = this.controller.rotate(nbran, aids);\n    return await fetch(this.url + \"/agent/\" + this.controller.pre, {\n      method: \"PUT\",\n      body: JSON.stringify(data),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  /**\n   * Get identifiers resource\n   * @returns {Identifier}\n   */\n  identifiers() {\n    return new Identifier(this);\n  }\n  /**\n   * Get OOBIs resource\n   * @returns {Oobis}\n   */\n  oobis() {\n    return new Oobis(this);\n  }\n  /**\n   * Get operations resource\n   * @returns {Operations}\n   */\n  operations() {\n    return new Operations(this);\n  }\n  /**\n   * Get keyEvents resource\n   * @returns {KeyEvents}\n   */\n  keyEvents() {\n    return new KeyEvents(this);\n  }\n  /**\n   * Get keyStates resource\n   * @returns {KeyStates}\n   */\n  keyStates() {\n    return new KeyStates(this);\n  }\n  /**\n   * Get credentials resource\n   * @returns {Credentials}\n   */\n  credentials() {\n    return new Credentials(this);\n  }\n  /**\n   * Get IPEX resource\n   * @returns {Ipex}\n   */\n  ipex() {\n    return new Ipex(this);\n  }\n  /**\n   * Get registries resource\n   * @returns {Registries}\n   */\n  registries() {\n    return new Registries(this);\n  }\n  /**\n   * Get schemas resource\n   * @returns {Schemas}\n   */\n  schemas() {\n    return new Schemas(this);\n  }\n  /**\n   * Get challenges resource\n   * @returns {Challenges}\n   */\n  challenges() {\n    return new Challenges(this);\n  }\n  /**\n   * Get contacts resource\n   * @returns {Contacts}\n   */\n  contacts() {\n    return new Contacts(this);\n  }\n  /**\n   * Get notifications resource\n   * @returns {Notifications}\n   */\n  notifications() {\n    return new Notifications(this);\n  }\n  /**\n   * Get escrows resource\n   * @returns {Escrows}\n   */\n  escrows() {\n    return new Escrows(this);\n  }\n  /**\n   * Get groups resource\n   * @returns {Groups}\n   */\n  groups() {\n    return new Groups(this);\n  }\n  /**\n   * Get exchange resource\n   * @returns {Exchanges}\n   */\n  exchanges() {\n    return new Exchanges(this);\n  }\n};\n\n// src/index.ts\nvar src_default = exports_exports;\n\n//# sourceMappingURL=signify-ts.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbmlmeS10cy9kaXN0L3NpZ25pZnktdHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDOEM7QUFDOUM7QUFDQSxRQUFRLDBEQUFhO0FBQ3JCOztBQUVBO0FBQ2lEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxFQUFFLFdBQVcsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTSxFQUFFO0FBQ3BCO0FBQ0EsSUFBSSxFQUFFLHlCQUF5QixFQUFFLEtBQUssRUFBRSxtQ0FBbUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQzs7QUFFM0M7QUFDMkM7QUFDM0M7QUFDQSxPQUFPLDBDQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMENBQU87QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUUsRUFBRSxzQkFBc0I7QUFDaEQsWUFBWTtBQUNaO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRSxFQUFFLDRCQUE0QixFQUFFLFFBQVE7QUFDaEUsWUFBWTtBQUNaO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRSxFQUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssYUFBYSxJQUFJO0FBQ2hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssYUFBYSxJQUFJO0FBQ2hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUssS0FBSyxHQUFHLGFBQWEsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxhQUFhLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkRBQTJELElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELElBQUk7QUFDL0Q7QUFDQTtBQUNBLCtEQUErRCxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsSUFBSTtBQUNqRTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLCtCQUErQixlQUFlO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQiwrQkFBK0IsZUFBZTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBTSxNQUFNLG1CQUFtQjtBQUNsRCxZQUFZO0FBQ1osbUJBQW1CLDhDQUFNLE1BQU0scUJBQXFCO0FBQ3BEO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLGFBQWEsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxjQUFjLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLLGVBQWUsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssZUFBZSxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssV0FBVyxLQUFLLGVBQWUsS0FBSztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPLFlBQVksS0FBSztBQUNoRTtBQUNBLElBQUk7QUFDSjtBQUNBLHdDQUF3QyxPQUFPLFlBQVksS0FBSztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHLG1CQUFtQixFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYSxXQUFXLEtBQUs7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYyxXQUFXLE1BQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxhQUFhLEtBQUs7QUFDdEU7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3Q0FBd0MsWUFBWSxhQUFhLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQTBDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtQkFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1CQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9DQUFvQztBQUM1QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0Esc0NBQXNDLGFBQWEsZ0JBQWdCLElBQUk7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQWdEO0FBQ2pFO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQWdEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRCxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0MscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJNEI7QUFDZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTSxLQUFLLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sS0FBSyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNLEtBQUssTUFBTTtBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQTJDO0FBQ25ELGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVFQUFtQixNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTSxHQUFHLElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlLGFBQWE7QUFDNUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxzQkFBc0I7QUFDbkMsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQSxpQkFBaUIsZ0RBQWdEO0FBQ2pFLDhCQUE4QixhQUFhO0FBQzNDLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLElBQUksSUFBSTtBQUM5QjtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUssSUFBSSxJQUFJO0FBQ2pDLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25ELFVBQVU7QUFDVix1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNLEtBQUssT0FBTztBQUM3QyxZQUFZO0FBQ1osMkJBQTJCLE1BQU0sS0FBSyxLQUFLO0FBQzNDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxLQUFLLE1BQU07QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0MsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQSxtQ0FBbUM7QUFDbkMsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0REFBNEQsSUFBSTtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFO0FBQ25DO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEtBQUs7QUFDbEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lEO0FBQ2pEO0FBQ0EsY0FBYyxvRUFBMEI7QUFDeEMsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBMEIsQ0FBQywwRUFBZ0M7QUFDMUUsZ0NBQWdDLHNDQUFzQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGlDQUFpQyxLQUFLLGNBQWMsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCLElBQUksYUFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLEtBQUs7QUFDbEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sY0FBYyxLQUFLO0FBQ2xFO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0EsZ0RBQWdELGlDQUFpQyxrQkFBa0IsNEJBQTRCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSyxlQUFlLEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUssZUFBZSxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixlQUFlLHdDQUF3QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0EsaUNBQWlDLEtBQUssY0FBYyxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBbUpFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbmlmeS10cy9kaXN0L3NpZ25pZnktdHMubWpzPzg1OGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2V4cG9ydHMudHNcbnZhciBleHBvcnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydHNfZXhwb3J0cywge1xuICBBZ2VudDogKCkgPT4gQWdlbnQsXG4gIEFsZ29zOiAoKSA9PiBBbGdvcyxcbiAgQXV0aGVudGljYXRlcjogKCkgPT4gQXV0aGVudGljYXRlcixcbiAgQjY0Q2hyQnlJZHg6ICgpID0+IEI2NENockJ5SWR4LFxuICBCNjRJZHhCeUNocjogKCkgPT4gQjY0SWR4QnlDaHIsXG4gIEJleENvZGV4OiAoKSA9PiBCZXhDb2RleCxcbiAgQmV4RGV4OiAoKSA9PiBCZXhEZXgsXG4gIENlc3JOdW1iZXI6ICgpID0+IENlc3JOdW1iZXIsXG4gIENoYWxsZW5nZXM6ICgpID0+IENoYWxsZW5nZXMsXG4gIENpZ2FyOiAoKSA9PiBDaWdhcixcbiAgQ2lwaGVyOiAoKSA9PiBDaXBoZXIsXG4gIENvZGV4OiAoKSA9PiBDb2RleCxcbiAgQ29udGFjdHM6ICgpID0+IENvbnRhY3RzLFxuICBDb250cm9sbGVyOiAoKSA9PiBDb250cm9sbGVyLFxuICBDb3VudGVyOiAoKSA9PiBDb3VudGVyLFxuICBDb3VudGVyQ29kZXg6ICgpID0+IENvdW50ZXJDb2RleCxcbiAgQ3JlYXRvcnk6ICgpID0+IENyZWF0b3J5LFxuICBDcmVkZW50aWFsVHlwZXM6ICgpID0+IENyZWRlbnRpYWxUeXBlcyxcbiAgQ3JlZGVudGlhbHM6ICgpID0+IENyZWRlbnRpYWxzLFxuICBDdHJEZXg6ICgpID0+IEN0ckRleCxcbiAgRGVjcnlwdGVyOiAoKSA9PiBEZWNyeXB0ZXIsXG4gIERpZ2VyOiAoKSA9PiBEaWdlcixcbiAgRGlnaUNvZGV4OiAoKSA9PiBEaWdpQ29kZXgsXG4gIERpZ2lEZXg6ICgpID0+IERpZ2lEZXgsXG4gIERpcExhYmVsczogKCkgPT4gRGlwTGFiZWxzLFxuICBEcnRMYWJlbHM6ICgpID0+IERydExhYmVscyxcbiAgRW1wdHlNYXRlcmlhbEVycm9yOiAoKSA9PiBFbXB0eU1hdGVyaWFsRXJyb3IsXG4gIEVuY3J5cHRlcjogKCkgPT4gRW5jcnlwdGVyLFxuICBFc2Nyb3dzOiAoKSA9PiBFc2Nyb3dzLFxuICBFdmVudFJlc3VsdDogKCkgPT4gRXZlbnRSZXN1bHQsXG4gIEV4Y2hhbmdlczogKCkgPT4gRXhjaGFuZ2VzLFxuICBGQUxTWTogKCkgPT4gRkFMU1ksXG4gIEdyb3VwS2VlcGVyOiAoKSA9PiBHcm91cEtlZXBlcixcbiAgR3JvdXBzOiAoKSA9PiBHcm91cHMsXG4gIEhFQURFUl9TSUdfSU5QVVQ6ICgpID0+IEhFQURFUl9TSUdfSU5QVVQsXG4gIEhFQURFUl9TSUdfVElNRTogKCkgPT4gSEVBREVSX1NJR19USU1FLFxuICBIYWI6ICgpID0+IEhhYixcbiAgSGFiZXJ5OiAoKSA9PiBIYWJlcnksXG4gIEljcExhYmVsczogKCkgPT4gSWNwTGFiZWxzLFxuICBJZGVudDogKCkgPT4gSWRlbnQsXG4gIElkZW50aWZpZXI6ICgpID0+IElkZW50aWZpZXIsXG4gIElkckRleDogKCkgPT4gSWRyRGV4LFxuICBJZHM6ICgpID0+IElkcyxcbiAgSWR4QnRoU2lnRGV4OiAoKSA9PiBJZHhCdGhTaWdEZXgsXG4gIElkeENydFNpZ0RleDogKCkgPT4gSWR4Q3J0U2lnRGV4LFxuICBJZHhTaWdEZXg6ICgpID0+IElkeFNpZ0RleCxcbiAgSWxrczogKCkgPT4gSWxrcyxcbiAgSW5kZXhlZEJvdGhTaWdDb2RleDogKCkgPT4gSW5kZXhlZEJvdGhTaWdDb2RleCxcbiAgSW5kZXhlZEN1cnJlbnRTaWdDb2RleDogKCkgPT4gSW5kZXhlZEN1cnJlbnRTaWdDb2RleCxcbiAgSW5kZXhlZFNpZ0NvZGV4OiAoKSA9PiBJbmRleGVkU2lnQ29kZXgsXG4gIEluZGV4ZXI6ICgpID0+IEluZGV4ZXIsXG4gIEluZGV4ZXJDb2RleDogKCkgPT4gSW5kZXhlckNvZGV4LFxuICBJbnB1dGFnZTogKCkgPT4gSW5wdXRhZ2UsXG4gIElwZXg6ICgpID0+IElwZXgsXG4gIEl4bkxhYmVsczogKCkgPT4gSXhuTGFiZWxzLFxuICBLZXlFdmVudHM6ICgpID0+IEtleUV2ZW50cyxcbiAgS2V5TWFuYWdlcjogKCkgPT4gS2V5TWFuYWdlcixcbiAgS2V5U3RhdGVzOiAoKSA9PiBLZXlTdGF0ZXMsXG4gIEtzbkxhYmVsczogKCkgPT4gS3NuTGFiZWxzLFxuICBMYXJnZVZyekRleDogKCkgPT4gTGFyZ2VWcnpEZXgsXG4gIE1JTlNJR1NJWkU6ICgpID0+IE1JTlNJR1NJWkUsXG4gIE1JTlNOSUZGU0laRTogKCkgPT4gTUlOU05JRkZTSVpFLFxuICBNYW5hZ2VyOiAoKSA9PiBNYW5hZ2VyLFxuICBNYXR0ZXI6ICgpID0+IE1hdHRlcixcbiAgTWF0dGVyQ29kZXg6ICgpID0+IE1hdHRlckNvZGV4LFxuICBNdHJEZXg6ICgpID0+IE10ckRleCxcbiAgTm9uVHJhbnNDb2RleDogKCkgPT4gTm9uVHJhbnNDb2RleCxcbiAgTm9uVHJhbnNEZXg6ICgpID0+IE5vblRyYW5zRGV4LFxuICBOb3RpZmljYXRpb25zOiAoKSA9PiBOb3RpZmljYXRpb25zLFxuICBOdW1Db2RleDogKCkgPT4gTnVtQ29kZXgsXG4gIE51bURleDogKCkgPT4gTnVtRGV4LFxuICBPb2JpczogKCkgPT4gT29iaXMsXG4gIE9wZXJhdGlvbnM6ICgpID0+IE9wZXJhdGlvbnMsXG4gIFByZWZpeGVyOiAoKSA9PiBQcmVmaXhlcixcbiAgUmFuZHlDcmVhdG9yOiAoKSA9PiBSYW5keUNyZWF0b3IsXG4gIFJhbmR5S2VlcGVyOiAoKSA9PiBSYW5keUtlZXBlcixcbiAgUmVnaXN0cmllczogKCkgPT4gUmVnaXN0cmllcyxcbiAgUmVnaXN0cnlSZXN1bHQ6ICgpID0+IFJlZ2lzdHJ5UmVzdWx0LFxuICBSb3RMYWJlbHM6ICgpID0+IFJvdExhYmVscyxcbiAgUnB5TGFiZWxzOiAoKSA9PiBScHlMYWJlbHMsXG4gIFNhaWRlcjogKCkgPT4gU2FpZGVyLFxuICBTYWx0ZXI6ICgpID0+IFNhbHRlcixcbiAgU2FsdHlDcmVhdG9yOiAoKSA9PiBTYWx0eUNyZWF0b3IsXG4gIFNhbHR5S2VlcGVyOiAoKSA9PiBTYWx0eUtlZXBlcixcbiAgU2NoZW1hczogKCkgPT4gU2NoZW1hcyxcbiAgU2VxbmVyOiAoKSA9PiBTZXFuZXIsXG4gIFNlcmRlcjogKCkgPT4gU2VyZGVyLFxuICBTZXJpYWxzOiAoKSA9PiBTZXJpYWxzLFxuICBTaWdlcjogKCkgPT4gU2lnZXIsXG4gIFNpZ25hZ2U6ICgpID0+IFNpZ25hZ2UsXG4gIFNpZ25lcjogKCkgPT4gU2lnbmVyLFxuICBTaWduaWZ5Q2xpZW50OiAoKSA9PiBTaWduaWZ5Q2xpZW50LFxuICBTaXphZ2U6ICgpID0+IFNpemFnZSxcbiAgU21hbGxWcnpEZXg6ICgpID0+IFNtYWxsVnJ6RGV4LFxuICBUUlVUSFk6ICgpID0+IFRSVVRIWSxcbiAgVGhvbGRlcjogKCkgPT4gVGhvbGRlcixcbiAgVGllcjogKCkgPT4gVGllcixcbiAgVHJhaXRDb2RleDogKCkgPT4gVHJhaXRDb2RleCxcbiAgVHJhaXREZXg6ICgpID0+IFRyYWl0RGV4LFxuICBVbnF1YWxpZmllZDogKCkgPT4gVW5xdWFsaWZpZWQsXG4gIFZFUkVYOiAoKSA9PiBWRVJFWCxcbiAgVkVSRlVMTFNJWkU6ICgpID0+IFZFUkZVTExTSVpFLFxuICBWZXJmZXI6ICgpID0+IFZlcmZlcixcbiAgVmVyc2lvbjogKCkgPT4gVmVyc2lvbixcbiAgVmVyc2lvbmFnZTogKCkgPT4gVmVyc2lvbmFnZSxcbiAgWGl6YWdlOiAoKSA9PiBYaXphZ2UsXG4gIGFtcGxlOiAoKSA9PiBhbXBsZSxcbiAgYXJyYXlFcXVhbHM6ICgpID0+IGFycmF5RXF1YWxzLFxuICBiOiAoKSA9PiBiLFxuICBiNjRUb0ludDogKCkgPT4gYjY0VG9JbnQsXG4gIGJ5dGVzVG9JbnQ6ICgpID0+IGJ5dGVzVG9JbnQsXG4gIGNvbmNhdDogKCkgPT4gY29uY2F0LFxuICBkOiAoKSA9PiBkLFxuICBkZXNpZ2lucHV0OiAoKSA9PiBkZXNpZ2lucHV0LFxuICBkZXNpZ25hdHVyZTogKCkgPT4gZGVzaWduYXR1cmUsXG4gIGRldmVyc2lmeTogKCkgPT4gZGV2ZXJzaWZ5LFxuICBkdW1wczogKCkgPT4gZHVtcHMsXG4gIGV4Y2hhbmdlOiAoKSA9PiBleGNoYW5nZSxcbiAgZXh0cmFjdFZhbHVlczogKCkgPT4gZXh0cmFjdFZhbHVlcyxcbiAgaW5jZXB0OiAoKSA9PiBpbmNlcHQsXG4gIGludFRvQjY0OiAoKSA9PiBpbnRUb0I2NCxcbiAgaW50VG9CNjRiOiAoKSA9PiBpbnRUb0I2NGIsXG4gIGludFRvQnl0ZXM6ICgpID0+IGludFRvQnl0ZXMsXG4gIGludGVyYWN0OiAoKSA9PiBpbnRlcmFjdCxcbiAgbWVzc2FnaXplOiAoKSA9PiBtZXNzYWdpemUsXG4gIG5vcm1hbGl6ZTogKCkgPT4gbm9ybWFsaXplLFxuICBub3dVVEM6ICgpID0+IG5vd1VUQyxcbiAgb3Blbk1hbmFnZXI6ICgpID0+IG9wZW5NYW5hZ2VyLFxuICBwYWQ6ICgpID0+IHBhZCxcbiAgcGFyc2VSYW5nZUhlYWRlcnM6ICgpID0+IHBhcnNlUmFuZ2VIZWFkZXJzLFxuICByYW5kb21Ob25jZTogKCkgPT4gcmFuZG9tTm9uY2UsXG4gIHJhbmRvbVBhc3Njb2RlOiAoKSA9PiByYW5kb21QYXNzY29kZSxcbiAgcmFuZ2U6ICgpID0+IHJhbmdlLFxuICByZWFkSW50OiAoKSA9PiByZWFkSW50LFxuICByZWFkeTogKCkgPT4gcmVhZHksXG4gIHJlcGx5OiAoKSA9PiByZXBseSxcbiAgcmlLZXk6ICgpID0+IHJpS2V5LFxuICByb3RhdGU6ICgpID0+IHJvdGF0ZSxcbiAgc2VyaWFsaXplQUNEQ0F0dGFjaG1lbnQ6ICgpID0+IHNlcmlhbGl6ZUFDRENBdHRhY2htZW50LFxuICBzZXJpYWxpemVJc3NFeG5BdHRhY2htZW50OiAoKSA9PiBzZXJpYWxpemVJc3NFeG5BdHRhY2htZW50LFxuICBzaWdpbnB1dDogKCkgPT4gc2lnaW5wdXQsXG4gIHNpZ25hdHVyZTogKCkgPT4gc2lnbmF0dXJlLFxuICBzaXplaWZ5OiAoKSA9PiBzaXplaWZ5LFxuICB2ZXJzaWZ5OiAoKSA9PiB2ZXJzaWZ5XG59KTtcblxuLy8gc3JjL3JlYWR5LnRzXG5pbXBvcnQgX3NvZGl1bSBmcm9tIFwibGlic29kaXVtLXdyYXBwZXJzLXN1bW9cIjtcbnZhciByZWFkeSA9IGFzeW5jICgpID0+IHtcbiAgYXdhaXQgX3NvZGl1bS5yZWFkeTtcbn07XG5cbi8vIHNyYy9rZXJpL2NvcmUvZW5jcnlwdGVyLnRzXG5pbXBvcnQgbGlic29kaXVtNSBmcm9tIFwibGlic29kaXVtLXdyYXBwZXJzLXN1bW9cIjtcblxuLy8gc3JjL2tlcmkvY29yZS9rZXJpbmcudHNcbnZhciBFbXB0eU1hdGVyaWFsRXJyb3IgPSBjbGFzcyB7XG4gIF9lcnI7XG4gIGNvbnN0cnVjdG9yKGVycikge1xuICAgIHRoaXMuX2VyciA9IG5ldyBFcnJvcihlcnIpO1xuICB9XG4gIGdldCBlcnIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VycjtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9jb3JlLnRzXG52YXIgU2VyaWFscyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcmlhbHMyKSA9PiB7XG4gIFNlcmlhbHMyW1wiSlNPTlwiXSA9IFwiSlNPTlwiO1xuICByZXR1cm4gU2VyaWFsczI7XG59KShTZXJpYWxzIHx8IHt9KTtcbnZhciBJZGVudCA9IC8qIEBfX1BVUkVfXyAqLyAoKElkZW50MikgPT4ge1xuICBJZGVudDJbXCJLRVJJXCJdID0gXCJLRVJJXCI7XG4gIElkZW50MltcIkFDRENcIl0gPSBcIkFDRENcIjtcbiAgcmV0dXJuIElkZW50Mjtcbn0pKElkZW50IHx8IHt9KTtcbnZhciBWZXJzaW9uID0gY2xhc3Mge1xuICBtYWpvcjtcbiAgbWlub3I7XG4gIGNvbnN0cnVjdG9yKG1ham9yID0gMSwgbWlub3IgPSAwKSB7XG4gICAgdGhpcy5tYWpvciA9IG1ham9yO1xuICAgIHRoaXMubWlub3IgPSBtaW5vcjtcbiAgfVxufTtcbnZhciBWZXJzaW9uYWdlID0gbmV3IFZlcnNpb24oKTtcbnZhciBJbGtzID0ge1xuICBpY3A6IFwiaWNwXCIsXG4gIHJvdDogXCJyb3RcIixcbiAgaXhuOiBcIml4blwiLFxuICBkaXA6IFwiZGlwXCIsXG4gIGRydDogXCJkcnRcIixcbiAgcmN0OiBcInJjdFwiLFxuICB2cmM6IFwidnJjXCIsXG4gIHJweTogXCJycHlcIixcbiAgZXhuOiBcImV4blwiLFxuICB2Y3A6IFwidmNwXCIsXG4gIGlzczogXCJpc3NcIixcbiAgcmV2OiBcInJldlwiXG59O1xudmFyIEljcExhYmVscyA9IFtcbiAgXCJ2XCIsXG4gIFwiaVwiLFxuICBcInNcIixcbiAgXCJ0XCIsXG4gIFwia3RcIixcbiAgXCJrXCIsXG4gIFwiblwiLFxuICBcImJ0XCIsXG4gIFwiYlwiLFxuICBcImNcIixcbiAgXCJhXCJcbl07XG52YXIgRGlwTGFiZWxzID0gW1xuICBcInZcIixcbiAgXCJpXCIsXG4gIFwic1wiLFxuICBcInRcIixcbiAgXCJrdFwiLFxuICBcImtcIixcbiAgXCJuXCIsXG4gIFwiYnRcIixcbiAgXCJiXCIsXG4gIFwiY1wiLFxuICBcImFcIixcbiAgXCJkaVwiXG5dO1xudmFyIFJvdExhYmVscyA9IFtcbiAgXCJ2XCIsXG4gIFwiaVwiLFxuICBcInNcIixcbiAgXCJ0XCIsXG4gIFwicFwiLFxuICBcImt0XCIsXG4gIFwia1wiLFxuICBcIm5cIixcbiAgXCJidFwiLFxuICBcImJyXCIsXG4gIFwiYmFcIixcbiAgXCJhXCJcbl07XG52YXIgRHJ0TGFiZWxzID0gW1xuICBcInZcIixcbiAgXCJpXCIsXG4gIFwic1wiLFxuICBcInRcIixcbiAgXCJwXCIsXG4gIFwia3RcIixcbiAgXCJrXCIsXG4gIFwiblwiLFxuICBcImJ0XCIsXG4gIFwiYnJcIixcbiAgXCJiYVwiLFxuICBcImFcIlxuXTtcbnZhciBJeG5MYWJlbHMgPSBbXCJ2XCIsIFwiaVwiLCBcInNcIiwgXCJ0XCIsIFwicFwiLCBcImFcIl07XG52YXIgS3NuTGFiZWxzID0gW1xuICBcInZcIixcbiAgXCJpXCIsXG4gIFwic1wiLFxuICBcInRcIixcbiAgXCJwXCIsXG4gIFwiZFwiLFxuICBcImZcIixcbiAgXCJkdFwiLFxuICBcImV0XCIsXG4gIFwia3RcIixcbiAgXCJrXCIsXG4gIFwiblwiLFxuICBcImJ0XCIsXG4gIFwiYlwiLFxuICBcImNcIixcbiAgXCJlZVwiLFxuICBcImRpXCIsXG4gIFwiclwiXG5dO1xudmFyIFJweUxhYmVscyA9IFtcInZcIiwgXCJ0XCIsIFwiZFwiLCBcImR0XCIsIFwiclwiLCBcImFcIl07XG52YXIgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xudmFyIGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbnZhciBWRVJGVUxMU0laRSA9IDE3O1xudmFyIE1JTlNOSUZGU0laRSA9IDEyICsgVkVSRlVMTFNJWkU7XG52YXIgTUlOU0lHU0laRSA9IDQ7XG52YXIgVkVSRVggPSBcIihLRVJJfEFDREMpKFswLTlhLWZdKShbMC05YS1mXSkoW0EtWl17NH0pKFswLTlhLWZdezZ9KV9cIjtcbmZ1bmN0aW9uIGRldmVyc2lmeSh2ZXJzaW9uU3RyaW5nKSB7XG4gIGxldCBraW5kO1xuICBsZXQgc2l6ZTtcbiAgbGV0IHByb3RvO1xuICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmFnZTtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKFZFUkVYKTtcbiAgY29uc3QgbWF0Y2ggPSByZS5leGVjKHZlcnNpb25TdHJpbmcpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBbcHJvdG8sIHZlcnNpb24ubWFqb3IsIHZlcnNpb24ubWlub3IsIGtpbmQsIHNpemVdID0gW1xuICAgICAgbWF0Y2hbMV0sXG4gICAgICArbWF0Y2hbMl0sXG4gICAgICArbWF0Y2hbM10sXG4gICAgICBtYXRjaFs0XSxcbiAgICAgIG1hdGNoWzVdXG4gICAgXTtcbiAgICBpZiAoIU9iamVjdC52YWx1ZXMoU2VyaWFscykuaW5jbHVkZXMoa2luZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXJpYWxpemF0aW9uIGtpbmQgPSAke2tpbmR9YCk7XG4gICAgfVxuICAgIGlmICghT2JqZWN0LnZhbHVlcyhJZGVudCkuaW5jbHVkZXMocHJvdG8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VyaWFsaXphdGlvbiBraW5kID0gJHtraW5kfWApO1xuICAgIH1cbiAgICBjb25zdCB0YSA9IGtpbmQ7XG4gICAga2luZCA9IFNlcmlhbHNbdGFdO1xuICAgIGNvbnN0IHBhID0gcHJvdG87XG4gICAgcHJvdG8gPSBJZGVudFtwYV07XG4gICAgcmV0dXJuIFtwcm90bywga2luZCwgdmVyc2lvbiwgc2l6ZV07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb24gc3RyaW5nID0gJHt2ZXJzaW9uU3RyaW5nfWApO1xufVxuZnVuY3Rpb24gdmVyc2lmeShpZGVudCA9IFwiS0VSSVwiIC8qIEtFUkkgKi8sIHZlcnNpb24sIGtpbmQgPSBcIkpTT05cIiAvKiBKU09OICovLCBzaXplID0gMCkge1xuICB2ZXJzaW9uID0gdmVyc2lvbiA9PSB2b2lkIDAgPyBWZXJzaW9uYWdlIDogdmVyc2lvbjtcbiAgcmV0dXJuIGAke2lkZW50fSR7dmVyc2lvbi5tYWpvci50b1N0cmluZyhcbiAgICAxNlxuICApfSR7dmVyc2lvbi5taW5vci50b1N0cmluZygpfSR7a2luZH0ke3NpemUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsIFwiMFwiKX1fYDtcbn1cbnZhciBCNjRDaHJCeUlkeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgWzAsIFwiQVwiXSxcbiAgWzEsIFwiQlwiXSxcbiAgWzIsIFwiQ1wiXSxcbiAgWzMsIFwiRFwiXSxcbiAgWzQsIFwiRVwiXSxcbiAgWzUsIFwiRlwiXSxcbiAgWzYsIFwiR1wiXSxcbiAgWzcsIFwiSFwiXSxcbiAgWzgsIFwiSVwiXSxcbiAgWzksIFwiSlwiXSxcbiAgWzEwLCBcIktcIl0sXG4gIFsxMSwgXCJMXCJdLFxuICBbMTIsIFwiTVwiXSxcbiAgWzEzLCBcIk5cIl0sXG4gIFsxNCwgXCJPXCJdLFxuICBbMTUsIFwiUFwiXSxcbiAgWzE2LCBcIlFcIl0sXG4gIFsxNywgXCJSXCJdLFxuICBbMTgsIFwiU1wiXSxcbiAgWzE5LCBcIlRcIl0sXG4gIFsyMCwgXCJVXCJdLFxuICBbMjEsIFwiVlwiXSxcbiAgWzIyLCBcIldcIl0sXG4gIFsyMywgXCJYXCJdLFxuICBbMjQsIFwiWVwiXSxcbiAgWzI1LCBcIlpcIl0sXG4gIFsyNiwgXCJhXCJdLFxuICBbMjcsIFwiYlwiXSxcbiAgWzI4LCBcImNcIl0sXG4gIFsyOSwgXCJkXCJdLFxuICBbMzAsIFwiZVwiXSxcbiAgWzMxLCBcImZcIl0sXG4gIFszMiwgXCJnXCJdLFxuICBbMzMsIFwiaFwiXSxcbiAgWzM0LCBcImlcIl0sXG4gIFszNSwgXCJqXCJdLFxuICBbMzYsIFwia1wiXSxcbiAgWzM3LCBcImxcIl0sXG4gIFszOCwgXCJtXCJdLFxuICBbMzksIFwiblwiXSxcbiAgWzQwLCBcIm9cIl0sXG4gIFs0MSwgXCJwXCJdLFxuICBbNDIsIFwicVwiXSxcbiAgWzQzLCBcInJcIl0sXG4gIFs0NCwgXCJzXCJdLFxuICBbNDUsIFwidFwiXSxcbiAgWzQ2LCBcInVcIl0sXG4gIFs0NywgXCJ2XCJdLFxuICBbNDgsIFwid1wiXSxcbiAgWzQ5LCBcInhcIl0sXG4gIFs1MCwgXCJ5XCJdLFxuICBbNTEsIFwielwiXSxcbiAgWzUyLCBcIjBcIl0sXG4gIFs1MywgXCIxXCJdLFxuICBbNTQsIFwiMlwiXSxcbiAgWzU1LCBcIjNcIl0sXG4gIFs1NiwgXCI0XCJdLFxuICBbNTcsIFwiNVwiXSxcbiAgWzU4LCBcIjZcIl0sXG4gIFs1OSwgXCI3XCJdLFxuICBbNjAsIFwiOFwiXSxcbiAgWzYxLCBcIjlcIl0sXG4gIFs2MiwgXCItXCJdLFxuICBbNjMsIFwiX1wiXVxuXSk7XG52YXIgQjY0SWR4QnlDaHIgPSBuZXcgTWFwKFxuICBBcnJheS5mcm9tKEI2NENockJ5SWR4LCAoZW50cnkpID0+IFtlbnRyeVsxXSwgZW50cnlbMF1dKVxuKTtcbmZ1bmN0aW9uIGludFRvQjY0KGksIGwgPSAxKSB7XG4gIGxldCBvdXQgPSBcIlwiO1xuICB3aGlsZSAobCAhPSAwKSB7XG4gICAgb3V0ID0gQjY0Q2hyQnlJZHguZ2V0KGkgJSA2NCkgKyBvdXQ7XG4gICAgaSA9IE1hdGguZmxvb3IoaSAvIDY0KTtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgeCA9IGwgLSBvdXQubGVuZ3RoO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgeDsgaTIrKykge1xuICAgIG91dCA9IFwiQVwiICsgb3V0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpbnRUb0I2NGIobiwgbCA9IDEpIHtcbiAgY29uc3QgcyA9IGludFRvQjY0KG4sIGwpO1xuICByZXR1cm4gYihzKTtcbn1cbmZ1bmN0aW9uIGI2NFRvSW50KHMpIHtcbiAgaWYgKHMubGVuZ3RoID09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBzdHJpbmcsIGNvbnZlcnNpb24gdW5kZWZpbmVkLlwiKTtcbiAgfVxuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHJldiA9IHMuc3BsaXQoXCJcIikucmV2ZXJzZSgpO1xuICByZXYuZm9yRWFjaCgoYywgZSkgPT4ge1xuICAgIGkgfD0gQjY0SWR4QnlDaHIuZ2V0KGMpIDw8IGUgKiA2O1xuICB9KTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBiKHMpIHtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHMpO1xufVxuZnVuY3Rpb24gZCh1KSB7XG4gIHJldHVybiBkZWNvZGVyLmRlY29kZSh1KTtcbn1cbmZ1bmN0aW9uIGNvbmNhdChvbmUsIHR3bykge1xuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShvbmUubGVuZ3RoICsgdHdvLmxlbmd0aCk7XG4gIG91dC5zZXQob25lKTtcbiAgb3V0LnNldCh0d28sIG9uZS5sZW5ndGgpO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gcmVhZEludChhcnJheSkge1xuICBsZXQgdmFsdWUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSAqIDI1NiArIGFycmF5W2ldO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2tlcmkvY29yZS9tYXR0ZXIudHNcbmltcG9ydCB7IEJ1ZmZlciBhcyBCdWZmZXIzIH0gZnJvbSBcImJ1ZmZlclwiO1xuXG4vLyBzcmMva2VyaS9jb3JlL2Jhc2U2NC50c1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlcjIgfSBmcm9tIFwiYnVmZmVyXCI7XG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRVcmwoYnVmZmVyKSB7XG4gIGlmICghQnVmZmVyMi5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImBidWZmZXJgIG11c3QgYmUgYSBidWZmZXIuXCIpO1xuICB9XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0rLywgXCJcIik7XG59XG5mdW5jdGlvbiBkZWNvZGVCYXNlNjRVcmwoaW5wdXQpIHtcbiAgaWYgKCEodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJgaW5wdXRgIG11c3QgYmUgYSBzdHJpbmcuXCIpO1xuICB9XG4gIGNvbnN0IG4gPSBpbnB1dC5sZW5ndGggJSA0O1xuICBjb25zdCBwYWRkZWQgPSBpbnB1dCArIFwiPVwiLnJlcGVhdChuID4gMCA/IDQgLSBuIDogbik7XG4gIGNvbnN0IGJhc2U2NFN0cmluZyA9IHBhZGRlZC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgcmV0dXJuIEJ1ZmZlcjIuZnJvbShiYXNlNjRTdHJpbmcsIFwiYmFzZTY0XCIpO1xufVxuXG4vLyBzcmMva2VyaS9jb3JlL21hdHRlci50c1xudmFyIENvZGV4ID0gY2xhc3Mge1xuICBoYXMocHJvcCkge1xuICAgIGNvbnN0IG0gPSBuZXcgTWFwKFxuICAgICAgQXJyYXkuZnJvbShPYmplY3QuZW50cmllcyh0aGlzKSwgKHYpID0+IFt2WzFdLCB2WzBdXSlcbiAgICApO1xuICAgIHJldHVybiBtLmhhcyhwcm9wKTtcbiAgfVxufTtcbnZhciBNYXR0ZXJDb2RleCA9IGNsYXNzIGV4dGVuZHMgQ29kZXgge1xuICBFZDI1NTE5X1NlZWQgPSBcIkFcIjtcbiAgLy8gRWQyNTUxOSAyNTYgYml0IHJhbmRvbSBzZWVkIGZvciBwcml2YXRlIGtleVxuICBFZDI1NTE5TiA9IFwiQlwiO1xuICAvLyBFZDI1NTE5IHZlcmlmaWNhdGlvbiBrZXkgbm9uLXRyYW5zZmVyYWJsZSwgYmFzaWMgZGVyaXZhdGlvbi5cbiAgWDI1NTE5ID0gXCJDXCI7XG4gIC8vIFgyNTUxOSBwdWJsaWMgZW5jcnlwdGlvbiBrZXksIGNvbnZlcnRlZCBmcm9tIEVkMjU1MTkgb3IgRWQyNTUxOU4uXG4gIEVkMjU1MTkgPSBcIkRcIjtcbiAgLy8gRWQyNTUxOSB2ZXJpZmljYXRpb24ga2V5IGJhc2ljIGRlcml2YXRpb25cbiAgQmxha2UzXzI1NiA9IFwiRVwiO1xuICAvLyBCbGFrZTMgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIFNIQTNfMjU2ID0gXCJIXCI7XG4gIC8vIFNIQTMgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIFNIQTJfMjU2ID0gXCJJXCI7XG4gIC8vIFNIQTIgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIEVDRFNBXzI1NmsxX1NlZWQgPSBcIkpcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NmsxIDI1NiBiaXQgcmFuZG9tIFNlZWQgZm9yIHByaXZhdGUga2V5XG4gIFgyNTUxOV9Qcml2YXRlID0gXCJPXCI7XG4gIC8vIFgyNTUxOSBwcml2YXRlIGRlY3J5cHRpb24ga2V5IGNvbnZlcnRlZCBmcm9tIEVkMjU1MTlcbiAgWDI1NTE5X0NpcGhlcl9TZWVkID0gXCJQXCI7XG4gIC8vIFgyNTUxOSAxMjQgY2hhciBiNjQgQ2lwaGVyIG9mIDQ0IGNoYXIgcWI2NCBTZWVkXG4gIEVDRFNBXzI1NnIxX1NlZWQgPSBcIlFcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NnIxIDI1NiBiaXQgcmFuZG9tIFNlZWQgZm9yIHByaXZhdGUga2V5XG4gIFNhbHRfMTI4ID0gXCIwQVwiO1xuICAvLyAxMjggYml0IHJhbmRvbSBzYWx0IG9yIDEyOCBiaXQgbnVtYmVyIChzZWUgSHVnZSlcbiAgRWQyNTUxOV9TaWcgPSBcIjBCXCI7XG4gIC8vIEVkMjU1MTkgc2lnbmF0dXJlLlxuICBFQ0RTQV8yNTZrMV9TaWcgPSBcIjBDXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZrMSBzaWduYXR1cmUuXG4gIEVDRFNBXzI1NnIxX1NpZyA9IFwiMElcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NnIxIHNpZ25hdHVyZS5cbiAgU3RyQjY0X0wwID0gXCI0QVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgTGVhZCBTaXplIDBcbiAgU3RyQjY0X0wxID0gXCI1QVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgTGVhZCBTaXplIDFcbiAgU3RyQjY0X0wyID0gXCI2QVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgTGVhZCBTaXplIDJcbiAgRUNEU0FfMjU2azFOID0gXCIxQUFBXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZrMSB2ZXJpZmljYXRpb24ga2V5IG5vbi10cmFuc2ZlcmFibGUsIGJhc2ljIGRlcml2YXRpb24uXG4gIEVDRFNBXzI1NmsxID0gXCIxQUFCXCI7XG4gIC8vIEVDRFNBIHB1YmxpYyB2ZXJpZmljYXRpb24gb3IgZW5jcnlwdGlvbiBrZXksIGJhc2ljIGRlcml2YXRpb25cbiAgWDI1NTE5X0NpcGhlcl9TYWx0ID0gXCIxQUFIXCI7XG4gIC8vIFgyNTUxOSAxMDAgY2hhciBiNjQgQ2lwaGVyIG9mIDI0IGNoYXIgcWI2NCBTYWx0XG4gIEVDRFNBXzI1NnIxTiA9IFwiMUFBSVwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2cjEgdmVyaWZpY2F0aW9uIGtleSBub24tdHJhbnNmZXJhYmxlLCBiYXNpYyBkZXJpdmF0aW9uLlxuICBFQ0RTQV8yNTZyMSA9IFwiMUFBSlwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2cjEgdmVyaWZpY2F0aW9uIG9yIGVuY3J5cHRpb24ga2V5LCBiYXNpYyBkZXJpdmF0aW9uXG4gIFN0ckI2NF9CaWdfTDAgPSBcIjdBQUFcIjtcbiAgLy8gU3RyaW5nIEJhc2U2NCBPbmx5IEJpZyBMZWFkIFNpemUgMFxuICBTdHJCNjRfQmlnX0wxID0gXCI4QUFBXCI7XG4gIC8vIFN0cmluZyBCYXNlNjQgT25seSBCaWcgTGVhZCBTaXplIDFcbiAgU3RyQjY0X0JpZ19MMiA9IFwiOUFBQVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgQmlnIExlYWQgU2l6ZSAyXG59O1xudmFyIE10ckRleCA9IG5ldyBNYXR0ZXJDb2RleCgpO1xudmFyIE5vblRyYW5zQ29kZXggPSBjbGFzcyBleHRlbmRzIENvZGV4IHtcbiAgRWQyNTUxOU4gPSBcIkJcIjtcbiAgLy8gRWQyNTUxOSB2ZXJpZmljYXRpb24ga2V5IG5vbi10cmFuc2ZlcmFibGUsIGJhc2ljIGRlcml2YXRpb24uXG4gIEVDRFNBXzI1NmsxTiA9IFwiMUFBQVwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2azEgdmVyaWZpY2F0aW9uIGtleSBub24tdHJhbnNmZXJhYmxlLCBiYXNpYyBkZXJpdmF0aW9uLlxuICBFZDQ0OE4gPSBcIjFBQUNcIjtcbiAgLy8gRWQ0NDggbm9uLXRyYW5zZmVyYWJsZSBwcmVmaXggcHVibGljIHNpZ25pbmcgdmVyaWZpY2F0aW9uIGtleS4gQmFzaWMgZGVyaXZhdGlvbi5cbiAgRUNEU0FfMjU2cjFOID0gXCIxQUFJXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZyMSB2ZXJpZmljYXRpb24ga2V5IG5vbi10cmFuc2ZlcmFibGUsIGJhc2ljIGRlcml2YXRpb24uXG59O1xudmFyIE5vblRyYW5zRGV4ID0gbmV3IE5vblRyYW5zQ29kZXgoKTtcbnZhciBEaWdpQ29kZXggPSBjbGFzcyBleHRlbmRzIENvZGV4IHtcbiAgQmxha2UzXzI1NiA9IFwiRVwiO1xuICAvLyBCbGFrZTMgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIEJsYWtlMmJfMjU2ID0gXCJGXCI7XG4gIC8vIEJsYWtlMmIgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIEJsYWtlMnNfMjU2ID0gXCJHXCI7XG4gIC8vIEJsYWtlMnMgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIFNIQTNfMjU2ID0gXCJIXCI7XG4gIC8vIFNIQTMgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIFNIQTJfMjU2ID0gXCJJXCI7XG4gIC8vIFNIQTIgMjU2IGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIEJsYWtlM181MTIgPSBcIjBEXCI7XG4gIC8vIEJsYWtlMyA1MTIgYml0IGRpZ2VzdCBzZWxmLWFkZHJlc3NpbmcgZGVyaXZhdGlvbi5cbiAgQmxha2UyYl81MTIgPSBcIjBFXCI7XG4gIC8vIEJsYWtlMmIgNTEyIGJpdCBkaWdlc3Qgc2VsZi1hZGRyZXNzaW5nIGRlcml2YXRpb24uXG4gIFNIQTNfNTEyID0gXCIwRlwiO1xuICAvLyBTSEEzIDUxMiBiaXQgZGlnZXN0IHNlbGYtYWRkcmVzc2luZyBkZXJpdmF0aW9uLlxuICBTSEEyXzUxMiA9IFwiMEdcIjtcbiAgLy8gU0hBMiA1MTIgYml0IGRpZ2VzdCBzZWxmLWFkZHJlc3NpbmcgZGVyaXZhdGlvbi5cbn07XG52YXIgRGlnaURleCA9IG5ldyBEaWdpQ29kZXgoKTtcbnZhciBOdW1Db2RleCA9IGNsYXNzIGV4dGVuZHMgQ29kZXgge1xuICBTaG9ydCA9IFwiTVwiO1xuICAvLyBTaG9ydCAyIGJ5dGUgYjIgbnVtYmVyXG4gIExvbmcgPSBcIjBIXCI7XG4gIC8vIExvbmcgNCBieXRlIGIyIG51bWJlclxuICBCaWcgPSBcIk5cIjtcbiAgLy8gQmlnIDggYnl0ZSBiMiBudW1iZXJcbiAgSHVnZSA9IFwiMEFcIjtcbiAgLy8gSHVnZSAxNiBieXRlIGIyIG51bWJlciAoc2FtZSBhcyBTYWx0XzEyOClcbn07XG52YXIgTnVtRGV4ID0gbmV3IE51bUNvZGV4KCk7XG52YXIgQmV4Q29kZXggPSBjbGFzcyBleHRlbmRzIENvZGV4IHtcbiAgU3RyQjY0X0wwID0gXCI0QVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgTGVhZGVyIFNpemUgMFxuICBTdHJCNjRfTDEgPSBcIjVBXCI7XG4gIC8vIFN0cmluZyBCYXNlNjQgT25seSBMZWFkZXIgU2l6ZSAxXG4gIFN0ckI2NF9MMiA9IFwiNkFcIjtcbiAgLy8gU3RyaW5nIEJhc2U2NCBPbmx5IExlYWRlciBTaXplIDJcbiAgU3RyQjY0X0JpZ19MMCA9IFwiN0FBQVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgQmlnIExlYWRlciBTaXplIDBcbiAgU3RyQjY0X0JpZ19MMSA9IFwiOEFBQVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgQmlnIExlYWRlciBTaXplIDFcbiAgU3RyQjY0X0JpZ19MMiA9IFwiOUFBQVwiO1xuICAvLyBTdHJpbmcgQmFzZTY0IE9ubHkgQmlnIExlYWRlciBTaXplIDJcbn07XG52YXIgQmV4RGV4ID0gbmV3IEJleENvZGV4KCk7XG52YXIgU21hbGxWYXJSYXdTaXplQ29kZXggPSBjbGFzcyBleHRlbmRzIENvZGV4IHtcbiAgTGVhZDAgPSBcIjRcIjtcbiAgLy8gRmlyc3QgU2VsZWN0b3IgQ2hhcmFjdGVyIGZvciBhbGwgbHMgPT0gMCBjb2Rlc1xuICBMZWFkMSA9IFwiNVwiO1xuICAvLyBGaXJzdCBTZWxlY3RvciBDaGFyYWN0ZXIgZm9yIGFsbCBscyA9PSAxIGNvZGVzXG4gIExlYWQyID0gXCI2XCI7XG4gIC8vIEZpcnN0IFNlbGVjdG9yIENoYXJhY3RlciBmb3IgYWxsIGxzID09IDIgY29kZXNcbn07XG52YXIgU21hbGxWcnpEZXggPSBuZXcgU21hbGxWYXJSYXdTaXplQ29kZXgoKTtcbnZhciBMYXJnZVZhclJhd1NpemVDb2RleCA9IGNsYXNzIGV4dGVuZHMgQ29kZXgge1xuICBMZWFkMF9CaWcgPSBcIjdcIjtcbiAgLy8gRmlyc3QgU2VsZWN0b3IgQ2hhcmFjdGVyIGZvciBhbGwgbHMgPT0gMCBjb2Rlc1xuICBMZWFkMV9CaWcgPSBcIjhcIjtcbiAgLy8gRmlyc3QgU2VsZWN0b3IgQ2hhcmFjdGVyIGZvciBhbGwgbHMgPT0gMSBjb2Rlc1xuICBMZWFkMl9CaWcgPSBcIjlcIjtcbiAgLy8gRmlyc3QgU2VsZWN0b3IgQ2hhcmFjdGVyIGZvciBhbGwgbHMgPT0gMiBjb2Rlc1xufTtcbnZhciBMYXJnZVZyekRleCA9IG5ldyBMYXJnZVZhclJhd1NpemVDb2RleCgpO1xudmFyIFNpemFnZSA9IGNsYXNzIHtcbiAgaHM7XG4gIHNzO1xuICBscztcbiAgZnM7XG4gIGNvbnN0cnVjdG9yKGhzLCBzcywgZnMsIGxzKSB7XG4gICAgdGhpcy5ocyA9IGhzO1xuICAgIHRoaXMuc3MgPSBzcztcbiAgICB0aGlzLmZzID0gZnM7XG4gICAgdGhpcy5scyA9IGxzO1xuICB9XG59O1xudmFyIE1hdHRlciA9IGNsYXNzIF9NYXR0ZXIge1xuICBzdGF0aWMgU2l6ZXMgPSBuZXcgTWFwKFxuICAgIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIEE6IG5ldyBTaXphZ2UoMSwgMCwgNDQsIDApLFxuICAgICAgQjogbmV3IFNpemFnZSgxLCAwLCA0NCwgMCksXG4gICAgICBDOiBuZXcgU2l6YWdlKDEsIDAsIDQ0LCAwKSxcbiAgICAgIEQ6IG5ldyBTaXphZ2UoMSwgMCwgNDQsIDApLFxuICAgICAgRTogbmV3IFNpemFnZSgxLCAwLCA0NCwgMCksXG4gICAgICBGOiBuZXcgU2l6YWdlKDEsIDAsIDQ0LCAwKSxcbiAgICAgIEc6IG5ldyBTaXphZ2UoMSwgMCwgNDQsIDApLFxuICAgICAgSDogbmV3IFNpemFnZSgxLCAwLCA0NCwgMCksXG4gICAgICBJOiBuZXcgU2l6YWdlKDEsIDAsIDQ0LCAwKSxcbiAgICAgIEo6IG5ldyBTaXphZ2UoMSwgMCwgNDQsIDApLFxuICAgICAgSzogbmV3IFNpemFnZSgxLCAwLCA3NiwgMCksXG4gICAgICBMOiBuZXcgU2l6YWdlKDEsIDAsIDc2LCAwKSxcbiAgICAgIE06IG5ldyBTaXphZ2UoMSwgMCwgNCwgMCksXG4gICAgICBOOiBuZXcgU2l6YWdlKDEsIDAsIDEyLCAwKSxcbiAgICAgIE86IG5ldyBTaXphZ2UoMSwgMCwgNDQsIDApLFxuICAgICAgUDogbmV3IFNpemFnZSgxLCAwLCAxMjQsIDApLFxuICAgICAgUTogbmV3IFNpemFnZSgxLCAwLCA0NCwgMCksXG4gICAgICBcIjBBXCI6IG5ldyBTaXphZ2UoMiwgMCwgMjQsIDApLFxuICAgICAgXCIwQlwiOiBuZXcgU2l6YWdlKDIsIDAsIDg4LCAwKSxcbiAgICAgIFwiMENcIjogbmV3IFNpemFnZSgyLCAwLCA4OCwgMCksXG4gICAgICBcIjBEXCI6IG5ldyBTaXphZ2UoMiwgMCwgODgsIDApLFxuICAgICAgXCIwRVwiOiBuZXcgU2l6YWdlKDIsIDAsIDg4LCAwKSxcbiAgICAgIFwiMEZcIjogbmV3IFNpemFnZSgyLCAwLCA4OCwgMCksXG4gICAgICBcIjBHXCI6IG5ldyBTaXphZ2UoMiwgMCwgODgsIDApLFxuICAgICAgXCIwSFwiOiBuZXcgU2l6YWdlKDIsIDAsIDgsIDApLFxuICAgICAgXCIwSVwiOiBuZXcgU2l6YWdlKDIsIDAsIDg4LCAwKSxcbiAgICAgIFwiMUFBQVwiOiBuZXcgU2l6YWdlKDQsIDAsIDQ4LCAwKSxcbiAgICAgIFwiMUFBQlwiOiBuZXcgU2l6YWdlKDQsIDAsIDQ4LCAwKSxcbiAgICAgIFwiMUFBQ1wiOiBuZXcgU2l6YWdlKDQsIDAsIDgwLCAwKSxcbiAgICAgIFwiMUFBRFwiOiBuZXcgU2l6YWdlKDQsIDAsIDgwLCAwKSxcbiAgICAgIFwiMUFBRVwiOiBuZXcgU2l6YWdlKDQsIDAsIDU2LCAwKSxcbiAgICAgIFwiMUFBRlwiOiBuZXcgU2l6YWdlKDQsIDAsIDgsIDApLFxuICAgICAgXCIxQUFHXCI6IG5ldyBTaXphZ2UoNCwgMCwgMzYsIDApLFxuICAgICAgXCIxQUFIXCI6IG5ldyBTaXphZ2UoNCwgMCwgMTAwLCAwKSxcbiAgICAgIFwiMUFBSVwiOiBuZXcgU2l6YWdlKDQsIDAsIDQ4LCAwKSxcbiAgICAgIFwiMUFBSlwiOiBuZXcgU2l6YWdlKDQsIDAsIDQ4LCAwKSxcbiAgICAgIFwiMkFBQVwiOiBuZXcgU2l6YWdlKDQsIDAsIDgsIDEpLFxuICAgICAgXCIzQUFBXCI6IG5ldyBTaXphZ2UoNCwgMCwgOCwgMiksXG4gICAgICBcIjRBXCI6IG5ldyBTaXphZ2UoMiwgMiwgdm9pZCAwLCAwKSxcbiAgICAgIFwiNUFcIjogbmV3IFNpemFnZSgyLCAyLCB2b2lkIDAsIDEpLFxuICAgICAgXCI2QVwiOiBuZXcgU2l6YWdlKDIsIDIsIHZvaWQgMCwgMiksXG4gICAgICBcIjdBQUFcIjogbmV3IFNpemFnZSg0LCA0LCB2b2lkIDAsIDApLFxuICAgICAgXCI4QUFBXCI6IG5ldyBTaXphZ2UoNCwgNCwgdm9pZCAwLCAxKSxcbiAgICAgIFwiOUFBQVwiOiBuZXcgU2l6YWdlKDQsIDQsIHZvaWQgMCwgMiksXG4gICAgICBcIjRCXCI6IG5ldyBTaXphZ2UoMiwgMiwgdm9pZCAwLCAwKSxcbiAgICAgIFwiNUJcIjogbmV3IFNpemFnZSgyLCAyLCB2b2lkIDAsIDEpLFxuICAgICAgXCI2QlwiOiBuZXcgU2l6YWdlKDIsIDIsIHZvaWQgMCwgMiksXG4gICAgICBcIjdBQUJcIjogbmV3IFNpemFnZSg0LCA0LCB2b2lkIDAsIDApLFxuICAgICAgXCI4QUFCXCI6IG5ldyBTaXphZ2UoNCwgNCwgdm9pZCAwLCAxKSxcbiAgICAgIFwiOUFBQlwiOiBuZXcgU2l6YWdlKDQsIDQsIHZvaWQgMCwgMilcbiAgICB9KVxuICApO1xuICBzdGF0aWMgSGFyZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgW1wiQVwiLCAxXSxcbiAgICBbXCJCXCIsIDFdLFxuICAgIFtcIkNcIiwgMV0sXG4gICAgW1wiRFwiLCAxXSxcbiAgICBbXCJFXCIsIDFdLFxuICAgIFtcIkZcIiwgMV0sXG4gICAgW1wiR1wiLCAxXSxcbiAgICBbXCJIXCIsIDFdLFxuICAgIFtcIklcIiwgMV0sXG4gICAgW1wiSlwiLCAxXSxcbiAgICBbXCJLXCIsIDFdLFxuICAgIFtcIkxcIiwgMV0sXG4gICAgW1wiTVwiLCAxXSxcbiAgICBbXCJOXCIsIDFdLFxuICAgIFtcIk9cIiwgMV0sXG4gICAgW1wiUFwiLCAxXSxcbiAgICBbXCJRXCIsIDFdLFxuICAgIFtcIlJcIiwgMV0sXG4gICAgW1wiU1wiLCAxXSxcbiAgICBbXCJUXCIsIDFdLFxuICAgIFtcIlVcIiwgMV0sXG4gICAgW1wiVlwiLCAxXSxcbiAgICBbXCJXXCIsIDFdLFxuICAgIFtcIlhcIiwgMV0sXG4gICAgW1wiWVwiLCAxXSxcbiAgICBbXCJaXCIsIDFdLFxuICAgIFtcImFcIiwgMV0sXG4gICAgW1wiYlwiLCAxXSxcbiAgICBbXCJjXCIsIDFdLFxuICAgIFtcImRcIiwgMV0sXG4gICAgW1wiZVwiLCAxXSxcbiAgICBbXCJmXCIsIDFdLFxuICAgIFtcImdcIiwgMV0sXG4gICAgW1wiaFwiLCAxXSxcbiAgICBbXCJpXCIsIDFdLFxuICAgIFtcImpcIiwgMV0sXG4gICAgW1wia1wiLCAxXSxcbiAgICBbXCJsXCIsIDFdLFxuICAgIFtcIm1cIiwgMV0sXG4gICAgW1wiblwiLCAxXSxcbiAgICBbXCJvXCIsIDFdLFxuICAgIFtcInBcIiwgMV0sXG4gICAgW1wicVwiLCAxXSxcbiAgICBbXCJyXCIsIDFdLFxuICAgIFtcInNcIiwgMV0sXG4gICAgW1widFwiLCAxXSxcbiAgICBbXCJ1XCIsIDFdLFxuICAgIFtcInZcIiwgMV0sXG4gICAgW1wid1wiLCAxXSxcbiAgICBbXCJ4XCIsIDFdLFxuICAgIFtcInlcIiwgMV0sXG4gICAgW1wielwiLCAxXSxcbiAgICBbXCIwXCIsIDJdLFxuICAgIFtcIjFcIiwgNF0sXG4gICAgW1wiMlwiLCA0XSxcbiAgICBbXCIzXCIsIDRdLFxuICAgIFtcIjRcIiwgMl0sXG4gICAgW1wiNVwiLCAyXSxcbiAgICBbXCI2XCIsIDJdLFxuICAgIFtcIjdcIiwgNF0sXG4gICAgW1wiOFwiLCA0XSxcbiAgICBbXCI5XCIsIDRdXG4gIF0pO1xuICBfY29kZSA9IFwiXCI7XG4gIF9zaXplID0gLTE7XG4gIF9yYXcgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJhdyxcbiAgICBjb2RlID0gTXRyRGV4LkVkMjU1MTlOLFxuICAgIHFiNjRiLFxuICAgIHFiNjQsXG4gICAgcWIyLFxuICAgIHJpemVcbiAgfSkge1xuICAgIGxldCBzaXplID0gLTE7XG4gICAgaWYgKHJhdyAhPSB2b2lkIDApIHtcbiAgICAgIGlmIChjb2RlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkltcHJvcGVyIGluaXRpYWxpemF0aW9uIG5lZWQgZWl0aGVyIChyYXcgYW5kIGNvZGUpIG9yIHFiNjRiIG9yIHFiNjQgb3IgcWIyLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoU21hbGxWcnpEZXguaGFzKGNvZGVbMF0pIHx8IExhcmdlVnJ6RGV4Lmhhcyhjb2RlWzBdKSkge1xuICAgICAgICBpZiAocml6ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKHJpemUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgbWlzc2luZyB2YXIgcmF3IHNpemUgZm9yIGNvZGU9JHtjb2RlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcml6ZSA9IHJhdy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHMgPSAoMyAtIHJpemUgJSAzKSAlIDM7XG4gICAgICAgIHNpemUgPSBNYXRoLmZsb29yKChyaXplICsgbHMpIC8gMyk7XG4gICAgICAgIGlmIChTbWFsbFZyekRleC5oYXMoY29kZVswXSkpIHtcbiAgICAgICAgICBpZiAoc2l6ZSA8PSA2NCAqKiAyIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgaHMgPSAyO1xuICAgICAgICAgICAgY29uc3QgcyA9IE9iamVjdC52YWx1ZXMoU21hbGxWcnpEZXgpW2xzXTtcbiAgICAgICAgICAgIGNvZGUgPSBgJHtzfSR7Y29kZS5zdWJzdHJpbmcoMSwgaHMpfWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChzaXplIDw9IDY0ICoqIDQgLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBocyA9IDQ7XG4gICAgICAgICAgICBjb25zdCBzID0gT2JqZWN0LnZhbHVlcyhMYXJnZVZyekRleClbbHNdO1xuICAgICAgICAgICAgY29kZSA9IGAke3N9JHtcIkFBQUFcIi5zdWJzdHJpbmcoMCwgaHMgLSAyKX0ke2NvZGVbMV19YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgcmF3IHNpemUgZm9yIGNvZGU9JHtjb2RlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaXplIDw9IDY0ICoqIDQgLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBocyA9IDQ7XG4gICAgICAgICAgICBjb25zdCBzID0gT2JqZWN0LnZhbHVlcyhMYXJnZVZyekRleClbbHNdO1xuICAgICAgICAgICAgY29kZSA9IGAke3N9JHtjb2RlLnN1YnN0cmluZygxLCBocyl9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgcmF3IHNpemUgZm9yIGNvZGU9JHtjb2RlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaXphZ2UgPSBfTWF0dGVyLlNpemVzLmdldChjb2RlKTtcbiAgICAgICAgaWYgKHNpemFnZS5mcyA9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdmFyaWFibGUgc2l6ZSBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByaXplID0gX01hdHRlci5fcmF3U2l6ZShjb2RlKTtcbiAgICAgIH1cbiAgICAgIHJhdyA9IHJhdy5zbGljZSgwLCByaXplKTtcbiAgICAgIGlmIChyYXcubGVuZ3RoICE9IHJpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBOb3QgZW5vdWd0aCByYXcgYnl0ZXMgZm9yIGNvZGU9JHtjb2RlfSBleHBlY3RlZCAke3JpemV9IGdvdCAke3Jhdy5sZW5ndGh9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvZGUgPSBjb2RlO1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLl9yYXcgPSByYXc7XG4gICAgfSBlbHNlIGlmIChxYjY0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2V4ZmlsKHFiNjQpO1xuICAgIH0gZWxzZSBpZiAocWI2NGIgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcWI2NDIgPSBkKHFiNjRiKTtcbiAgICAgIHRoaXMuX2V4ZmlsKHFiNjQyKTtcbiAgICB9IGVsc2UgaWYgKHFiMiAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9iZXhmaWwocWIyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVtcHR5TWF0ZXJpYWxFcnJvcihcIkVtcHR5TWF0ZXJpYWxFcnJvclwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvZGU7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cbiAgZ2V0IHJhdygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3O1xuICB9XG4gIGdldCBxYjY0KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZpbCgpO1xuICB9XG4gIGdldCBxYjY0YigpIHtcbiAgICByZXR1cm4gYih0aGlzLnFiNjQpO1xuICB9XG4gIGdldCB0cmFuc2ZlcmFibGUoKSB7XG4gICAgcmV0dXJuICFOb25UcmFuc0RleC5oYXModGhpcy5jb2RlKTtcbiAgfVxuICBnZXQgZGlnZXN0aXZlKCkge1xuICAgIHJldHVybiBEaWdpRGV4Lmhhcyh0aGlzLmNvZGUpO1xuICB9XG4gIHN0YXRpYyBfcmF3U2l6ZShjb2RlKSB7XG4gICAgY29uc3Qgc2l6YWdlID0gdGhpcy5TaXplcy5nZXQoY29kZSk7XG4gICAgY29uc3QgY3MgPSBzaXphZ2UuaHMgKyBzaXphZ2Uuc3M7XG4gICAgaWYgKHNpemFnZS5mcyA9PT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKGBOb24tZml4ZWQgcmF3IHNpemUgY29kZSAke2NvZGV9LmApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcigoc2l6YWdlLmZzIC0gY3MpICogMyAvIDQpIC0gc2l6YWdlLmxzO1xuICB9XG4gIHN0YXRpYyBfbGVhZFNpemUoY29kZSkge1xuICAgIGNvbnN0IHNpemFnZSA9IHRoaXMuU2l6ZXMuZ2V0KGNvZGUpO1xuICAgIHJldHVybiBzaXphZ2UubHM7XG4gIH1cbiAgZ2V0IGJvdGgoKSB7XG4gICAgY29uc3Qgc2l6YWdlID0gX01hdHRlci5TaXplcy5nZXQodGhpcy5jb2RlKTtcbiAgICByZXR1cm4gYCR7dGhpcy5jb2RlfSR7aW50VG9CNjQodGhpcy5zaXplLCBzaXphZ2Uuc3MpfWA7XG4gIH1cbiAgX2luZmlsKCkge1xuICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCByYXcgPSB0aGlzLnJhdztcbiAgICBjb25zdCBwcyA9ICgzIC0gcmF3Lmxlbmd0aCAlIDMpICUgMztcbiAgICBjb25zdCBzaXphZ2UgPSBfTWF0dGVyLlNpemVzLmdldChjb2RlKTtcbiAgICBpZiAoc2l6YWdlLmZzID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGNzID0gc2l6YWdlLmhzICsgc2l6YWdlLnNzO1xuICAgICAgaWYgKGNzICUgNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFdob2xlIGNvZGUgc2l6ZSBub3QgbXVsdGlwbGUgb2YgNCBmb3IgdmFyaWFibGUgbGVuZ3RoIG1hdGVyaWFsLiBjcz0ke2NzfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaXplIDwgMCB8fCBzaXplID4gNjQgKiogc2l6YWdlLnNzIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2l6ZT0ke3NpemV9IGZvciBjb2RlPSR7Y29kZX0uYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBib3RoID0gYCR7Y29kZX0ke2ludFRvQjY0KHNpemUsIHNpemFnZS5zcyl9YDtcbiAgICAgIGlmIChib3RoLmxlbmd0aCAlIDQgIT09IHBzIC0gc2l6YWdlLmxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBjb2RlPSR7Ym90aH0gZm9yIGNvbnZlcnRlZCByYXcgcGFkIHNpemU9JHtwc30uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXphZ2UubHMgKyByYXcubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6YWdlLmxzOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2R4ID0gaSArIHBzO1xuICAgICAgICBieXRlc1tvZHhdID0gcmF3W2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJvdGggKyBlbmNvZGVCYXNlNjRVcmwoQnVmZmVyMy5mcm9tKGJ5dGVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJvdGggPSBjb2RlO1xuICAgICAgY29uc3QgY3MgPSBib3RoLmxlbmd0aDtcbiAgICAgIGlmIChjcyAlIDQgIT0gcHMgLSBzaXphZ2UubHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGNvZGU9JHtib3RofSBmb3IgY29udmVydGVkIHJhdyBwYWQgc2l6ZT0ke3BzfSwgJHtyYXcubGVuZ3RofS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHBzICsgcmF3Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBzOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2R4ID0gaSArIHBzO1xuICAgICAgICBieXRlc1tvZHhdID0gcmF3W2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJvdGggKyBlbmNvZGVCYXNlNjRVcmwoQnVmZmVyMy5mcm9tKGJ5dGVzKSkuc2xpY2UoY3MgJSA0KTtcbiAgICB9XG4gIH1cbiAgX2V4ZmlsKHFiNjQpIHtcbiAgICBpZiAocWI2NC5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgTWF0ZXJpYWxcIik7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gcWI2NFswXTtcbiAgICBpZiAoIUFycmF5LmZyb20oX01hdHRlci5IYXJkcy5rZXlzKCkpLmluY2x1ZGVzKGZpcnN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGNvZGUgJHtmaXJzdH1gKTtcbiAgICB9XG4gICAgY29uc3QgaHMgPSBfTWF0dGVyLkhhcmRzLmdldChmaXJzdCk7XG4gICAgaWYgKHFiNjQubGVuZ3RoIDwgaHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2hvcnRhZ2UgRXJyb3JgKTtcbiAgICB9XG4gICAgY29uc3QgaGFyZCA9IHFiNjQuc2xpY2UoMCwgaHMpO1xuICAgIGlmICghQXJyYXkuZnJvbShfTWF0dGVyLlNpemVzLmtleXMoKSkuaW5jbHVkZXMoaGFyZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29kZSAke2hhcmR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHNpemFnZSA9IF9NYXR0ZXIuU2l6ZXMuZ2V0KGhhcmQpO1xuICAgIGNvbnN0IGNzID0gc2l6YWdlLmhzICsgc2l6YWdlLnNzO1xuICAgIGxldCBzaXplID0gLTE7XG4gICAgaWYgKHNpemFnZS5mcyA9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgc2l6ZSBjb2RlcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IHNpemFnZS5mcztcbiAgICB9XG4gICAgaWYgKHFiNjQubGVuZ3RoIDwgc2l6YWdlLmZzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lZWQgJHtzaXphZ2UuZnMgLSBxYjY0Lmxlbmd0aH0gbW9yZSBjaGFycy5gKTtcbiAgICB9XG4gICAgcWI2NCA9IHFiNjQuc2xpY2UoMCwgc2l6YWdlLmZzKTtcbiAgICBjb25zdCBwcyA9IGNzICUgNDtcbiAgICBjb25zdCBwYnMgPSAyICogKHBzID09IDAgPyBzaXphZ2UubHMgOiBwcyk7XG4gICAgbGV0IHJhdztcbiAgICBpZiAocHMgIT0gMCkge1xuICAgICAgY29uc3QgYmFzZSA9IG5ldyBBcnJheShwcyArIDEpLmpvaW4oXCJBXCIpICsgcWI2NC5zbGljZShjcyk7XG4gICAgICBjb25zdCBwYXcgPSBkZWNvZGVCYXNlNjRVcmwoYmFzZSk7XG4gICAgICBjb25zdCBwaSA9IHJlYWRJbnQocGF3LnN1YmFycmF5KDAsIHBzKSk7XG4gICAgICBpZiAocGkgJiAyICoqIHBicyAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBOb24gemVyb2VkIHByZXBhZCBiaXRzID0ge3BpICYgKDIgKiogcGJzIC0gMSApOjwwNmJ9IGluIHtxYjY0YltjczpjcysxXX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmF3ID0gcGF3LnN1YmFycmF5KHBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZSA9IHFiNjQuc2xpY2UoY3MpO1xuICAgICAgY29uc3QgcGF3ID0gZGVjb2RlQmFzZTY0VXJsKGJhc2UpO1xuICAgICAgY29uc3QgbGkgPSByZWFkSW50KHBhdy5zdWJhcnJheSgwLCBzaXphZ2UubHMpKTtcbiAgICAgIGlmIChsaSAhPSAwKSB7XG4gICAgICAgIGlmIChsaSA9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24gemVyb2VkIGxlYWQgYnl0ZSA9IDB4e2xpOjAyeH0uYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24gemVyb2VkIGxlYWQgYnl0ZXMgPSAweHtsaTowNHh9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJhdyA9IHBhdy5zdWJhcnJheShzaXphZ2UubHMpO1xuICAgIH1cbiAgICB0aGlzLl9jb2RlID0gaGFyZDtcbiAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB0aGlzLl9yYXcgPSBVaW50OEFycmF5LmZyb20ocmF3KTtcbiAgfVxuICBfYmV4ZmlsKHFiMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcWIyIG5vdCB5ZXQgc3VwcG9ydGVkOiAke3FiMn1gKTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS92ZXJmZXIudHNcbmltcG9ydCBsaWJzb2RpdW0gZnJvbSBcImxpYnNvZGl1bS13cmFwcGVycy1zdW1vXCI7XG5pbXBvcnQgc2VjcDI1NnIxIGZyb20gXCJlY2RzYS1zZWNwMjU2cjFcIjtcbnZhciBWZXJmZXIgPSBjbGFzcyBleHRlbmRzIE1hdHRlciB7XG4gIF92ZXJpZnk7XG4gIGNvbnN0cnVjdG9yKHsgcmF3LCBjb2RlLCBxYjY0LCBxYjY0YiwgcWIyIH0pIHtcbiAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9KTtcbiAgICBpZiAoQXJyYXkuZnJvbShbTXRyRGV4LkVkMjU1MTlOLCBNdHJEZXguRWQyNTUxOV0pLmluY2x1ZGVzKHRoaXMuY29kZSkpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeSA9IHRoaXMuX2VkMjU1MTk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5mcm9tKFtNdHJEZXguRUNEU0FfMjU2cjFOLCBNdHJEZXguRUNEU0FfMjU2cjFdKS5pbmNsdWRlcyhcbiAgICAgIHRoaXMuY29kZVxuICAgICkpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeSA9IHRoaXMuX3NlY3AyNTZyMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb2RlID0gJHt0aGlzLmNvZGV9IGZvciB2ZXJpZmllci5gKTtcbiAgICB9XG4gIH1cbiAgdmVyaWZ5KHNpZywgc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcmlmeShzaWcsIHNlciwgdGhpcy5yYXcpO1xuICB9XG4gIF9lZDI1NTE5KHNpZywgc2VyLCBrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxpYnNvZGl1bS5jcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWQoc2lnLCBzZXIsIGtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIF9zZWNwMjU2cjEoc2lnLCBzZXIsIGtleSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNwMjU2cjEuZnJvbUNvbXByZXNzZWRQdWJsaWNLZXkoa2V5KTtcbiAgICAgIHJldHVybiBwdWJsaWNLZXkudmVyaWZ5KHNlciwgc2lnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2NvcmUvc2lnbmVyLnRzXG5pbXBvcnQgbGlic29kaXVtMiBmcm9tIFwibGlic29kaXVtLXdyYXBwZXJzLXN1bW9cIjtcblxuLy8gc3JjL2tlcmkvY29yZS9jaWdhci50c1xudmFyIENpZ2FyID0gY2xhc3MgZXh0ZW5kcyBNYXR0ZXIge1xuICBfdmVyZmVyO1xuICBjb25zdHJ1Y3Rvcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9LCB2ZXJmZXIpIHtcbiAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9KTtcbiAgICB0aGlzLl92ZXJmZXIgPSB2ZXJmZXI7XG4gIH1cbiAgZ2V0IHZlcmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyZmVyO1xuICB9XG4gIHNldCB2ZXJmZXIodmVyZmVyKSB7XG4gICAgdGhpcy5fdmVyZmVyID0gdmVyZmVyO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL2luZGV4ZXIudHNcbmltcG9ydCB7IEJ1ZmZlciBhcyBCdWZmZXI0IH0gZnJvbSBcImJ1ZmZlclwiO1xudmFyIEluZGV4ZXJDb2RleCA9IGNsYXNzIHtcbiAgRWQyNTUxOV9TaWcgPSBcIkFcIjtcbiAgLy8gRWQyNTUxOSBzaWcgYXBwZWFycyBzYW1lIGluIGJvdGggbGlzdHMgaWYgYW55LlxuICBFZDI1NTE5X0NydF9TaWcgPSBcIkJcIjtcbiAgLy8gRWQyNTUxOSBzaWcgYXBwZWFycyBpbiBjdXJyZW50IGxpc3Qgb25seS5cbiAgRUNEU0FfMjU2azFfU2lnID0gXCJDXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZrMSBzaWcgYXBwZWFycyBzYW1lIGluIGJvdGggbGlzdHMgaWYgYW55LlxuICBFQ0RTQV8yNTZrMV9DcnRfU2lnID0gXCJEXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZrMSBzaWcgYXBwZWFycyBpbiBjdXJyZW50IGxpc3QuXG4gIEVDRFNBXzI1NnIxX1NpZyA9IFwiRVwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2cjEgc2lnIGFwcGVhcnMgc2FtZSBpbiBib3RoIGxpc3RzIGlmIGFueS5cbiAgRUNEU0FfMjU2cjFfQ3J0X1NpZyA9IFwiRlwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2cjEgc2lnIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0LlxuICBFZDQ0OF9TaWcgPSBcIjBBXCI7XG4gIC8vIEVkNDQ4IHNpZ25hdHVyZSBhcHBlYXJzIGluIGJvdGggbGlzdHMuXG4gIEVkNDQ4X0NydF9TaWcgPSBcIjBCXCI7XG4gIC8vIEVkNDQ4IHNpZ25hdHVyZSBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFZDI1NTE5X0JpZ19TaWcgPSBcIjJBXCI7XG4gIC8vIEVkMjU1MTkgc2lnIGFwcGVhcnMgaW4gYm90aCBsaXN0cy5cbiAgRWQyNTUxOV9CaWdfQ3J0X1NpZyA9IFwiMkJcIjtcbiAgLy8gRWQyNTUxOSBzaWcgYXBwZWFycyBpbiBjdXJyZW50IGxpc3Qgb25seS5cbiAgRUNEU0FfMjU2azFfQmlnX1NpZyA9IFwiMkNcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NmsxIHNpZyBhcHBlYXJzIGluIGJvdGggbGlzdHMuXG4gIEVDRFNBXzI1NmsxX0JpZ19DcnRfU2lnID0gXCIyRFwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2azEgc2lnIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0IG9ubHkuXG4gIEVDRFNBXzI1NnIxX0JpZ19TaWcgPSBcIjJFXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZyMSBzaWcgYXBwZWFycyBpbiBib3RoIGxpc3RzLlxuICBFQ0RTQV8yNTZyMV9CaWdfQ3J0X1NpZyA9IFwiMkZcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NnIxIHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFZDQ0OF9CaWdfU2lnID0gXCIzQVwiO1xuICAvLyBFZDQ0OCBzaWduYXR1cmUgYXBwZWFycyBpbiBib3RoIGxpc3RzLlxuICBFZDQ0OF9CaWdfQ3J0X1NpZyA9IFwiM0JcIjtcbiAgLy8gRWQ0NDggc2lnbmF0dXJlIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0IG9ubHkuXG59O1xudmFyIElkckRleCA9IG5ldyBJbmRleGVyQ29kZXgoKTtcbnZhciBJbmRleGVkU2lnQ29kZXggPSBjbGFzcyB7XG4gIEVkMjU1MTlfU2lnID0gXCJBXCI7XG4gIC8vIEVkMjU1MTkgc2lnIGFwcGVhcnMgc2FtZSBpbiBib3RoIGxpc3RzIGlmIGFueS5cbiAgRWQyNTUxOV9DcnRfU2lnID0gXCJCXCI7XG4gIC8vIEVkMjU1MTkgc2lnIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0IG9ubHkuXG4gIEVDRFNBXzI1NmsxX1NpZyA9IFwiQ1wiO1xuICAvLyBFQ0RTQSBzZWNwMjU2azEgc2lnIGFwcGVhcnMgc2FtZSBpbiBib3RoIGxpc3RzIGlmIGFueS5cbiAgRUNEU0FfMjU2azFfQ3J0X1NpZyA9IFwiRFwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2azEgc2lnIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0LlxuICBFQ0RTQV8yNTZyMV9TaWcgPSBcIkVcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NnIxIHNpZyBhcHBlYXJzIHNhbWUgaW4gYm90aCBsaXN0cyBpZiBhbnkuXG4gIEVDRFNBXzI1NnIxX0NydF9TaWcgPSBcIkZcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NnIxIHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdC5cbiAgRWQ0NDhfU2lnID0gXCIwQVwiO1xuICAvLyBFZDQ0OCBzaWduYXR1cmUgYXBwZWFycyBpbiBib3RoIGxpc3RzLlxuICBFZDQ0OF9DcnRfU2lnID0gXCIwQlwiO1xuICAvLyBFZDQ0OCBzaWduYXR1cmUgYXBwZWFycyBpbiBjdXJyZW50IGxpc3Qgb25seS5cbiAgRWQyNTUxOV9CaWdfU2lnID0gXCIyQVwiO1xuICAvLyBFZDI1NTE5IHNpZyBhcHBlYXJzIGluIGJvdGggbGlzdHMuXG4gIEVkMjU1MTlfQmlnX0NydF9TaWcgPSBcIjJCXCI7XG4gIC8vIEVkMjU1MTkgc2lnIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0IG9ubHkuXG4gIEVDRFNBXzI1NmsxX0JpZ19TaWcgPSBcIjJDXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZrMSBzaWcgYXBwZWFycyBpbiBib3RoIGxpc3RzLlxuICBFQ0RTQV8yNTZrMV9CaWdfQ3J0X1NpZyA9IFwiMkRcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NmsxIHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFQ0RTQV8yNTZyMV9CaWdfU2lnID0gXCIyRVwiO1xuICAvLyBFQ0RTQSBzZWNwMjU2cjEgc2lnIGFwcGVhcnMgaW4gYm90aCBsaXN0cy5cbiAgRUNEU0FfMjU2cjFfQmlnX0NydF9TaWcgPSBcIjJGXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZyMSBzaWcgYXBwZWFycyBpbiBjdXJyZW50IGxpc3Qgb25seS5cbiAgRWQ0NDhfQmlnX1NpZyA9IFwiM0FcIjtcbiAgLy8gRWQ0NDggc2lnbmF0dXJlIGFwcGVhcnMgaW4gYm90aCBsaXN0cy5cbiAgRWQ0NDhfQmlnX0NydF9TaWcgPSBcIjNCXCI7XG4gIC8vIEVkNDQ4IHNpZ25hdHVyZSBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBoYXMocHJvcCkge1xuICAgIGNvbnN0IG0gPSBuZXcgTWFwKFxuICAgICAgQXJyYXkuZnJvbShPYmplY3QuZW50cmllcyh0aGlzKSwgKHYpID0+IFt2WzFdLCB2WzBdXSlcbiAgICApO1xuICAgIHJldHVybiBtLmhhcyhwcm9wKTtcbiAgfVxufTtcbnZhciBJZHhTaWdEZXggPSBuZXcgSW5kZXhlZFNpZ0NvZGV4KCk7XG52YXIgSW5kZXhlZEN1cnJlbnRTaWdDb2RleCA9IGNsYXNzIHtcbiAgRWQyNTUxOV9DcnRfU2lnID0gXCJCXCI7XG4gIC8vIEVkMjU1MTkgc2lnIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0IG9ubHkuXG4gIEVDRFNBXzI1NmsxX0NydF9TaWcgPSBcIkRcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NmsxIHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFQ0RTQV8yNTZyMV9DcnRfU2lnID0gXCJGXCI7XG4gIC8vIEVDRFNBIHNlY3AyNTZyMSBzaWcgYXBwZWFycyBpbiBjdXJyZW50IGxpc3QuXG4gIEVkNDQ4X0NydF9TaWcgPSBcIjBCXCI7XG4gIC8vIEVkNDQ4IHNpZ25hdHVyZSBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFZDI1NTE5X0JpZ19DcnRfU2lnID0gXCIyQlwiO1xuICAvLyBFZDI1NTE5IHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFQ0RTQV8yNTZrMV9CaWdfQ3J0X1NpZyA9IFwiMkRcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NmsxIHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFQ0RTQV8yNTZyMV9CaWdfQ3J0X1NpZyA9IFwiMkZcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NnIxIHNpZyBhcHBlYXJzIGluIGN1cnJlbnQgbGlzdCBvbmx5LlxuICBFZDQ0OF9CaWdfQ3J0X1NpZyA9IFwiM0JcIjtcbiAgLy8gRWQ0NDggc2lnbmF0dXJlIGFwcGVhcnMgaW4gY3VycmVudCBsaXN0IG9ubHkuXG4gIGhhcyhwcm9wKSB7XG4gICAgY29uc3QgbSA9IG5ldyBNYXAoXG4gICAgICBBcnJheS5mcm9tKE9iamVjdC5lbnRyaWVzKHRoaXMpLCAodikgPT4gW3ZbMV0sIHZbMF1dKVxuICAgICk7XG4gICAgcmV0dXJuIG0uaGFzKHByb3ApO1xuICB9XG59O1xudmFyIElkeENydFNpZ0RleCA9IG5ldyBJbmRleGVkQ3VycmVudFNpZ0NvZGV4KCk7XG52YXIgSW5kZXhlZEJvdGhTaWdDb2RleCA9IGNsYXNzIHtcbiAgRWQyNTUxOV9TaWcgPSBcIkFcIjtcbiAgLy8gRWQyNTUxOSBzaWcgYXBwZWFycyBzYW1lIGluIGJvdGggbGlzdHMgaWYgYW55LlxuICBFQ0RTQV8yNTZrMV9TaWcgPSBcIkNcIjtcbiAgLy8gRUNEU0Egc2VjcDI1NmsxIHNpZyBhcHBlYXJzIHNhbWUgaW4gYm90aCBsaXN0cyBpZiBhbnkuXG4gIEVkNDQ4X1NpZyA9IFwiMEFcIjtcbiAgLy8gRWQ0NDggc2lnbmF0dXJlIGFwcGVhcnMgaW4gYm90aCBsaXN0cy5cbiAgRWQyNTUxOV9CaWdfU2lnID0gXCIyQVwiO1xuICAvLyBFZDI1NTE5IHNpZyBhcHBlYXJzIGluIGJvdGggbGlzdHN5LlxuICBFQ0RTQV8yNTZrMV9CaWdfU2lnID0gXCIyQ1wiO1xuICAvLyBFQ0RTQSBzZWNwMjU2azEgc2lnIGFwcGVhcnMgaW4gYm90aCBsaXN0cy5cbiAgRWQ0NDhfQmlnX1NpZyA9IFwiM0FcIjtcbiAgLy8gRWQ0NDggc2lnbmF0dXJlIGFwcGVhcnMgaW4gYm90aCBsaXN0cy5cbiAgaGFzKHByb3ApIHtcbiAgICBjb25zdCBtID0gbmV3IE1hcChcbiAgICAgIEFycmF5LmZyb20oT2JqZWN0LmVudHJpZXModGhpcyksICh2KSA9PiBbdlsxXSwgdlswXV0pXG4gICAgKTtcbiAgICByZXR1cm4gbS5oYXMocHJvcCk7XG4gIH1cbn07XG52YXIgSWR4QnRoU2lnRGV4ID0gbmV3IEluZGV4ZWRCb3RoU2lnQ29kZXgoKTtcbnZhciBYaXphZ2UgPSBjbGFzcyB7XG4gIGhzO1xuICBzcztcbiAgb3M7XG4gIGZzO1xuICBscztcbiAgY29uc3RydWN0b3IoaHMsIHNzLCBvcywgZnMsIGxzKSB7XG4gICAgdGhpcy5ocyA9IGhzO1xuICAgIHRoaXMuc3MgPSBzcztcbiAgICB0aGlzLm9zID0gb3M7XG4gICAgdGhpcy5mcyA9IGZzO1xuICAgIHRoaXMubHMgPSBscztcbiAgfVxufTtcbnZhciBJbmRleGVyID0gY2xhc3MgX0luZGV4ZXIge1xuICBDb2RleCA9IElkckRleDtcbiAgc3RhdGljIEhhcmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtcIkFcIiwgMV0sXG4gICAgW1wiQlwiLCAxXSxcbiAgICBbXCJDXCIsIDFdLFxuICAgIFtcIkRcIiwgMV0sXG4gICAgW1wiRVwiLCAxXSxcbiAgICBbXCJGXCIsIDFdLFxuICAgIFtcIkdcIiwgMV0sXG4gICAgW1wiSFwiLCAxXSxcbiAgICBbXCJJXCIsIDFdLFxuICAgIFtcIkpcIiwgMV0sXG4gICAgW1wiS1wiLCAxXSxcbiAgICBbXCJMXCIsIDFdLFxuICAgIFtcIk1cIiwgMV0sXG4gICAgW1wiTlwiLCAxXSxcbiAgICBbXCJPXCIsIDFdLFxuICAgIFtcIlBcIiwgMV0sXG4gICAgW1wiUVwiLCAxXSxcbiAgICBbXCJSXCIsIDFdLFxuICAgIFtcIlNcIiwgMV0sXG4gICAgW1wiVFwiLCAxXSxcbiAgICBbXCJVXCIsIDFdLFxuICAgIFtcIlZcIiwgMV0sXG4gICAgW1wiV1wiLCAxXSxcbiAgICBbXCJYXCIsIDFdLFxuICAgIFtcIllcIiwgMV0sXG4gICAgW1wiWlwiLCAxXSxcbiAgICBbXCJhXCIsIDFdLFxuICAgIFtcImJcIiwgMV0sXG4gICAgW1wiY1wiLCAxXSxcbiAgICBbXCJkXCIsIDFdLFxuICAgIFtcImVcIiwgMV0sXG4gICAgW1wiZlwiLCAxXSxcbiAgICBbXCJnXCIsIDFdLFxuICAgIFtcImhcIiwgMV0sXG4gICAgW1wiaVwiLCAxXSxcbiAgICBbXCJqXCIsIDFdLFxuICAgIFtcImtcIiwgMV0sXG4gICAgW1wibFwiLCAxXSxcbiAgICBbXCJtXCIsIDFdLFxuICAgIFtcIm5cIiwgMV0sXG4gICAgW1wib1wiLCAxXSxcbiAgICBbXCJwXCIsIDFdLFxuICAgIFtcInFcIiwgMV0sXG4gICAgW1wiclwiLCAxXSxcbiAgICBbXCJzXCIsIDFdLFxuICAgIFtcInRcIiwgMV0sXG4gICAgW1widVwiLCAxXSxcbiAgICBbXCJ2XCIsIDFdLFxuICAgIFtcIndcIiwgMV0sXG4gICAgW1wieFwiLCAxXSxcbiAgICBbXCJ5XCIsIDFdLFxuICAgIFtcInpcIiwgMV0sXG4gICAgW1wiMFwiLCAyXSxcbiAgICBbXCIxXCIsIDJdLFxuICAgIFtcIjJcIiwgMl0sXG4gICAgW1wiM1wiLCAyXSxcbiAgICBbXCI0XCIsIDJdXG4gIF0pO1xuICBzdGF0aWMgU2l6ZXMgPSBuZXcgTWFwKFxuICAgIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIEE6IG5ldyBYaXphZ2UoMSwgMSwgMCwgODgsIDApLFxuICAgICAgQjogbmV3IFhpemFnZSgxLCAxLCAwLCA4OCwgMCksXG4gICAgICBDOiBuZXcgWGl6YWdlKDEsIDEsIDAsIDg4LCAwKSxcbiAgICAgIEQ6IG5ldyBYaXphZ2UoMSwgMSwgMCwgODgsIDApLFxuICAgICAgRTogbmV3IFhpemFnZSgxLCAxLCAwLCA4OCwgMCksXG4gICAgICBGOiBuZXcgWGl6YWdlKDEsIDEsIDAsIDg4LCAwKSxcbiAgICAgIFwiMEFcIjogbmV3IFhpemFnZSgyLCAyLCAxLCAxNTYsIDApLFxuICAgICAgXCIwQlwiOiBuZXcgWGl6YWdlKDIsIDIsIDEsIDE1NiwgMCksXG4gICAgICBcIjJBXCI6IG5ldyBYaXphZ2UoMiwgNCwgMiwgOTIsIDApLFxuICAgICAgXCIyQlwiOiBuZXcgWGl6YWdlKDIsIDQsIDIsIDkyLCAwKSxcbiAgICAgIFwiMkNcIjogbmV3IFhpemFnZSgyLCA0LCAyLCA5MiwgMCksXG4gICAgICBcIjJEXCI6IG5ldyBYaXphZ2UoMiwgNCwgMiwgOTIsIDApLFxuICAgICAgXCIyRVwiOiBuZXcgWGl6YWdlKDIsIDQsIDIsIDkyLCAwKSxcbiAgICAgIFwiMkZcIjogbmV3IFhpemFnZSgyLCA0LCAyLCA5MiwgMCksXG4gICAgICBcIjNBXCI6IG5ldyBYaXphZ2UoMiwgNiwgMywgMTYwLCAwKSxcbiAgICAgIFwiM0JcIjogbmV3IFhpemFnZSgyLCA2LCAzLCAxNjAsIDApLFxuICAgICAgXCIwelwiOiBuZXcgWGl6YWdlKDIsIDIsIDAsIHZvaWQgMCwgMCksXG4gICAgICBcIjF6XCI6IG5ldyBYaXphZ2UoMiwgMiwgMSwgNzYsIDEpLFxuICAgICAgXCI0elwiOiBuZXcgWGl6YWdlKDIsIDYsIDMsIDgwLCAxKVxuICAgIH0pXG4gICk7XG4gIF9jb2RlID0gXCJcIjtcbiAgX2luZGV4ID0gLTE7XG4gIF9vbmRleDtcbiAgX3JhdyA9IG5ldyBVaW50OEFycmF5KDApO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmF3ID0gdm9pZCAwLFxuICAgIGNvZGUgPSBJZHJEZXguRWQyNTUxOV9TaWcsXG4gICAgaW5kZXggPSAwLFxuICAgIG9uZGV4ID0gdm9pZCAwLFxuICAgIHFiNjRiID0gdm9pZCAwLFxuICAgIHFiNjQgPSB2b2lkIDAsXG4gICAgcWIyID0gdm9pZCAwXG4gIH0pIHtcbiAgICBpZiAocmF3ICE9IHZvaWQgMCkge1xuICAgICAgaWYgKGNvZGUgPT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFbXB0eU1hdGVyaWFsRXJyb3IoXG4gICAgICAgICAgYEltcHJvcGVyIGluaXRpYWxpemF0aW9uIG5lZWQgZWl0aGVyIChyYXcgYW5kIGNvZGUpIG9yIHFiNjRiIG9yIHFiNjQgb3IgcWIyLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghX0luZGV4ZXIuU2l6ZXMuaGFzKGNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29kZT0ke2NvZGV9LmApO1xuICAgICAgfVxuICAgICAgY29uc3QgeGl6YWdlID0gX0luZGV4ZXIuU2l6ZXMuZ2V0KGNvZGUpO1xuICAgICAgY29uc3Qgb3MgPSB4aXphZ2Uub3M7XG4gICAgICBjb25zdCBmcyA9IHhpemFnZS5mcztcbiAgICAgIGNvbnN0IGNzID0geGl6YWdlLmhzICsgeGl6YWdlLnNzO1xuICAgICAgY29uc3QgbXMgPSB4aXphZ2Uuc3MgLSB4aXphZ2Uub3M7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+IDY0ICoqIG1zIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5kZXg9JHtpbmRleH0gZm9yIGNvZGU9JHtjb2RlfS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbmRleCAhPSB2b2lkIDAgJiYgeGl6YWdlLm9zICE9IDAgJiYgIShvbmRleCA+PSAwICYmIG9uZGV4IDw9IDY0ICoqIG9zIC0gMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9uZGV4PSR7b25kZXh9IGZvciBjb2RlPSR7Y29kZX0uYCk7XG4gICAgICB9XG4gICAgICBpZiAoSWR4Q3J0U2lnRGV4Lmhhcyhjb2RlKSAmJiBvbmRleCAhPSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24gTm9uZSBvbmRleD0ke29uZGV4fSBmb3IgY29kZT0ke2NvZGV9LmApO1xuICAgICAgfVxuICAgICAgaWYgKElkeEJ0aFNpZ0RleC5oYXMoY29kZSkpIHtcbiAgICAgICAgaWYgKG9uZGV4ID09IHZvaWQgMCkge1xuICAgICAgICAgIG9uZGV4ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9uZGV4ICE9IGluZGV4ICYmIG9zID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYE5vbiBtYXRjaGluZyBvbmRleD0ke29uZGV4fSBhbmQgaW5kZXg9JHtpbmRleH0gZm9yIGNvZGU9JHtjb2RlfS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZzID09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpYWJsZSBsZW5ndGggdW5zdXBwb3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByYXdzaXplID0gTWF0aC5mbG9vcigoZnMgLSBjcykgKiAzIC8gNCk7XG4gICAgICByYXcgPSByYXcuc2xpY2UoMCwgcmF3c2l6ZSk7XG4gICAgICBpZiAocmF3Lmxlbmd0aCAhPSByYXdzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgTm90IGVub3VndGggcmF3IGJ5dGVzIGZvciBjb2RlPSR7Y29kZX0gYW5kIGluZGV4PSR7aW5kZXh9ICxleHBlY3RlZCAke3Jhd3NpemV9IGdvdCAke3Jhdy5sZW5ndGh9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvZGUgPSBjb2RlO1xuICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuX29uZGV4ID0gb25kZXg7XG4gICAgICB0aGlzLl9yYXcgPSByYXc7XG4gICAgfSBlbHNlIGlmIChxYjY0YiAhPSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHFiNjQyID0gZChxYjY0Yik7XG4gICAgICB0aGlzLl9leGZpbChxYjY0Mik7XG4gICAgfSBlbHNlIGlmIChxYjY0ICE9IHZvaWQgMCkge1xuICAgICAgdGhpcy5fZXhmaWwocWI2NCk7XG4gICAgfSBlbHNlIGlmIChxYjIgIT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9iZXhmaWwocWIyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVtcHR5TWF0ZXJpYWxFcnJvcihcbiAgICAgICAgYEltcHJvcGVyIGluaXRpYWxpemF0aW9uIG5lZWQgZWl0aGVyIChyYXcgYW5kIGNvZGUgYW5kIGluZGV4KSBvciBxYjY0YiBvciBxYjY0IG9yIHFiMi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBfYmV4ZmlsKHFiMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcWIyIG5vdCB5ZXQgc3VwcG9ydGVkOiAke3FiMn1gKTtcbiAgfVxuICBzdGF0aWMgX3Jhd1NpemUoY29kZSkge1xuICAgIGNvbnN0IHhpemFnZSA9IF9JbmRleGVyLlNpemVzLmdldChjb2RlKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih4aXphZ2UuZnMgLSAoeGl6YWdlLmhzICsgeGl6YWdlLnNzKSAqIDMgLyA0KTtcbiAgfVxuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29kZTtcbiAgfVxuICBnZXQgcmF3KCkge1xuICAgIHJldHVybiB0aGlzLl9yYXc7XG4gIH1cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgfVxuICBnZXQgb25kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uZGV4O1xuICB9XG4gIGdldCBxYjY0KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZpbCgpO1xuICB9XG4gIGdldCBxYjY0YigpIHtcbiAgICByZXR1cm4gYih0aGlzLnFiNjQpO1xuICB9XG4gIF9pbmZpbCgpIHtcbiAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBjb25zdCBvbmRleCA9IHRoaXMub25kZXg7XG4gICAgY29uc3QgcmF3ID0gdGhpcy5yYXc7XG4gICAgY29uc3QgcHMgPSAoMyAtIHJhdy5sZW5ndGggJSAzKSAlIDM7XG4gICAgY29uc3QgeGl6YWdlID0gX0luZGV4ZXIuU2l6ZXMuZ2V0KGNvZGUpO1xuICAgIGNvbnN0IGNzID0geGl6YWdlLmhzICsgeGl6YWdlLnNzO1xuICAgIGNvbnN0IG1zID0geGl6YWdlLnNzIC0geGl6YWdlLm9zO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiA2NCAqKiBtcyAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbmRleD0ke2luZGV4fSBmb3IgY29kZT0ke2NvZGV9LmApO1xuICAgIH1cbiAgICBpZiAob25kZXggIT0gdm9pZCAwICYmIHhpemFnZS5vcyAhPSAwICYmICEob25kZXggPj0gMCAmJiBvbmRleCA8PSA2NCAqKiB4aXphZ2Uub3MgLSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBvbmRleD0ke29uZGV4fSBmb3Igb3M9JHt4aXphZ2Uub3N9IGFuZCBjb2RlPSR7Y29kZX0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYm90aCA9IGAke2NvZGV9JHtpbnRUb0I2NChpbmRleCwgbXMpfSR7aW50VG9CNjQoXG4gICAgICBvbmRleCA9PSB2b2lkIDAgPyAwIDogb25kZXgsXG4gICAgICB4aXphZ2Uub3NcbiAgICApfWA7XG4gICAgaWYgKGJvdGgubGVuZ3RoICE9IGNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNaXNtYXRjaCBjb2RlIHNpemUgPSAke2NzfSB3aXRoIHRhYmxlID0gJHtib3RoLmxlbmd0aH0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNzICUgNCAhPSBwcyAtIHhpemFnZS5scykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBjb2RlPSR7Ym90aH0gZm9yIGNvbnZlcnRlZCByYXcgcGFkIHNpemU9JHtwc30uYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShwcyArIHJhdy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHM7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2R4ID0gaSArIHBzO1xuICAgICAgYnl0ZXNbb2R4XSA9IHJhd1tpXTtcbiAgICB9XG4gICAgY29uc3QgZnVsbCA9IGJvdGggKyBlbmNvZGVCYXNlNjRVcmwoQnVmZmVyNC5mcm9tKGJ5dGVzKSkuc2xpY2UocHMgLSB4aXphZ2UubHMpO1xuICAgIGlmIChmdWxsLmxlbmd0aCAhPSB4aXphZ2UuZnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2RlPSR7Ym90aH0gZm9yIHJhdyBzaXplPSR7cmF3Lmxlbmd0aH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBmdWxsO1xuICB9XG4gIF9leGZpbChxYjY0KSB7XG4gICAgaWYgKHFiNjQubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IE1hdGVyaWFsXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHFiNjRbMF07XG4gICAgaWYgKCFBcnJheS5mcm9tKF9JbmRleGVyLkhhcmRzLmtleXMoKSkuaW5jbHVkZXMoZmlyc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY29kZSAke2ZpcnN0fWApO1xuICAgIH1cbiAgICBjb25zdCBocyA9IF9JbmRleGVyLkhhcmRzLmdldChmaXJzdCk7XG4gICAgaWYgKHFiNjQubGVuZ3RoIDwgaHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCAke2hzIC0gcWI2NC5sZW5ndGh9IG1vcmUgY2hhcmFjdGVycy5gKTtcbiAgICB9XG4gICAgY29uc3QgaGFyZCA9IHFiNjQuc2xpY2UoMCwgaHMpO1xuICAgIGlmICghQXJyYXkuZnJvbShfSW5kZXhlci5TaXplcy5rZXlzKCkpLmluY2x1ZGVzKGhhcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvZGUgJHtoYXJkfWApO1xuICAgIH1cbiAgICBjb25zdCB4aXphZ2UgPSBfSW5kZXhlci5TaXplcy5nZXQoaGFyZCk7XG4gICAgY29uc3QgY3MgPSB4aXphZ2UuaHMgKyB4aXphZ2Uuc3M7XG4gICAgY29uc3QgbXMgPSB4aXphZ2Uuc3MgLSB4aXphZ2Uub3M7XG4gICAgaWYgKHFiNjQubGVuZ3RoIDwgY3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCAke2NzIC0gcWI2NC5sZW5ndGh9IG1vcmUgY2hhcmFjdGVycy5gKTtcbiAgICB9XG4gICAgY29uc3Qgc2luZGV4ID0gcWI2NC5zbGljZShocywgaHMgKyBtcyk7XG4gICAgY29uc3QgaW5kZXggPSBiNjRUb0ludChzaW5kZXgpO1xuICAgIGNvbnN0IHNvbmRleCA9IHFiNjQuc2xpY2UoaHMgKyBtcywgaHMgKyBtcyArIHhpemFnZS5vcyk7XG4gICAgbGV0IG9uZGV4O1xuICAgIGlmIChJZHhDcnRTaWdEZXguaGFzKGhhcmQpKSB7XG4gICAgICBvbmRleCA9IHhpemFnZS5vcyAhPSAwID8gYjY0VG9JbnQoc29uZGV4KSA6IHZvaWQgMDtcbiAgICAgIGlmIChvbmRleCAhPSAwICYmIG9uZGV4ICE9IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb25kZXg9JHtvbmRleH0gZm9yIGNvZGU9JHtoYXJkfS5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZGV4ID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbmRleCA9IHhpemFnZS5vcyAhPSAwID8gYjY0VG9JbnQoc29uZGV4KSA6IGluZGV4O1xuICAgIH1cbiAgICBpZiAoeGl6YWdlLmZzID09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFyaWFibGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChxYjY0Lmxlbmd0aCA8IHhpemFnZS5mcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZWVkICR7eGl6YWdlLmZzIC0gcWI2NC5sZW5ndGh9IG1vcmUgY2hhcnMuYCk7XG4gICAgfVxuICAgIHFiNjQgPSBxYjY0LnNsaWNlKDAsIHhpemFnZS5mcyk7XG4gICAgY29uc3QgcHMgPSBjcyAlIDQ7XG4gICAgY29uc3QgcGJzID0gMiAqIHBzICE9IDAgPyBwcyA6IHhpemFnZS5scztcbiAgICBsZXQgcmF3O1xuICAgIGlmIChwcyAhPSAwKSB7XG4gICAgICBjb25zdCBiYXNlID0gbmV3IEFycmF5KHBzICsgMSkuam9pbihcIkFcIikgKyBxYjY0LnNsaWNlKGNzKTtcbiAgICAgIGNvbnN0IHBhdyA9IGRlY29kZUJhc2U2NFVybChiYXNlKTtcbiAgICAgIGNvbnN0IHBpID0gcmVhZEludChwYXcuc2xpY2UoMCwgcHMpKTtcbiAgICAgIGlmIChwaSAmIDIgKiogcGJzIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE5vbiB6ZXJvZWQgcHJlcGFkIGJpdHMgPSB7cGkgJiAoMiAqKiBwYnMgLSAxICk6PDA2Yn0gaW4ge3FiNjRiW2NzOmNzKzFdfS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByYXcgPSBwYXcuc2xpY2UocHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBiYXNlID0gcWI2NC5zbGljZShjcyk7XG4gICAgICBjb25zdCBwYXcgPSBkZWNvZGVCYXNlNjRVcmwoYmFzZSk7XG4gICAgICBjb25zdCBsaSA9IHJlYWRJbnQocGF3LnNsaWNlKDAsIHhpemFnZS5scykpO1xuICAgICAgaWYgKGxpICE9IDApIHtcbiAgICAgICAgaWYgKGxpID09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbiB6ZXJvZWQgbGVhZCBieXRlID0gMHh7bGk6MDJ4fS5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbiB6ZXJvZWQgbGVhZCBieXRlcyA9IDB4e2xpOjA0eH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmF3ID0gcGF3LnNsaWNlKHhpemFnZS5scyk7XG4gICAgfVxuICAgIGlmIChyYXcubGVuZ3RoICE9IE1hdGguZmxvb3IoKHFiNjQubGVuZ3RoIC0gY3MpICogMyAvIDQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcHJvcGVybHkgcXVhbGlmaWVkIG1hdGVyaWFsID0gJHtxYjY0fWApO1xuICAgIH1cbiAgICB0aGlzLl9jb2RlID0gaGFyZDtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX29uZGV4ID0gb25kZXg7XG4gICAgdGhpcy5fcmF3ID0gbmV3IFVpbnQ4QXJyYXkocmF3KTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9zaWdlci50c1xudmFyIFNpZ2VyID0gY2xhc3MgZXh0ZW5kcyBJbmRleGVyIHtcbiAgX3ZlcmZlcjtcbiAgY29uc3RydWN0b3IoeyByYXcsIGNvZGUsIGluZGV4LCBvbmRleCwgcWI2NCwgcWI2NGIsIHFiMiB9LCB2ZXJmZXIpIHtcbiAgICBzdXBlcih7IHJhdywgY29kZSwgaW5kZXgsIG9uZGV4LCBxYjY0LCBxYjY0YiwgcWIyIH0pO1xuICAgIGlmICghSWR4U2lnRGV4Lmhhcyh0aGlzLmNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29kZSA9ICR7dGhpcy5jb2RlfSBmb3IgU2lnZXIuYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZlcmZlciA9IHZlcmZlcjtcbiAgfVxuICBnZXQgdmVyZmVyKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJmZXI7XG4gIH1cbiAgc2V0IHZlcmZlcih2ZXJmZXIpIHtcbiAgICB0aGlzLl92ZXJmZXIgPSB2ZXJmZXI7XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2NvcmUvc2lnbmVyLnRzXG5pbXBvcnQgeyBCdWZmZXIgYXMgQnVmZmVyNSB9IGZyb20gXCJidWZmZXJcIjtcbnZhciBTaWduZXIgPSBjbGFzcyBleHRlbmRzIE1hdHRlciB7XG4gIF9zaWduO1xuICBfdmVyZmVyO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmF3LFxuICAgIGNvZGUgPSBNdHJEZXguRWQyNTUxOV9TZWVkLFxuICAgIHFiNjQsXG4gICAgcWI2NGIsXG4gICAgcWIyLFxuICAgIHRyYW5zZmVyYWJsZSA9IHRydWVcbiAgfSkge1xuICAgIHRyeSB7XG4gICAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVtcHR5TWF0ZXJpYWxFcnJvcikge1xuICAgICAgICBpZiAoY29kZSA9PSBNdHJEZXguRWQyNTUxOV9TZWVkKSB7XG4gICAgICAgICAgY29uc3QgcmF3MiA9IGxpYnNvZGl1bTIucmFuZG9tYnl0ZXNfYnVmKFxuICAgICAgICAgICAgbGlic29kaXVtMi5jcnlwdG9fc2lnbl9TRUVEQllURVNcbiAgICAgICAgICApO1xuICAgICAgICAgIHN1cGVyKHsgcmF3OiByYXcyLCBjb2RlLCBxYjY0LCBxYjY0YiwgcWIyIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2lnbmVyIGNvZGUgPSAke2NvZGV9LmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdmVyZmVyO1xuICAgIGlmICh0aGlzLmNvZGUgPT0gTXRyRGV4LkVkMjU1MTlfU2VlZCkge1xuICAgICAgdGhpcy5fc2lnbiA9IHRoaXMuX2VkMjU1MTk7XG4gICAgICBjb25zdCBrZXlwYWlyID0gbGlic29kaXVtMi5jcnlwdG9fc2lnbl9zZWVkX2tleXBhaXIodGhpcy5yYXcpO1xuICAgICAgdmVyZmVyID0gbmV3IFZlcmZlcih7XG4gICAgICAgIHJhdzoga2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgIGNvZGU6IHRyYW5zZmVyYWJsZSA/IE10ckRleC5FZDI1NTE5IDogTXRyRGV4LkVkMjU1MTlOXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzaWduZXIgY29kZSA9ICR7dGhpcy5jb2RlfS5gKTtcbiAgICB9XG4gICAgdGhpcy5fdmVyZmVyID0gdmVyZmVyO1xuICB9XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gUHJvcGVydHkgdmVyZmVyOlxuICAgUmV0dXJucyBWZXJmZXIgaW5zdGFuY2VcbiAgIEFzc3VtZXMgLl92ZXJmZXIgaXMgY29ycmVjdGx5IGFzc2lnbmVkXG4gICAqL1xuICBnZXQgdmVyZmVyKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJmZXI7XG4gIH1cbiAgc2lnbihzZXIsIGluZGV4ID0gbnVsbCwgb25seSA9IGZhbHNlLCBvbmRleCA9IHZvaWQgMCkge1xuICAgIHJldHVybiB0aGlzLl9zaWduKHNlciwgdGhpcy5yYXcsIHRoaXMudmVyZmVyLCBpbmRleCwgb25seSwgb25kZXgpO1xuICB9XG4gIF9lZDI1NTE5KHNlciwgc2VlZCwgdmVyZmVyLCBpbmRleCwgb25seSA9IGZhbHNlLCBvbmRleCkge1xuICAgIGNvbnN0IHNpZyA9IGxpYnNvZGl1bTIuY3J5cHRvX3NpZ25fZGV0YWNoZWQoXG4gICAgICBzZXIsXG4gICAgICBCdWZmZXI1LmNvbmNhdChbc2VlZCwgdmVyZmVyLnJhd10pXG4gICAgKTtcbiAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBDaWdhcih7IHJhdzogc2lnLCBjb2RlOiBNdHJEZXguRWQyNTUxOV9TaWcgfSwgdmVyZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvZGU7XG4gICAgICBpZiAob25seSkge1xuICAgICAgICBvbmRleCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGluZGV4IDw9IDYzKSB7XG4gICAgICAgICAgY29kZSA9IElkckRleC5FZDI1NTE5X0NydF9TaWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IElkckRleC5FZDI1NTE5X0JpZ19DcnRfU2lnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob25kZXggPT0gdm9pZCAwKSB7XG4gICAgICAgICAgb25kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25kZXggPT0gaW5kZXggJiYgaW5kZXggPD0gNjMpXG4gICAgICAgICAgY29kZSA9IElkckRleC5FZDI1NTE5X1NpZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvZGUgPSBJZHJEZXguRWQyNTUxOV9CaWdfU2lnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTaWdlcihcbiAgICAgICAgeyByYXc6IHNpZywgY29kZSwgaW5kZXgsIG9uZGV4IH0sXG4gICAgICAgIHZlcmZlclxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2NvcmUvZGVjcnlwdGVyLnRzXG5pbXBvcnQgbGlic29kaXVtNCBmcm9tIFwibGlic29kaXVtLXdyYXBwZXJzLXN1bW9cIjtcblxuLy8gc3JjL2tlcmkvY29yZS9zYWx0ZXIudHNcbmltcG9ydCBsaWJzb2RpdW0zIGZyb20gXCJsaWJzb2RpdW0td3JhcHBlcnMtc3Vtb1wiO1xudmFyIFRpZXIgPSAvKiBAX19QVVJFX18gKi8gKChUaWVyMykgPT4ge1xuICBUaWVyM1tcImxvd1wiXSA9IFwibG93XCI7XG4gIFRpZXIzW1wibWVkXCJdID0gXCJtZWRcIjtcbiAgVGllcjNbXCJoaWdoXCJdID0gXCJoaWdoXCI7XG4gIHJldHVybiBUaWVyMztcbn0pKFRpZXIgfHwge30pO1xudmFyIFNhbHRlciA9IGNsYXNzIGV4dGVuZHMgTWF0dGVyIHtcbiAgX3RpZXI7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByYXcsXG4gICAgY29kZSA9IE10ckRleC5TYWx0XzEyOCxcbiAgICB0aWVyID0gXCJsb3dcIiAvKiBsb3cgKi8sXG4gICAgcWI2NCxcbiAgICBxYjY0YixcbiAgICBxYjJcbiAgfSkge1xuICAgIHRyeSB7XG4gICAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVtcHR5TWF0ZXJpYWxFcnJvcikge1xuICAgICAgICBpZiAoY29kZSA9PSBNdHJEZXguU2FsdF8xMjgpIHtcbiAgICAgICAgICBjb25zdCBzYWx0ID0gbGlic29kaXVtMy5yYW5kb21ieXRlc19idWYoXG4gICAgICAgICAgICBsaWJzb2RpdW0zLmNyeXB0b19wd2hhc2hfU0FMVEJZVEVTXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdXBlcih7IHJhdzogc2FsdCwgY29kZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcImludmFsaWQgY29kZSBmb3IgU2FsdGVyLCBvbmx5IFNhbHRfMTI4IGFjY2VwdGVkXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb2RlICE9IE10ckRleC5TYWx0XzEyOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb2RlIGZvciBTYWx0ZXIsIG9ubHkgU2FsdF8xMjggYWNjZXB0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuX3RpZXIgPSB0aWVyICE9PSBudWxsID8gdGllciA6IFwibG93XCIgLyogbG93ICovO1xuICB9XG4gIHN0cmV0Y2goc2l6ZSA9IDMyLCBwYXRoID0gXCJcIiwgdGllciA9IG51bGwsIHRlbXAgPSBmYWxzZSkge1xuICAgIHRpZXIgPSB0aWVyID09IG51bGwgPyB0aGlzLnRpZXIgOiB0aWVyO1xuICAgIGxldCBvcHNsaW1pdCwgbWVtbGltaXQ7XG4gICAgaWYgKHRlbXApIHtcbiAgICAgIG9wc2xpbWl0ID0gMTtcbiAgICAgIG1lbWxpbWl0ID0gODE5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aWVyKSB7XG4gICAgICAgIGNhc2UgXCJsb3dcIiAvKiBsb3cgKi86XG4gICAgICAgICAgb3BzbGltaXQgPSAyO1xuICAgICAgICAgIG1lbWxpbWl0ID0gNjcxMDg4NjQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZWRcIiAvKiBtZWQgKi86XG4gICAgICAgICAgb3BzbGltaXQgPSAzO1xuICAgICAgICAgIG1lbWxpbWl0ID0gMjY4NDM1NDU2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGlnaFwiIC8qIGhpZ2ggKi86XG4gICAgICAgICAgb3BzbGltaXQgPSA0O1xuICAgICAgICAgIG1lbWxpbWl0ID0gMTA3Mzc0MTgyNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNlY3VyaXR5IHRpZXIgPSAke3RpZXJ9LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlic29kaXVtMy5jcnlwdG9fcHdoYXNoKFxuICAgICAgc2l6ZSxcbiAgICAgIHBhdGgsXG4gICAgICB0aGlzLnJhdyxcbiAgICAgIG9wc2xpbWl0LFxuICAgICAgbWVtbGltaXQsXG4gICAgICBsaWJzb2RpdW0zLmNyeXB0b19wd2hhc2hfQUxHX0FSR09OMklEMTNcbiAgICApO1xuICB9XG4gIHNpZ25lcihjb2RlID0gTXRyRGV4LkVkMjU1MTlfU2VlZCwgdHJhbnNmZXJhYmxlID0gdHJ1ZSwgcGF0aCA9IFwiXCIsIHRpZXIgPSBudWxsLCB0ZW1wID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWVkID0gdGhpcy5zdHJldGNoKE1hdHRlci5fcmF3U2l6ZShjb2RlKSwgcGF0aCwgdGllciwgdGVtcCk7XG4gICAgcmV0dXJuIG5ldyBTaWduZXIoe1xuICAgICAgcmF3OiBzZWVkLFxuICAgICAgY29kZSxcbiAgICAgIHRyYW5zZmVyYWJsZVxuICAgIH0pO1xuICB9XG4gIGdldCB0aWVyKCkge1xuICAgIHJldHVybiB0aGlzLl90aWVyO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL2RlY3J5cHRlci50c1xudmFyIERlY3J5cHRlciA9IGNsYXNzIGV4dGVuZHMgTWF0dGVyIHtcbiAgX2RlY3J5cHQ7XG4gIGNvbnN0cnVjdG9yKHsgcmF3LCBjb2RlID0gTXRyRGV4LlgyNTUxOV9Qcml2YXRlLCBxYjY0LCBxYjY0YiwgcWIyIH0sIHNlZWQgPSB2b2lkIDApIHtcbiAgICB0cnkge1xuICAgICAgc3VwZXIoeyByYXcsIGNvZGUsIHFiNjQsIHFiNjRiLCBxYjIgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFbXB0eU1hdGVyaWFsRXJyb3IpIHtcbiAgICAgICAgaWYgKHNlZWQgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3Qgc2lnbmVyID0gbmV3IFNpZ25lcih7IHFiNjRiOiBzZWVkIH0pO1xuICAgICAgICAgIGlmIChzaWduZXIuY29kZSAhPSBNdHJEZXguRWQyNTUxOV9TZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBzaWduaW5nIHNlZWQgZGVyaXZhdGlvbiBjb2RlICR7c2lnbmVyLmNvZGV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2lna2V5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBzaWduZXIucmF3Lmxlbmd0aCArIHNpZ25lci52ZXJmZXIucmF3Lmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2lna2V5LnNldChzaWduZXIucmF3KTtcbiAgICAgICAgICBzaWdrZXkuc2V0KHNpZ25lci52ZXJmZXIucmF3LCBzaWduZXIucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgcmF3ID0gbGlic29kaXVtNC5jcnlwdG9fc2lnbl9lZDI1NTE5X3NrX3RvX2N1cnZlMjU1MTkoc2lna2V5KTtcbiAgICAgICAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb2RlID09IE10ckRleC5YMjU1MTlfUHJpdmF0ZSkge1xuICAgICAgdGhpcy5fZGVjcnlwdCA9IHRoaXMuX3gyNTUxOTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNyeXB0ZXIgY29kZSA9ICR7dGhpcy5jb2RlfS5gKTtcbiAgICB9XG4gIH1cbiAgZGVjcnlwdChzZXIgPSBudWxsLCBjaXBoZXIgPSBudWxsLCB0cmFuc2ZlcmFibGUgPSBmYWxzZSkge1xuICAgIGlmIChzZXIgPT0gbnVsbCAmJiBjaXBoZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVtcHR5TWF0ZXJpYWxFcnJvcihcIk5laXRoZXIgc2VyIG9yIGNpcGhlciB3ZXJlIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBpZiAoc2VyICE9IG51bGwpIHtcbiAgICAgIGNpcGhlciA9IG5ldyBDaXBoZXIoeyBxYjY0Yjogc2VyIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdChjaXBoZXIsIHRoaXMucmF3LCB0cmFuc2ZlcmFibGUpO1xuICB9XG4gIF94MjU1MTkoY2lwaGVyLCBwcmlrZXksIHRyYW5zZmVyYWJsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcHVia2V5ID0gbGlic29kaXVtNC5jcnlwdG9fc2NhbGFybXVsdF9iYXNlKHByaWtleSk7XG4gICAgY29uc3QgcGxhaW4gPSBsaWJzb2RpdW00LmNyeXB0b19ib3hfc2VhbF9vcGVuKFxuICAgICAgY2lwaGVyLnJhdyxcbiAgICAgIHB1YmtleSxcbiAgICAgIHByaWtleVxuICAgICk7XG4gICAgaWYgKGNpcGhlci5jb2RlID09IE10ckRleC5YMjU1MTlfQ2lwaGVyX1NhbHQpIHtcbiAgICAgIHJldHVybiBuZXcgU2FsdGVyKHsgcWI2NGI6IHBsYWluIH0pO1xuICAgIH0gZWxzZSBpZiAoY2lwaGVyLmNvZGUgPT0gTXRyRGV4LlgyNTUxOV9DaXBoZXJfU2VlZCkge1xuICAgICAgcmV0dXJuIG5ldyBTaWduZXIoeyBxYjY0YjogcGxhaW4sIHRyYW5zZmVyYWJsZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaXBoZXIgdGV4dCBjb2RlID09ICR7Y2lwaGVyLmNvZGV9YCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL2NpcGhlci50c1xudmFyIENpcGhlciA9IGNsYXNzIGV4dGVuZHMgTWF0dGVyIHtcbiAgY29uc3RydWN0b3IoeyByYXcsIGNvZGUsIHFiNjQsIHFiNjRiLCBxYjIgfSkge1xuICAgIGlmIChyYXcgIT0gdm9pZCAwICYmIGNvZGUgPT0gdm9pZCAwKSB7XG4gICAgICBpZiAocmF3Lmxlbmd0aCA9PSBNYXR0ZXIuX3Jhd1NpemUoTXRyRGV4LlgyNTUxOV9DaXBoZXJfU2FsdCkpIHtcbiAgICAgICAgY29kZSA9IE10ckRleC5YMjU1MTlfQ2lwaGVyX1NhbHQ7XG4gICAgICB9IGVsc2UgaWYgKHJhdy5sZW5ndGggPT0gTWF0dGVyLl9yYXdTaXplKE10ckRleC5YMjU1MTlfQ2lwaGVyX1NlZWQpKSB7XG4gICAgICAgIGNvZGUgPSBNdHJEZXguWDI1NTE5X0NpcGhlcl9TYWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NGIsIHFiNjQsIHFiMiB9KTtcbiAgICBpZiAoIUFycmF5LmZyb20oW1xuICAgICAgTXRyRGV4LlgyNTUxOV9DaXBoZXJfU2FsdCxcbiAgICAgIE10ckRleC5YMjU1MTlfQ2lwaGVyX1NlZWRcbiAgICBdKS5pbmNsdWRlcyh0aGlzLmNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIENpcGhlciBjb2RlID09ICR7dGhpcy5jb2RlfWApO1xuICAgIH1cbiAgfVxuICBkZWNyeXB0KHByaWtleSA9IHZvaWQgMCwgc2VlZCA9IHZvaWQgMCkge1xuICAgIGNvbnN0IGRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoeyBxYjY0YjogcHJpa2V5IH0sIHNlZWQpO1xuICAgIHJldHVybiBkZWNyeXB0ZXIuZGVjcnlwdCh0aGlzLnFiNjRiKTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9jb3VudGVyLnRzXG52YXIgQ291bnRlckNvZGV4ID0gY2xhc3MgZXh0ZW5kcyBDb2RleCB7XG4gIENvbnRyb2xsZXJJZHhTaWdzID0gXCItQVwiO1xuICAvLyBRdWFsaWZpZWQgQmFzZTY0IEluZGV4ZWQgU2lnbmF0dXJlLlxuICBXaXRuZXNzSWR4U2lncyA9IFwiLUJcIjtcbiAgLy8gUXVhbGlmaWVkIEJhc2U2NCBJbmRleGVkIFNpZ25hdHVyZS5cbiAgTm9uVHJhbnNSZWNlaXB0Q291cGxlcyA9IFwiLUNcIjtcbiAgLy8gQ29tcG9zZWQgQmFzZTY0IENvdXBsZSwgcHJlK2NpZy5cbiAgVHJhbnNSZWNlaXB0UXVhZHJ1cGxlcyA9IFwiLURcIjtcbiAgLy8gQ29tcG9zZWQgQmFzZTY0IFF1YWRydXBsZSwgcHJlK3NudStkaWcrc2lnLlxuICBGaXJzdFNlZW5SZXBsYXlDb3VwbGVzID0gXCItRVwiO1xuICAvLyBDb21wb3NlZCBCYXNlNjQgQ291cGxlLCBmbnUrZHRzLlxuICBUcmFuc0lkeFNpZ0dyb3VwcyA9IFwiLUZcIjtcbiAgLy8gQ29tcG9zZWQgQmFzZTY0IEdyb3VwLCBwcmUrc251K2RpZytDb250cm9sbGVySWR4U2lncyBncm91cC5cbiAgU2VhbFNvdXJjZUNvdXBsZXMgPSBcIi1HXCI7XG4gIC8vIENvbXBvc2VkIEJhc2U2NCBjb3VwbGUsIHNudStkaWcgb2YgZ2l2ZW4gZGVsZWdhdG9ycyBvciBpc3N1ZXJzIGV2ZW50XG4gIFRyYW5zTGFzdElkeFNpZ0dyb3VwcyA9IFwiLUhcIjtcbiAgLy8gQ29tcG9zZWQgQmFzZTY0IEdyb3VwLCBwcmUrQ29udHJvbGxlcklkeFNpZ3MgZ3JvdXAuXG4gIFNlYWxTb3VyY2VUcmlwbGVzID0gXCItSVwiO1xuICAvLyBDb21wb3NlZCBCYXNlNjQgdHJpcGxlLCBwcmUrc251K2RpZyBvZiBhbmNob3Jpbmcgc291cmNlIGV2ZW50XG4gIFNhZFBhdGhTaWcgPSBcIi1KXCI7XG4gIC8vIENvbXBvc2VkIEJhc2U2NCBHcm91cCBwYXRoK1RyYW5zSWR4U2lnR3JvdXAgb2YgU0FJRCBvZiBjb250ZW50XG4gIFNhZFBhdGhTaWdHcm91cCA9IFwiLUtcIjtcbiAgLy8gQ29tcG9zZWQgQmFzZTY0IEdyb3VwLCByb290KHBhdGgpK1NhaWRQYXRoQ291cGxlc1xuICBQYXRoZWRNYXRlcmlhbFF1YWRsZXRzID0gXCItTFwiO1xuICAvLyBDb21wb3NlZCBHcm91cGVkIFBhdGhlZCBNYXRlcmlhbCBRdWFkbGV0ICg0IGNoYXIgZWFjaClcbiAgQXR0YWNoZWRNYXRlcmlhbFF1YWRsZXRzID0gXCItVlwiO1xuICAvLyBDb21wb3NlZCBHcm91cGVkIEF0dGFjaGVkIE1hdGVyaWFsIFF1YWRsZXQgKDQgY2hhciBlYWNoKVxuICBCaWdBdHRhY2hlZE1hdGVyaWFsUXVhZGxldHMgPSBcIi0wVlwiO1xuICAvLyBDb21wb3NlZCBHcm91cGVkIEF0dGFjaGVkIE1hdGVyaWFsIFF1YWRsZXQgKDQgY2hhciBlYWNoKVxuICBLRVJJUHJvdG9jb2xTdGFjayA9IFwiLS1BQUFcIjtcbiAgLy8gS0VSSSBBQ0RDIFByb3RvY29sIFN0YWNrIENFU1IgVmVyc2lvblxufTtcbnZhciBDdHJEZXggPSBuZXcgQ291bnRlckNvZGV4KCk7XG52YXIgQ291bnRlciA9IGNsYXNzIF9Db3VudGVyIHtcbiAgc3RhdGljIFNpemVzID0gbmV3IE1hcChcbiAgICBPYmplY3QuZW50cmllcyh7XG4gICAgICBcIi1BXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1CXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1DXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1EXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1FXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1GXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1HXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1IXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1JXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1KXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1LXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1MXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi1WXCI6IG5ldyBTaXphZ2UoMiwgMiwgNCwgMCksXG4gICAgICBcIi0wVlwiOiBuZXcgU2l6YWdlKDMsIDUsIDgsIDApLFxuICAgICAgXCItLUFBQVwiOiBuZXcgU2l6YWdlKDUsIDMsIDgsIDApXG4gICAgfSlcbiAgKTtcbiAgc3RhdGljIEhhcmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtcIi1BXCIsIDJdLFxuICAgIFtcIi1CXCIsIDJdLFxuICAgIFtcIi1DXCIsIDJdLFxuICAgIFtcIi1EXCIsIDJdLFxuICAgIFtcIi1FXCIsIDJdLFxuICAgIFtcIi1GXCIsIDJdLFxuICAgIFtcIi1HXCIsIDJdLFxuICAgIFtcIi1IXCIsIDJdLFxuICAgIFtcIi1JXCIsIDJdLFxuICAgIFtcIi1KXCIsIDJdLFxuICAgIFtcIi1LXCIsIDJdLFxuICAgIFtcIi1MXCIsIDJdLFxuICAgIFtcIi1NXCIsIDJdLFxuICAgIFtcIi1OXCIsIDJdLFxuICAgIFtcIi1PXCIsIDJdLFxuICAgIFtcIi1QXCIsIDJdLFxuICAgIFtcIi1RXCIsIDJdLFxuICAgIFtcIi1SXCIsIDJdLFxuICAgIFtcIi1TXCIsIDJdLFxuICAgIFtcIi1UXCIsIDJdLFxuICAgIFtcIi1VXCIsIDJdLFxuICAgIFtcIi1WXCIsIDJdLFxuICAgIFtcIi1XXCIsIDJdLFxuICAgIFtcIi1YXCIsIDJdLFxuICAgIFtcIi1ZXCIsIDJdLFxuICAgIFtcIi1aXCIsIDJdLFxuICAgIFtcIi1hXCIsIDJdLFxuICAgIFtcIi1iXCIsIDJdLFxuICAgIFtcIi1jXCIsIDJdLFxuICAgIFtcIi1kXCIsIDJdLFxuICAgIFtcIi1lXCIsIDJdLFxuICAgIFtcIi1mXCIsIDJdLFxuICAgIFtcIi1nXCIsIDJdLFxuICAgIFtcIi1oXCIsIDJdLFxuICAgIFtcIi1pXCIsIDJdLFxuICAgIFtcIi1qXCIsIDJdLFxuICAgIFtcIi1rXCIsIDJdLFxuICAgIFtcIi1sXCIsIDJdLFxuICAgIFtcIi1tXCIsIDJdLFxuICAgIFtcIi1uXCIsIDJdLFxuICAgIFtcIi1vXCIsIDJdLFxuICAgIFtcIi1wXCIsIDJdLFxuICAgIFtcIi1xXCIsIDJdLFxuICAgIFtcIi1yXCIsIDJdLFxuICAgIFtcIi1zXCIsIDJdLFxuICAgIFtcIi10XCIsIDJdLFxuICAgIFtcIi11XCIsIDJdLFxuICAgIFtcIi12XCIsIDJdLFxuICAgIFtcIi13XCIsIDJdLFxuICAgIFtcIi14XCIsIDJdLFxuICAgIFtcIi15XCIsIDJdLFxuICAgIFtcIi16XCIsIDJdLFxuICAgIFtcIi0wXCIsIDNdLFxuICAgIFtcIi0tXCIsIDVdXG4gIF0pO1xuICBfY29kZSA9IFwiXCI7XG4gIF9jb3VudCA9IC0xO1xuICBjb25zdHJ1Y3Rvcih7IGNvZGUsIGNvdW50LCBjb3VudEI2NCwgcWI2NGIsIHFiNjQsIHFiMiB9KSB7XG4gICAgaWYgKGNvZGUgIT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIV9Db3VudGVyLlNpemVzLmhhcyhjb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiVW5zdXBwb3J0ZWQgY29kZT0ke2NvZGV9LmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6YWdlID0gX0NvdW50ZXIuU2l6ZXMuZ2V0KGNvZGUpO1xuICAgICAgY29uc3QgY3MgPSBzaXphZ2UuaHMgKyBzaXphZ2Uuc3M7XG4gICAgICBpZiAoc2l6YWdlLmZzICE9IGNzIHx8IGNzICUgNCAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgV2hvbGUgY29kZSBzaXplIG5vdCBmdWxsIHNpemUgb3Igbm90IG11bHRpcGxlIG9mIDQuIGNzPSR7Y3N9IGZzPSR7c2l6YWdlLmZzfS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvdW50ID0gY291bnRCNjQgPT0gdm9pZCAwID8gMSA6IGI2NFRvSW50KGNvdW50QjY0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCA8IDAgfHwgY291bnQgPiA2NCAqKiBzaXphZ2Uuc3MgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb3VudD0ke2NvdW50fSBmb3IgY29kZT0ke2NvZGV9LmApO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29kZSA9IGNvZGU7XG4gICAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIH0gZWxzZSBpZiAocWI2NGIgIT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBxYjY0MiA9IGQocWI2NGIpO1xuICAgICAgdGhpcy5fZXhmaWwocWI2NDIpO1xuICAgIH0gZWxzZSBpZiAocWI2NCAhPSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2V4ZmlsKHFiNjQpO1xuICAgIH0gZWxzZSBpZiAocWIyICE9IHZvaWQgMCkge1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbXByb3BlciBpbml0aWFsaXphdGlvbiBuZWVkIGVpdGhlciAoY29kZSBhbmQgY291bnQpIG9yIHFiNjRiIG9yIHFiNjQgb3IgcWIyLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2RlO1xuICB9XG4gIGdldCBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gIH1cbiAgZ2V0IHFiNjQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZmlsKCk7XG4gIH1cbiAgZ2V0IHFiNjRiKCkge1xuICAgIHJldHVybiBiKHRoaXMucWI2NCk7XG4gIH1cbiAgY291bnRUb0I2NChsKSB7XG4gICAgaWYgKGwgPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBzaXphZ2UgPSBfQ291bnRlci5TaXplcy5nZXQodGhpcy5jb2RlKTtcbiAgICAgIGwgPSBzaXphZ2Uuc3M7XG4gICAgfVxuICAgIHJldHVybiBpbnRUb0I2NCh0aGlzLmNvdW50LCBsKTtcbiAgfVxuICBzdGF0aWMgc2VtVmVyVG9CNjQodmVyc2lvbiA9IFwiXCIsIG1ham9yID0gMCwgbWlub3IgPSAwLCBwYXRjaCA9IDApIHtcbiAgICBsZXQgcGFydHMgPSBbbWFqb3IsIG1pbm9yLCBwYXRjaF07XG4gICAgaWYgKHZlcnNpb24gIT0gXCJcIikge1xuICAgICAgY29uc3Qgc3NwbGl0cyA9IHZlcnNpb24uc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3Qgc3BsaXRzID0gc3NwbGl0cy5tYXAoKHgyKSA9PiB7XG4gICAgICAgIGlmICh4MiA9PSBcIlwiKVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeDIpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBvZmYgPSBzcGxpdHMubGVuZ3RoO1xuICAgICAgY29uc3QgeCA9IDMgLSBvZmY7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHg7IGkrKykge1xuICAgICAgICBzcGxpdHMucHVzaChwYXJ0c1tpICsgb2ZmXSk7XG4gICAgICB9XG4gICAgICBwYXJ0cyA9IHNwbGl0cztcbiAgICB9XG4gICAgcGFydHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgaWYgKHAgPCAwIHx8IHAgPiA2Mykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE91dCBvZiBib3VuZHMgc2VtYW50aWMgdmVyc2lvbi4gUGFydD0ke3B9IGlzIDwgMCBvciA+IDYzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHMubWFwKChwKSA9PiB7XG4gICAgICByZXR1cm4gaW50VG9CNjQocCwgMSk7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfVxuICBfaW5maWwoKSB7XG4gICAgY29uc3QgY29kZSA9IHRoaXMuY29kZTtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgY29uc3Qgc2l6YWdlID0gX0NvdW50ZXIuU2l6ZXMuZ2V0KGNvZGUpO1xuICAgIGNvbnN0IGNzID0gc2l6YWdlLmhzICsgc2l6YWdlLnNzO1xuICAgIGlmIChzaXphZ2UuZnMgIT0gY3MgfHwgY3MgJSA0ICE9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFdob2xlIGNvZGUgc2l6ZSBub3QgZnVsbCBzaXplIG9yIG5vdCBtdWx0aXBsZSBvZiA0LiBjcz0ke2NzfSBmcz0ke3NpemFnZS5mc30uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvdW50IDwgMCB8fCBjb3VudCA+IDY0ICoqIHNpemFnZS5zcyAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb3VudD0ke2NvdW50fSBmb3IgY29kZT0ke2NvZGV9LmApO1xuICAgIH1cbiAgICBjb25zdCBib3RoID0gYCR7Y29kZX0ke2ludFRvQjY0KGNvdW50LCBzaXphZ2Uuc3MpfWA7XG4gICAgaWYgKGJvdGgubGVuZ3RoICUgNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBzaXplID0gJHtib3RoLmxlbmd0aH0gb2YgJHtib3RofSBub3QgYSBtdWx0aXBsZSBvZiA0LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBib3RoO1xuICB9XG4gIF9leGZpbChxYjY0KSB7XG4gICAgaWYgKHFiNjQubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IE1hdGVyaWFsXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHFiNjQuc2xpY2UoMCwgMik7XG4gICAgaWYgKCFfQ291bnRlci5IYXJkcy5oYXMoZmlyc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY29kZSAke2ZpcnN0fWApO1xuICAgIH1cbiAgICBjb25zdCBocyA9IF9Db3VudGVyLkhhcmRzLmdldChmaXJzdCk7XG4gICAgaWYgKHFiNjQubGVuZ3RoIDwgaHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCAke2hzIC0gcWI2NC5sZW5ndGh9IG1vcmUgY2hhcmFjdGVycy5gKTtcbiAgICB9XG4gICAgY29uc3QgaGFyZCA9IHFiNjQuc2xpY2UoMCwgaHMpO1xuICAgIGlmICghX0NvdW50ZXIuU2l6ZXMuaGFzKGhhcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvZGUgJHtoYXJkfWApO1xuICAgIH1cbiAgICBjb25zdCBzaXphZ2UgPSBfQ291bnRlci5TaXplcy5nZXQoaGFyZCk7XG4gICAgY29uc3QgY3MgPSBzaXphZ2UuaHMgKyBzaXphZ2Uuc3M7XG4gICAgaWYgKHFiNjQubGVuZ3RoIDwgY3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmVlZCAke2NzIC0gcWI2NC5sZW5ndGh9IG1vcmUgY2hhcnMuYCk7XG4gICAgfVxuICAgIGNvbnN0IHNjb3VudCA9IHFiNjQuc2xpY2Uoc2l6YWdlLmhzLCBzaXphZ2UuaHMgKyBzaXphZ2Uuc3MpO1xuICAgIGNvbnN0IGNvdW50ID0gYjY0VG9JbnQoc2NvdW50KTtcbiAgICB0aGlzLl9jb2RlID0gaGFyZDtcbiAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL3NlcW5lci50c1xudmFyIFNlcW5lciA9IGNsYXNzIGV4dGVuZHMgTWF0dGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJhdyxcbiAgICBjb2RlID0gTXRyRGV4LlNhbHRfMTI4LFxuICAgIHFiNjQsXG4gICAgcWI2NGIsXG4gICAgcWIyLFxuICAgIHNuLFxuICAgIHNuaCxcbiAgICAuLi5rd2FcbiAgfSkge1xuICAgIGlmICghcmF3ICYmICFxYjY0YiAmJiAhcWI2NCAmJiAhcWIyKSB7XG4gICAgICBpZiAoc24gPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoc25oID09PSB2b2lkIDApIHtcbiAgICAgICAgICBzbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc24gPSBwYXJzZUludChzbmgsIDE2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmF3ID0gaW50VG9CeXRlcyhzbiwgTWF0dGVyLl9yYXdTaXplKE10ckRleC5TYWx0XzEyOCkpO1xuICAgIH1cbiAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiwgLi4ua3dhIH0pO1xuICAgIGlmICh0aGlzLmNvZGUgIT09IE10ckRleC5TYWx0XzEyOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvZGUgPSAke3RoaXMuY29kZX0gZm9yIFNlcW5lci5gKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNuKCkge1xuICAgIHJldHVybiBieXRlc1RvSW50KHRoaXMucmF3KTtcbiAgfVxuICBnZXQgc25oKCkge1xuICAgIHJldHVybiB0aGlzLnNuLnRvU3RyaW5nKDE2KTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9kaWdlci50c1xuaW1wb3J0IHsgYmxha2UzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UzXCI7XG5pbXBvcnQgeyBCdWZmZXIgYXMgQnVmZmVyNiB9IGZyb20gXCJidWZmZXJcIjtcbnZhciBEaWdlciA9IGNsYXNzIF9EaWdlciBleHRlbmRzIE1hdHRlciB7XG4gIF92ZXJpZnk7XG4gIC8vIFRoaXMgY29uc3RydWN0b3Igd2lsbCBhc3NpZ24gZGlnZXN0IHZlcmlmaWNhdGlvbiBmdW5jdGlvbiB0byAuX3ZlcmlmeVxuICBjb25zdHJ1Y3Rvcih7IHJhdywgY29kZSA9IE10ckRleC5CbGFrZTNfMjU2LCBxYjY0LCBxYjY0YiwgcWIyIH0sIHNlciA9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgc3VwZXIoeyByYXcsIGNvZGUsIHFiNjQsIHFiNjRiLCBxYjIgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChzZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSBNdHJEZXguQmxha2UzXzI1Nikge1xuICAgICAgICBjb25zdCBkaWcgPSBCdWZmZXI2LmZyb20oXG4gICAgICAgICAgYmxha2UzLmNyZWF0ZSh7IGRrTGVuOiAzMiB9KS51cGRhdGUoc2VyKS5kaWdlc3QoKVxuICAgICAgICApO1xuICAgICAgICBzdXBlcih7IHJhdzogZGlnLCBjb2RlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb2RlID0gJHtjb2RlfSBmb3IgZGlnZXN0ZXIuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2RlID09PSBNdHJEZXguQmxha2UzXzI1Nikge1xuICAgICAgdGhpcy5fdmVyaWZ5ID0gdGhpcy5ibGFrZTNfMjU2O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvZGUgPSAke2NvZGV9IGZvciBkaWdlc3Rlci5gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VyICBzZXJpYWxpemF0aW9uIGJ5dGVzXG4gICAqIEBkZXNjcmlwdGlvbiAgVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdHJ1ZSBpZiBkaWdlc3Qgb2YgYnl0ZXMgc2VyaWFsaXphdGlvbiBzZXIgbWF0Y2hlcyAucmF3XG4gICAqIHVzaW5nIC5yYXcgYXMgcmVmZXJlbmNlIGRpZ2VzdCBmb3IgLl92ZXJpZnkgZGlnZXN0IGFsZ29yaXRobSBkZXRlcm1pbmVkXG4gICBieSAuY29kZVxuICAgKi9cbiAgdmVyaWZ5KHNlcikge1xuICAgIHJldHVybiB0aGlzLl92ZXJpZnkoc2VyLCB0aGlzLnJhdyk7XG4gIH1cbiAgY29tcGFyZShzZXIsIGRpZyA9IG51bGwsIGRpZ2VyID0gbnVsbCkge1xuICAgIGlmIChkaWcgIT0gbnVsbCkge1xuICAgICAgaWYgKGRpZy50b1N0cmluZygpID09IHRoaXMucWI2NCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRpZ2VyID0gbmV3IF9EaWdlcih7IHFiNjRiOiBkaWcgfSk7XG4gICAgfSBlbHNlIGlmIChkaWdlciAhPSBudWxsKSB7XG4gICAgICBpZiAoZGlnZXIucWI2NGIgPT0gdGhpcy5xYjY0Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBkaWcgYW5kIGRpZ2VyIG1heSBub3QgYmUgTm9uZS5cIik7XG4gICAgfVxuICAgIGlmIChkaWdlci5jb2RlID09IHRoaXMuY29kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGlnZXIudmVyaWZ5KHNlcikgJiYgdGhpcy52ZXJpZnkoc2VyKTtcbiAgfVxuICBibGFrZTNfMjU2KHNlciwgZGlnKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gQnVmZmVyNi5mcm9tKFxuICAgICAgYmxha2UzLmNyZWF0ZSh7IGRrTGVuOiAzMiB9KS51cGRhdGUoc2VyKS5kaWdlc3QoKVxuICAgICk7XG4gICAgcmV0dXJuIGRpZ2VzdC50b1N0cmluZygpID09PSBkaWcudG9TdHJpbmcoKTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9udW1iZXIudHNcbnZhciBDZXNyTnVtYmVyID0gY2xhc3MgZXh0ZW5kcyBNYXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih7IHJhdywgY29kZSwgcWI2NGIsIHFiNjQsIHFiMiB9LCBudW0sIG51bWgpIHtcbiAgICBsZXQgX251bTtcbiAgICBpZiAocmF3ID09IHZvaWQgMCAmJiBxYjY0ID09IHZvaWQgMCAmJiBxYjY0YiA9PSB2b2lkIDAgJiYgcWIyID09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBudW0gPT0gXCJudW1iZXJcIikge1xuICAgICAgICBfbnVtID0gbnVtO1xuICAgICAgfSBlbHNlIGlmIChudW1oICE9IHZvaWQgMCkge1xuICAgICAgICBfbnVtID0gcGFyc2VJbnQobnVtaCwgMTYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX251bSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfbnVtID09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3aG9sZSBudW1iZXJcIik7XG4gICAgfVxuICAgIGlmIChfbnVtIDw9IDI1NiAqKiAyIC0gMSkge1xuICAgICAgY29kZSA9IE51bURleC5TaG9ydDtcbiAgICB9IGVsc2UgaWYgKF9udW0gPD0gMjU2ICoqIDQgLSAxKSB7XG4gICAgICBjb2RlID0gY29kZSA9IE51bURleC5Mb25nO1xuICAgIH0gZWxzZSBpZiAoX251bSA8PSAyNTYgKiogOCAtIDEpIHtcbiAgICAgIGNvZGUgPSBjb2RlID0gTnVtRGV4LkJpZztcbiAgICB9IGVsc2UgaWYgKF9udW0gPD0gMjU2ICoqIDE2IC0gMSkge1xuICAgICAgY29kZSA9IGNvZGUgPSBOdW1EZXguSHVnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bSA9ICR7bnVtfSwgdG9vIGxhcmdlIHRvIGVuY29kZS5gKTtcbiAgICB9XG4gICAgcmF3ID0gaW50VG9CeXRlcyhfbnVtLCBNYXR0ZXIuX3Jhd1NpemUoY29kZSkpO1xuICAgIHN1cGVyKHsgcmF3LCBjb2RlLCBxYjY0YiwgcWI2NCwgcWIyIH0pO1xuICAgIGlmICghTnVtRGV4Lmhhcyh0aGlzLmNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgXCIgKyBjb2RlICsgXCIgZm9yIE51bWJlclwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG51bSgpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0ludCh0aGlzLnJhdyk7XG4gIH1cbiAgZ2V0IG51bWgoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtLnRvU3RyaW5nKDE2KTtcbiAgfVxuICBnZXQgcG9zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtID4gMDtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9zZXJkZXIudHNcbnZhciBTZXJkZXIgPSBjbGFzcyB7XG4gIF9raW5kO1xuICBfcmF3ID0gXCJcIjtcbiAgX2tlZCA9IHt9O1xuICBfaWRlbnQgPSBcIktFUklcIiAvKiBLRVJJICovO1xuICBfc2l6ZSA9IDA7XG4gIF92ZXJzaW9uID0gVmVyc2lvbmFnZTtcbiAgX2NvZGU7XG4gIGNvbnN0cnVjdG9yKGtlZCwga2luZCA9IFwiSlNPTlwiIC8qIEpTT04gKi8sIGNvZGUgPSBNdHJEZXguQmxha2UzXzI1Nikge1xuICAgIHRoaXMuX2NvZGUgPSBjb2RlO1xuICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIHRoaXMua2VkID0ga2VkO1xuICB9XG4gIHNldCBrZWQoa2VkKSB7XG4gICAgY29uc3QgW3JhdywgaWRlbnQsIGtpbmQsIGtkLCB2ZXJzaW9uXSA9IHRoaXMuX2V4aGFsZShrZWQsIHRoaXMuX2tpbmQpO1xuICAgIGNvbnN0IHNpemUgPSByYXcubGVuZ3RoO1xuICAgIHRoaXMuX3JhdyA9IHJhdztcbiAgICB0aGlzLl9pZGVudCA9IGlkZW50O1xuICAgIHRoaXMuX2tlZCA9IGtkO1xuICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICB9XG4gIGdldCBwcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tlZFtcImlcIl07XG4gIH1cbiAgZ2V0IGtlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2VkO1xuICB9XG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2RlO1xuICB9XG4gIGdldCByYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhdztcbiAgfVxuICBnZXQgc25lcigpIHtcbiAgICByZXR1cm4gbmV3IENlc3JOdW1iZXIoe30sIHRoaXMua2VkW1wic1wiXSk7XG4gIH1cbiAgZ2V0IHNuKCkge1xuICAgIHJldHVybiB0aGlzLnNuZXIubnVtO1xuICB9XG4gIGdldCBraW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9raW5kO1xuICB9XG4gIF9leGhhbGUoa2VkLCBraW5kKSB7XG4gICAgcmV0dXJuIHNpemVpZnkoa2VkLCBraW5kKTtcbiAgfVxuICBnZXQgaWRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkZW50O1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICB9XG4gIGdldCB2ZXJmZXJzKCkge1xuICAgIGxldCBrZXlzID0gW107XG4gICAgaWYgKFwia1wiIGluIHRoaXMuX2tlZCkge1xuICAgICAga2V5cyA9IHRoaXMuX2tlZFtcImtcIl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgdmVyZmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHZlcmZlcnMucHVzaChuZXcgVmVyZmVyKHsgcWI2NDoga2V5IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcmZlcnM7XG4gIH1cbiAgZ2V0IGRpZ2VycygpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGlmIChcIm5cIiBpbiB0aGlzLl9rZWQpIHtcbiAgICAgIGtleXMgPSB0aGlzLl9rZWRbXCJuXCJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gW107XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VycyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGRpZ2Vycy5wdXNoKG5ldyBEaWdlcih7IHFiNjQ6IGtleSB9KSk7XG4gICAgfVxuICAgIHJldHVybiBkaWdlcnM7XG4gIH1cbiAgcHJldHR5KCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9rZWQsIHZvaWQgMCwgMik7XG4gIH1cbn07XG5mdW5jdGlvbiBkdW1wcyhrZWQsIGtpbmQpIHtcbiAgaWYgKGtpbmQgPT0gXCJKU09OXCIgLyogSlNPTiAqLykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZWQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGV2ZW50IGVuY29kaW5nXCIpO1xuICB9XG59XG5mdW5jdGlvbiBzaXplaWZ5KGtlZCwga2luZCkge1xuICBpZiAoIShcInZcIiBpbiBrZWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBvciBlbXB0eSB2ZXJzaW9uIHN0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBbaWRlbnQsIGtuZCwgdmVyc2lvbl0gPSBkZXZlcnNpZnkoa2VkW1widlwiXSk7XG4gIGlmICh2ZXJzaW9uICE9IFZlcnNpb25hZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHZlcnNpb24gJHt2ZXJzaW9uLnRvU3RyaW5nKCl9YCk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gdm9pZCAwKSB7XG4gICAga2luZCA9IGtuZDtcbiAgfVxuICBsZXQgcmF3ID0gZHVtcHMoa2VkLCBraW5kKTtcbiAgY29uc3Qgc2l6ZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShyYXcpLmxlbmd0aDtcbiAga2VkW1widlwiXSA9IHZlcnNpZnkoaWRlbnQsIHZlcnNpb24sIGtpbmQsIHNpemUpO1xuICByYXcgPSBkdW1wcyhrZWQsIGtpbmQpO1xuICByZXR1cm4gW3JhdywgaWRlbnQsIGtpbmQsIGtlZCwgdmVyc2lvbl07XG59XG5cbi8vIHNyYy9rZXJpL2NvcmUvcHJlZml4ZXIudHNcbmltcG9ydCB7IEJ1ZmZlciBhcyBCdWZmZXI3IH0gZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0IHsgYmxha2UzIGFzIGJsYWtlMzIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTNcIjtcbnZhciBEdW1teSA9IFwiI1wiO1xudmFyIFByZWZpeGVyID0gY2xhc3MgX1ByZWZpeGVyIGV4dGVuZHMgTWF0dGVyIHtcbiAgX2Rlcml2ZTtcbiAgX3ZlcmlmeTtcbiAgY29uc3RydWN0b3IoeyByYXcsIGNvZGUsIHFiNjRiLCBxYjY0LCBxYjIgfSwga2VkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1cGVyKHsgcmF3LCBjb2RlLCBxYjY0YiwgcWI2NCwgcWIyIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRW1wdHlNYXRlcmlhbEVycm9yKSB7XG4gICAgICAgIGlmIChrZWQgPT0gdm9pZCAwIHx8IGNvZGUgPT0gdm9pZCAwICYmICEoXCJpXCIgaW4ga2VkKSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3VwZXIoeyBxYjY0OiBrZWRbXCJpXCJdLCBjb2RlIH0pO1xuICAgICAgICAgIGNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IF9kZXJpdmU7XG4gICAgICAgIGlmIChjb2RlID09IE10ckRleC5FZDI1NTE5Tikge1xuICAgICAgICAgIF9kZXJpdmUgPSBfUHJlZml4ZXIuX2Rlcml2ZV9lZDI1NTE5TjtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IE10ckRleC5FZDI1NTE5KSB7XG4gICAgICAgICAgX2Rlcml2ZSA9IF9QcmVmaXhlci5fZGVyaXZlX2VkMjU1MTk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PSBNdHJEZXguQmxha2UzXzI1Nikge1xuICAgICAgICAgIF9kZXJpdmUgPSBfUHJlZml4ZXIuX2Rlcml2ZV9ibGFrZTNfMjU2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29kZSA9ICR7Y29kZX0gZm9yIHByZWZpeGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIFtyYXcsIGNvZGVdID0gX2Rlcml2ZShrZWQpO1xuICAgICAgICBzdXBlcih7IHJhdywgY29kZSB9KTtcbiAgICAgICAgdGhpcy5fZGVyaXZlID0gX2Rlcml2ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvZGUgPT0gTXRyRGV4LkVkMjU1MTlOKSB7XG4gICAgICB0aGlzLl92ZXJpZnkgPSB0aGlzLl92ZXJpZnlfZWQyNTUxOU47XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvZGUgPT0gTXRyRGV4LkVkMjU1MTkpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeSA9IHRoaXMuX3ZlcmlmeV9lZDI1NTE5O1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb2RlID09IE10ckRleC5CbGFrZTNfMjU2KSB7XG4gICAgICB0aGlzLl92ZXJpZnkgPSB0aGlzLl92ZXJpZnlfYmxha2UzXzI1NjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb2RlID0gJHtjb2RlfSBmb3IgcHJlZml4ZXIuYCk7XG4gICAgfVxuICB9XG4gIGRlcml2ZShrZWQpIHtcbiAgICBpZiAoa2VkW1wiaVwiXSAhPSBJbGtzLmljcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm9uLWluY2VwdGluZyBpbGsgJHtrZWRbXCJpXCJdfSBmb3IgcHJlZml4IGRlcml2YXRpb25gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVyaXZlKGtlZCk7XG4gIH1cbiAgdmVyaWZ5KGtlZCwgcHJlZml4ZWQgPSBmYWxzZSkge1xuICAgIGlmIChrZWRbXCJpXCJdICE9IElsa3MuaWNwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb24taW5jZXB0aW5nIGlsayAke2tlZFtcImlcIl19IGZvciBwcmVmaXggZGVyaXZhdGlvbmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92ZXJpZnkoa2VkLCB0aGlzLnFiNjQsIHByZWZpeGVkKTtcbiAgfVxuICBzdGF0aWMgX2Rlcml2ZV9lZDI1NTE5TihrZWQpIHtcbiAgICBsZXQgdmVyZmVyO1xuICAgIGNvbnN0IGtleXMgPSBrZWRbXCJrXCJdO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYXNpYyBkZXJpdmF0aW9uIG5lZWRzIGF0IG1vc3QgMSBrZXkgZ290ICR7a2V5cy5sZW5ndGh9IGtleXMgaW5zdGVhZGBcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2ZXJmZXIgPSBuZXcgVmVyZmVyKHsgcWI2NDoga2V5c1swXSB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGV4dHJhY3RpbmcgcHVibGljIGtleSA9ICR7ZX1gKTtcbiAgICB9XG4gICAgaWYgKHZlcmZlci5jb2RlICE9IE10ckRleC5FZDI1NTE5Tikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNtYXRjaCBkZXJpdmF0aW9uIGNvZGUgPSAke3ZlcmZlci5jb2RlfWApO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gXCJuXCIgaW4ga2VkID8ga2VkW1wiblwiXSA6IFtdO1xuICAgIGlmICh2ZXJmZXIuY29kZSA9PSBNdHJEZXguRWQyNTUxOU4gJiYgbmV4dC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb24tZW1wdHkgbnh0ID0gJHtuZXh0fSBmb3Igbm9uLXRyYW5zZmVyYWJsZSBjb2RlID0gJHt2ZXJmZXIuY29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiYWNrZXJzID0gXCJiXCIgaW4ga2VkID8ga2VkW1wiYlwiXSA6IFtdO1xuICAgIGlmICh2ZXJmZXIuY29kZSA9PSBNdHJEZXguRWQyNTUxOU4gJiYgYmFja2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb24tZW1wdHkgYiA9JHtiYWNrZXJzfSBmb3Igbm9uLXRyYW5zZmVyYWJsZSBjb2RlID0gJHt2ZXJmZXIuY29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3IgPSBcImFcIiBpbiBrZWQgPyBrZWRbXCJhXCJdIDogW107XG4gICAgaWYgKHZlcmZlci5jb2RlID09IE10ckRleC5FZDI1NTE5TiAmJiBhbmNob3IubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm9uLWVtcHR5IGEgPSAke3ZlcmZlci5jb2RlfSBmb3Igbm9uLXRyYW5zZmVyYWJsZSBjb2RlID0gJHt2ZXJmZXIuY29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3ZlcmZlci5yYXcsIHZlcmZlci5jb2RlXTtcbiAgfVxuICBzdGF0aWMgX2Rlcml2ZV9lZDI1NTE5KGtlZCkge1xuICAgIGxldCB2ZXJmZXI7XG4gICAgY29uc3Qga2V5cyA9IGtlZFtcImtcIl07XG4gICAgaWYgKGtleXMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhc2ljIGRlcml2YXRpb24gbmVlZHMgYXQgbW9zdCAxIGtleSBnb3QgJHtrZXlzLmxlbmd0aH0ga2V5cyBpbnN0ZWFkYFxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHZlcmZlciA9IG5ldyBWZXJmZXIoeyBxYjY0OiBrZXlzWzBdIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXh0cmFjdGluZyBwdWJsaWMga2V5ID0gJHtlfWApO1xuICAgIH1cbiAgICBpZiAodmVyZmVyLmNvZGUgaW4gW010ckRleC5FZDI1NTE5XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNtYXRjaCBkZXJpdmF0aW9uIGNvZGUgPSAke3ZlcmZlci5jb2RlfWApO1xuICAgIH1cbiAgICByZXR1cm4gW3ZlcmZlci5yYXcsIHZlcmZlci5jb2RlXTtcbiAgfVxuICBzdGF0aWMgX2Rlcml2ZV9ibGFrZTNfMjU2KGtlZCkge1xuICAgIGNvbnN0IGtkID0ga2VkO1xuICAgIGNvbnN0IGlsayA9IGtlZFtcInRcIl07XG4gICAgaWYgKCFbSWxrcy5pY3AsIElsa3MuZGlwLCBJbGtzLnZjcCwgSWxrcy5kaXBdLmluY2x1ZGVzKGlsaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbGsgPSAke2lsa30gdG8gZGVyaXZlIHByZS5gKTtcbiAgICB9XG4gICAga2RbXCJpXCJdID0gXCJcIi5wYWRTdGFydChNYXR0ZXIuU2l6ZXMuZ2V0KE10ckRleC5CbGFrZTNfMjU2KS5mcywgRHVtbXkpO1xuICAgIGtkW1wiZFwiXSA9IGtlZFtcImlcIl07XG4gICAgY29uc3QgW3Jhd10gPSBzaXplaWZ5KGtlZCk7XG4gICAgY29uc3QgZGlnID0gQnVmZmVyNy5mcm9tKFxuICAgICAgYmxha2UzMi5jcmVhdGUoeyBka0xlbjogMzIgfSkudXBkYXRlKHJhdykuZGlnZXN0KClcbiAgICApO1xuICAgIHJldHVybiBbZGlnLCBNdHJEZXguQmxha2UzXzI1Nl07XG4gIH1cbiAgX3ZlcmlmeV9lZDI1NTE5TihrZWQsIHByZSwgcHJlZml4ZWQgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0ga2VkW1wia1wiXTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzWzBdICE9IHByZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4ZWQgJiYga2VkW1wiaVwiXSAhPSBwcmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dCA9IFwiblwiIGluIGtlZCA/IGtlZFtcIm5cIl0gOiBbXTtcbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3ZlcmlmeV9lZDI1NTE5KGtlZCwgcHJlLCBwcmVmaXhlZCA9IGZhbHNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXMgPSBrZWRbXCJrXCJdO1xuICAgICAgaWYgKGtleXMubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGtleXNbMF0gIT0gcHJlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhlZCAmJiBrZWRbXCJpXCJdICE9IHByZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfdmVyaWZ5X2JsYWtlM18yNTYoa2VkLCBwcmUsIHByZWZpeGVkID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3Jhd10gPSBfUHJlZml4ZXIuX2Rlcml2ZV9ibGFrZTNfMjU2KGtlZCk7XG4gICAgICBjb25zdCBjcnltYXQgPSBuZXcgTWF0dGVyKHsgcmF3LCBjb2RlOiBNdHJEZXguQmxha2UzXzI1NiB9KTtcbiAgICAgIGlmIChjcnltYXQucWI2NCAhPSBwcmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeGVkICYmIGtlZFtcImlcIl0gIT0gcHJlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL3NhaWRlci50c1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlcjggfSBmcm9tIFwiYnVmZmVyXCI7XG5pbXBvcnQgeyBibGFrZTMgYXMgYmxha2UzMyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2JsYWtlM1wiO1xudmFyIER1bW15MiA9IFwiI1wiO1xudmFyIElkcyA9IC8qIEBfX1BVUkVfXyAqLyAoKElkczIpID0+IHtcbiAgSWRzMltcImRcIl0gPSBcImRcIjtcbiAgcmV0dXJuIElkczI7XG59KShJZHMgfHwge30pO1xudmFyIERpZ2VzdGFnZSA9IGNsYXNzIHtcbiAga2xhcyA9IHZvaWQgMDtcbiAgc2l6ZSA9IDA7XG4gIGxlbmd0aCA9IDA7XG4gIGNvbnN0cnVjdG9yKGtsYXMsIHNpemUsIGxlbmd0aCkge1xuICAgIHRoaXMua2xhcyA9IGtsYXM7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxufTtcbnZhciBTYWlkZXIgPSBjbGFzcyBfU2FpZGVyIGV4dGVuZHMgTWF0dGVyIHtcbiAgc3RhdGljIERpZ2VzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgW1xuICAgICAgTXRyRGV4LkJsYWtlM18yNTYsXG4gICAgICBuZXcgRGlnZXN0YWdlKF9TYWlkZXIuX2Rlcml2ZV9ibGFrZTNfMjU2LCB2b2lkIDAsIHZvaWQgMClcbiAgICBdXG4gIF0pO1xuICBjb25zdHJ1Y3Rvcih7IHJhdywgY29kZSwgcWI2NGIsIHFiNjQsIHFiMiB9LCBzYWQsIGtpbmQsIGxhYmVsID0gXCJkXCIgLyogZCAqLykge1xuICAgIHRyeSB7XG4gICAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NGIsIHFiNjQsIHFiMiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVtcHR5TWF0ZXJpYWxFcnJvcikge1xuICAgICAgICBpZiAoc2FkID09IHZvaWQgMCB8fCAhKGxhYmVsIGluIHNhZCkpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlID09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChzYWRbbGFiZWxdICE9IFwiXCIpIHtcbiAgICAgICAgICAgIHN1cGVyKHsgcWI2NDogc2FkW2xhYmVsXSwgY29kZSB9KTtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSBNdHJEZXguQmxha2UzXzI1NjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFEaWdpRGV4Lmhhcyhjb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGlnZXN0IGNvZGUgPSAke2NvZGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgW3Jhd10gPSBfU2FpZGVyLl9kZXJpdmUoeyAuLi5zYWQgfSwgY29kZSwga2luZCwgbGFiZWwpO1xuICAgICAgICBzdXBlcih7IHJhdywgY29kZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5kaWdlc3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGlnZXN0IGNvZGUgPSAke3RoaXMuY29kZX0uYCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfZGVyaXZlX2JsYWtlM18yNTYoc2VyLCBfZGlnZXN0X3NpemUsIF9sZW5ndGgpIHtcbiAgICByZXR1cm4gQnVmZmVyOC5mcm9tKGJsYWtlMzMuY3JlYXRlKHsgZGtMZW46IDMyIH0pLnVwZGF0ZShzZXIpLmRpZ2VzdCgpKTtcbiAgfVxuICBzdGF0aWMgX2Rlcml2ZShzYWQsIGNvZGUsIGtpbmQsIGxhYmVsKSB7XG4gICAgaWYgKCFEaWdpRGV4Lmhhcyhjb2RlKSB8fCAhX1NhaWRlci5EaWdlc3RzLmhhcyhjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaWdlc3QgY29kZSA9ICR7Y29kZX0uYCk7XG4gICAgfVxuICAgIHNhZCA9IHsgLi4uc2FkIH07XG4gICAgc2FkW2xhYmVsXSA9IFwiXCIucGFkU3RhcnQoTWF0dGVyLlNpemVzLmdldChjb2RlKS5mcywgRHVtbXkyKTtcbiAgICBpZiAoXCJ2XCIgaW4gc2FkKSB7XG4gICAgICBbLCAsIGtpbmQsIHNhZF0gPSBzaXplaWZ5KHNhZCwga2luZCk7XG4gICAgfVxuICAgIGNvbnN0IHNlciA9IHsgLi4uc2FkIH07XG4gICAgY29uc3QgZGlnZXN0YWdlID0gX1NhaWRlci5EaWdlc3RzLmdldChjb2RlKTtcbiAgICBjb25zdCBjcGEgPSBfU2FpZGVyLl9zZXJpYWx6ZShzZXIsIGtpbmQpO1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBpZiAoZGlnZXN0YWdlLnNpemUgIT0gdm9pZCAwKSB7XG4gICAgICBhcmdzLnB1c2goZGlnZXN0YWdlLnNpemUpO1xuICAgIH1cbiAgICBpZiAoZGlnZXN0YWdlLmxlbmd0aCAhPSB2b2lkIDApIHtcbiAgICAgIGFyZ3MucHVzaChkaWdlc3RhZ2UubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtkaWdlc3RhZ2Uua2xhcyhjcGEsIC4uLmFyZ3MpLCBzYWRdO1xuICB9XG4gIGRlcml2ZShzYWQsIGNvZGUsIGtpbmQsIGxhYmVsKSB7XG4gICAgY29kZSA9IGNvZGUgIT0gdm9pZCAwID8gY29kZSA6IHRoaXMuY29kZTtcbiAgICByZXR1cm4gX1NhaWRlci5fZGVyaXZlKHNhZCwgY29kZSwga2luZCwgbGFiZWwpO1xuICB9XG4gIHZlcmlmeShzYWQsIHByZWZpeGVkID0gZmFsc2UsIHZlcnNpb25lZCA9IGZhbHNlLCBraW5kLCBsYWJlbCA9IFwiZFwiIC8qIGQgKi8pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3JhdywgZHNhZF0gPSBfU2FpZGVyLl9kZXJpdmUoc2FkLCB0aGlzLmNvZGUsIGtpbmQsIGxhYmVsKTtcbiAgICAgIGNvbnN0IHNhaWRlciA9IG5ldyBfU2FpZGVyKHsgcmF3LCBjb2RlOiB0aGlzLmNvZGUgfSk7XG4gICAgICBpZiAodGhpcy5xYjY0ICE9IHNhaWRlci5xYjY0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChcInZcIiBpbiBzYWQgJiYgdmVyc2lvbmVkKSB7XG4gICAgICAgIGlmIChzYWRbXCJ2XCJdICE9IGRzYWRbXCJ2XCJdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4ZWQgJiYgc2FkW2xhYmVsXSAhPSB0aGlzLnFiNjQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIF9zZXJpYWx6ZShzYWQsIGtpbmQpIHtcbiAgICBsZXQga25kID0gXCJKU09OXCIgLyogSlNPTiAqLztcbiAgICBpZiAoXCJ2XCIgaW4gc2FkKSB7XG4gICAgICBbLCBrbmRdID0gZGV2ZXJzaWZ5KHNhZFtcInZcIl0pO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PSB2b2lkIDApIHtcbiAgICAgIGtpbmQgPSBrbmQ7XG4gICAgfVxuICAgIHJldHVybiBkdW1wcyhzYWQsIGtpbmQpO1xuICB9XG4gIHN0YXRpYyBzYWlkaWZ5KHNhZCwgY29kZSA9IE10ckRleC5CbGFrZTNfMjU2LCBraW5kID0gXCJKU09OXCIgLyogSlNPTiAqLywgbGFiZWwgPSBcImRcIiAvKiBkICovKSB7XG4gICAgaWYgKCEobGFiZWwgaW4gc2FkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGlkIGZpZWxkIGxhYmVsZWQ9JHtsYWJlbH0gaW4gc2FkLmApO1xuICAgIH1cbiAgICBsZXQgcmF3O1xuICAgIFtyYXcsIHNhZF0gPSBfU2FpZGVyLl9kZXJpdmUoc2FkLCBjb2RlLCBraW5kLCBsYWJlbCk7XG4gICAgY29uc3Qgc2FpZGVyID0gbmV3IF9TYWlkZXIoXG4gICAgICB7IHJhdywgY29kZSB9LFxuICAgICAgdm9pZCAwLFxuICAgICAga2luZCxcbiAgICAgIGxhYmVsXG4gICAgKTtcbiAgICBzYWRbbGFiZWxdID0gc2FpZGVyLnFiNjQ7XG4gICAgcmV0dXJuIFtzYWlkZXIsIHNhZF07XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2NvcmUvdXRpbHMudHNcbmZ1bmN0aW9uIHBhZChuLCB3aWR0aCA9IDMsIHogPSAwKSB7XG4gIHJldHVybiAoU3RyaW5nKHopLnJlcGVhdCh3aWR0aCkgKyBTdHJpbmcobikpLnNsaWNlKFN0cmluZyhuKS5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZXh0cmFjdFZhbHVlcyhrZWQsIGxhYmVscykge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgdmFsdWVzID0gZXh0cmFjdEVsZW1lbnRWYWx1ZXMoa2VkW2xhYmVsXSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gYXJyYXlFcXVhbHMoYXIxLCBhcjIpIHtcbiAgcmV0dXJuIGFyMS5sZW5ndGggPT09IGFyMi5sZW5ndGggJiYgYXIxLmV2ZXJ5KCh2YWwsIGluZGV4KSA9PiB2YWwgPT09IGFyMltpbmRleF0pO1xufVxuZnVuY3Rpb24gZXh0cmFjdEVsZW1lbnRWYWx1ZXMoZWxlbWVudCwgdmFsdWVzKSB7XG4gIGxldCBkYXRhID0gW107XG4gIHRyeSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSAmJiAhKHR5cGVvZiBlbGVtZW50ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gZWxlbWVudClcbiAgICAgICAgZXh0cmFjdEVsZW1lbnRWYWx1ZXMoZWxlbWVudFtrXSwgdmFsdWVzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBkYXRhID0gdmFsdWVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBub3dVVEMoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbn1cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmICh0eXBlb2Ygc3RvcCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc3RvcCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAodHlwZW9mIHN0ZXAgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHN0ZXAgPSAxO1xuICB9XG4gIGlmIChzdGVwID4gMCAmJiBzdGFydCA+PSBzdG9wIHx8IHN0ZXAgPCAwICYmIHN0YXJ0IDw9IHN0b3ApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgc3RlcCA+IDAgPyBpIDwgc3RvcCA6IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICByZXN1bHQucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaW50VG9CeXRlcyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGluZGV4ID0gYnl0ZUFycmF5Lmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICBjb25zdCBieXRlID0gdmFsdWUgJiAyNTU7XG4gICAgYnl0ZUFycmF5W2luZGV4XSA9IGJ5dGU7XG4gICAgdmFsdWUgPSAodmFsdWUgLSBieXRlKSAvIDI1NjtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuZnVuY3Rpb24gYnl0ZXNUb0ludChhcikge1xuICBsZXQgdmFsdWUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSAqIDI1NiArIGFyW2ldO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFDRENBdHRhY2htZW50KGFuYykge1xuICBjb25zdCBwcmVmaXhlciA9IG5ldyBQcmVmaXhlcih7IHFiNjQ6IGFuYy5wcmUgfSk7XG4gIGNvbnN0IHNlcW5lciA9IG5ldyBTZXFuZXIoeyBzbjogYW5jLnNuIH0pO1xuICBjb25zdCBzYWlkZXIgPSBuZXcgU2FpZGVyKHsgcWI2NDogYW5jLmtlZFtcImRcIl0gfSk7XG4gIGNvbnN0IGNyYXcgPSBuZXcgVWludDhBcnJheSgpO1xuICBjb25zdCBjdHIgPSBuZXcgQ291bnRlcih7IGNvZGU6IEN0ckRleC5TZWFsU291cmNlVHJpcGxlcywgY291bnQ6IDEgfSkucWI2NGI7XG4gIGNvbnN0IHByZWZpeCA9IHByZWZpeGVyLnFiNjRiO1xuICBjb25zdCBzZXEgPSBzZXFuZXIucWI2NGI7XG4gIGNvbnN0IHNhaWQgPSBzYWlkZXIucWI2NGI7XG4gIGNvbnN0IG5ld0NyYXcgPSBuZXcgVWludDhBcnJheShcbiAgICBjcmF3Lmxlbmd0aCArIGN0ci5sZW5ndGggKyBwcmVmaXgubGVuZ3RoICsgc2VxLmxlbmd0aCArIHNhaWQubGVuZ3RoXG4gICk7XG4gIG5ld0NyYXcuc2V0KGNyYXcpO1xuICBuZXdDcmF3LnNldChjdHIsIGNyYXcubGVuZ3RoKTtcbiAgbmV3Q3Jhdy5zZXQocHJlZml4LCBjcmF3Lmxlbmd0aCArIGN0ci5sZW5ndGgpO1xuICBuZXdDcmF3LnNldChzZXEsIGNyYXcubGVuZ3RoICsgY3RyLmxlbmd0aCArIHByZWZpeC5sZW5ndGgpO1xuICBuZXdDcmF3LnNldChzYWlkLCBjcmF3Lmxlbmd0aCArIGN0ci5sZW5ndGggKyBwcmVmaXgubGVuZ3RoICsgc2VxLmxlbmd0aCk7XG4gIHJldHVybiBuZXdDcmF3O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSXNzRXhuQXR0YWNobWVudChhbmMpIHtcbiAgY29uc3Qgc2VxbmVyID0gbmV3IFNlcW5lcih7IHNuOiBhbmMuc24gfSk7XG4gIGNvbnN0IGFuY1NhaWRlciA9IG5ldyBTYWlkZXIoeyBxYjY0OiBhbmMua2VkW1wiZFwiXSB9KTtcbiAgY29uc3QgY291cGxlQXJyYXkgPSBuZXcgVWludDhBcnJheShcbiAgICBzZXFuZXIucWI2NGIubGVuZ3RoICsgYW5jU2FpZGVyLnFiNjRiLmxlbmd0aFxuICApO1xuICBjb3VwbGVBcnJheS5zZXQoc2VxbmVyLnFiNjRiKTtcbiAgY291cGxlQXJyYXkuc2V0KGFuY1NhaWRlci5xYjY0Yiwgc2VxbmVyLnFiNjRiLmxlbmd0aCk7XG4gIGNvbnN0IGNvdW50ZXIgPSBuZXcgQ291bnRlcih7XG4gICAgY29kZTogQ3RyRGV4LlNlYWxTb3VyY2VDb3VwbGVzLFxuICAgIGNvdW50OiAxXG4gIH0pO1xuICBjb25zdCBjb3VudGVyUWI2NGIgPSBjb3VudGVyLnFiNjRiO1xuICBjb25zdCBhdGMgPSBuZXcgVWludDhBcnJheShjb3VudGVyLnFiNjRiLmxlbmd0aCArIGNvdXBsZUFycmF5Lmxlbmd0aCk7XG4gIGF0Yy5zZXQoY291bnRlclFiNjRiKTtcbiAgYXRjLnNldChjb3VwbGVBcnJheSwgY291bnRlclFiNjRiLmxlbmd0aCk7XG4gIGlmIChhdGMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGF0dGFjaG1lbnRzIHNpemU6ICR7YXRjLmxlbmd0aH0sIG5vbi1pbnRlZ3JhbCBxdWFkbGV0cyBkZXRlY3RlZC5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBwY250ID0gbmV3IENvdW50ZXIoe1xuICAgIGNvZGU6IEN0ckRleC5BdHRhY2hlZE1hdGVyaWFsUXVhZGxldHMsXG4gICAgY291bnQ6IE1hdGguZmxvb3IoYXRjLmxlbmd0aCAvIDQpXG4gIH0pO1xuICBjb25zdCBtc2cgPSBuZXcgVWludDhBcnJheShwY250LnFiNjRiLmxlbmd0aCArIGF0Yy5sZW5ndGgpO1xuICBtc2cuc2V0KHBjbnQucWI2NGIpO1xuICBtc2cuc2V0KGF0YywgcGNudC5xYjY0Yi5sZW5ndGgpO1xuICByZXR1cm4gbXNnO1xufVxuXG4vLyBzcmMva2VyaS9jb3JlL2VuY3J5cHRlci50c1xudmFyIEVuY3J5cHRlciA9IGNsYXNzIGV4dGVuZHMgTWF0dGVyIHtcbiAgX2VuY3J5cHQ7XG4gIGNvbnN0cnVjdG9yKHsgcmF3LCBjb2RlID0gTXRyRGV4LlgyNTUxOSwgcWI2NCwgcWI2NGIsIHFiMiB9LCB2ZXJrZXkgPSBudWxsKSB7XG4gICAgaWYgKHJhdyA9PSB2b2lkIDAgJiYgdmVya2V5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHZlcmZlciA9IG5ldyBWZXJmZXIoeyBxYjY0YjogdmVya2V5IH0pO1xuICAgICAgaWYgKCFBcnJheS5mcm9tKFtNdHJEZXguRWQyNTUxOU4sIE10ckRleC5FZDI1NTE5XSkuaW5jbHVkZXMoXG4gICAgICAgIHZlcmZlci5jb2RlXG4gICAgICApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5zdXBwb3J0ZWQgdmVya2V5IGRlcml2YXRpb24gY29kZSA9ICR7dmVyZmVyLmNvZGV9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJhdyA9IGxpYnNvZGl1bTUuY3J5cHRvX3NpZ25fZWQyNTUxOV9wa190b19jdXJ2ZTI1NTE5KHZlcmZlci5yYXcpO1xuICAgIH1cbiAgICBzdXBlcih7IHJhdywgY29kZSwgcWI2NCwgcWI2NGIsIHFiMiB9KTtcbiAgICBpZiAodGhpcy5jb2RlID09IE10ckRleC5YMjU1MTkpIHtcbiAgICAgIHRoaXMuX2VuY3J5cHQgPSB0aGlzLl94MjU1MTk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jcnlwdGVyIGNvZGUgPSAke3RoaXMuY29kZX0uYCk7XG4gICAgfVxuICB9XG4gIHZlcmlmeVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IHNpZ25lciA9IG5ldyBTaWduZXIoeyBxYjY0Yjogc2VlZCB9KTtcbiAgICBjb25zdCBrZXlwYWlyID0gbGlic29kaXVtNS5jcnlwdG9fc2lnbl9zZWVkX2tleXBhaXIoc2lnbmVyLnJhdyk7XG4gICAgY29uc3QgcHVia2V5ID0gbGlic29kaXVtNS5jcnlwdG9fc2lnbl9lZDI1NTE5X3BrX3RvX2N1cnZlMjU1MTkoXG4gICAgICBrZXlwYWlyLnB1YmxpY0tleVxuICAgICk7XG4gICAgcmV0dXJuIGFycmF5RXF1YWxzKHB1YmtleSwgdGhpcy5yYXcpO1xuICB9XG4gIGVuY3J5cHQoc2VyID0gbnVsbCwgbWF0dGVyID0gbnVsbCkge1xuICAgIGlmIChzZXIgPT0gbnVsbCAmJiBtYXR0ZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVpdGhlciBzZXIgbm9yIG1hdHRlciBhcmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoc2VyICE9IG51bGwpIHtcbiAgICAgIG1hdHRlciA9IG5ldyBNYXR0ZXIoeyBxYjY0Yjogc2VyIH0pO1xuICAgIH1cbiAgICBsZXQgY29kZTtcbiAgICBpZiAobWF0dGVyLmNvZGUgPT0gTXRyRGV4LlNhbHRfMTI4KSB7XG4gICAgICBjb2RlID0gTXRyRGV4LlgyNTUxOV9DaXBoZXJfU2FsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IE10ckRleC5YMjU1MTlfQ2lwaGVyX1NlZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbmNyeXB0KG1hdHRlci5xYjY0LCB0aGlzLnJhdywgY29kZSk7XG4gIH1cbiAgX3gyNTUxOShzZXIsIHB1YmtleSwgY29kZSkge1xuICAgIGNvbnN0IHJhdyA9IGxpYnNvZGl1bTUuY3J5cHRvX2JveF9zZWFsKHNlciwgcHVia2V5KTtcbiAgICByZXR1cm4gbmV3IENpcGhlcih7IHJhdywgY29kZSB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9tYW5hZ2VyLnRzXG52YXIgQWxnb3MgPSAvKiBAX19QVVJFX18gKi8gKChBbGdvczIpID0+IHtcbiAgQWxnb3MyW1wicmFuZHlcIl0gPSBcInJhbmR5XCI7XG4gIEFsZ29zMltcInNhbHR5XCJdID0gXCJzYWx0eVwiO1xuICBBbGdvczJbXCJncm91cFwiXSA9IFwiZ3JvdXBcIjtcbiAgQWxnb3MyW1wiZXh0ZXJuXCJdID0gXCJleHRlcm5cIjtcbiAgcmV0dXJuIEFsZ29zMjtcbn0pKEFsZ29zIHx8IHt9KTtcbnZhciBQdWJMb3QgPSBjbGFzcyB7XG4gIHB1YnMgPSBuZXcgQXJyYXkoKTtcbiAgLy8gbGlzdCBxYjY0IHB1YmxpYyBrZXlzLlxuICByaWR4ID0gMDtcbiAgLy8gIGluZGV4IG9mIHJvdGF0aW9uIChlc3QgZXZlbnQpIHRoYXQgdXNlcyBwdWJsaWMga2V5IHNldFxuICBraWR4ID0gMDtcbiAgLy8gIGluZGV4IG9mIGtleSBpbiBzZXF1ZW5jZSBvZiBwdWJsaWMga2V5c1xuICBkdCA9IFwiXCI7XG4gIC8vIGRhdGV0aW1lIElTTzg2MDEgd2hlbiBrZXkgc2V0IGNyZWF0ZWRcbn07XG52YXIgUHJlU2l0ID0gY2xhc3Mge1xuICBvbGQgPSBuZXcgUHViTG90KCk7XG4gIC8vcHJldmlvdXMgcHVibG90XG4gIG5ldyA9IG5ldyBQdWJMb3QoKTtcbiAgLy9uZXdseSBjdXJyZW50IHB1YmxvdFxuICBueHQgPSBuZXcgUHViTG90KCk7XG4gIC8vbmV4dCBwdWJsaWMgcHVibG90XG59O1xudmFyIFByZVBybSA9IGNsYXNzIHtcbiAgcGlkeCA9IDA7XG4gIC8vIHByZWZpeCBpbmRleCBmb3IgdGhpcyBrZXlwYWlyIHNlcXVlbmNlXG4gIGFsZ28gPSBcInNhbHR5XCIgLyogc2FsdHkgKi87XG4gIC8vIHNhbHR5IGRlZmF1bHQgdXNlcyBpbmRpY2VzIGFuZCBzYWx0IHRvIGNyZWF0ZSBuZXcga2V5IHBhaXJzXG4gIHNhbHQgPSBcIlwiO1xuICAvLyBlbXB0eSBzYWx0ICB1c2VkIGZvciBzYWx0eSBhbGdvLlxuICBzdGVtID0gXCJcIjtcbiAgLy8gZGVmYXVsdCB1bmlxdWUgcGF0aCBzdGVtIGZvciBzYWx0eSBhbGdvXG4gIHRpZXIgPSBcIlwiO1xuICAvLyBzZWN1cml0eSB0aWVyIGZvciBzdHJldGNoIGluZGV4IHNhbHR5IGFsZ29cbn07XG52YXIgUHViU2V0ID0gY2xhc3Mge1xuICBwdWJzID0gbmV3IEFycmF5KCk7XG4gIC8vIGxpc3QgcWI2NCBwdWJsaWMga2V5cy5cbn07XG52YXIgUHViUGF0aCA9IGNsYXNzIHtcbiAgcGF0aCA9IFwiXCI7XG4gIGNvZGUgPSBcIlwiO1xuICB0aWVyID0gXCJoaWdoXCIgLyogaGlnaCAqLztcbiAgdGVtcCA9IGZhbHNlO1xufTtcbnZhciBLZXlzID0gY2xhc3Mge1xuICBfc2lnbmVycztcbiAgX3BhdGhzO1xuICBjb25zdHJ1Y3RvcihzaWduZXJzLCBwYXRocykge1xuICAgIHRoaXMuX3NpZ25lcnMgPSBzaWduZXJzO1xuICAgIGlmIChwYXRocyAhPSB2b2lkIDApIHtcbiAgICAgIGlmIChzaWduZXJzLmxlbmd0aCAhPSBwYXRocy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSWYgcGF0aHMgYXJlIHByb3ZpZGVkLCB0aGV5IG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHNpZ25lcnNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wYXRocyA9IHBhdGhzO1xuICB9XG4gIGdldCBwYXRocygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aHM7XG4gIH1cbiAgZ2V0IHNpZ25lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25lcnM7XG4gIH1cbn07XG52YXIgUmFuZHlDcmVhdG9yID0gY2xhc3Mge1xuICBjcmVhdGUoY29kZXMgPSB2b2lkIDAsIGNvdW50ID0gMSwgY29kZSA9IE10ckRleC5FZDI1NTE5X1NlZWQsIHRyYW5zZmVyYWJsZSA9IHRydWUpIHtcbiAgICBjb25zdCBzaWduZXJzID0gbmV3IEFycmF5KCk7XG4gICAgaWYgKGNvZGVzID09IHZvaWQgMCkge1xuICAgICAgY29kZXMgPSBuZXcgQXJyYXkoY291bnQpLmZpbGwoY29kZSk7XG4gICAgfVxuICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24oY29kZTIpIHtcbiAgICAgIHNpZ25lcnMucHVzaChcbiAgICAgICAgbmV3IFNpZ25lcih7IGNvZGU6IGNvZGUyLCB0cmFuc2ZlcmFibGUgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBLZXlzKHNpZ25lcnMpO1xuICB9XG4gIGdldCBzYWx0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGdldCBzdGVtKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGdldCB0aWVyKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xudmFyIFNhbHR5Q3JlYXRvciA9IGNsYXNzIHtcbiAgc2FsdGVyO1xuICBfc3RlbTtcbiAgY29uc3RydWN0b3Ioc2FsdCA9IHZvaWQgMCwgdGllciA9IHZvaWQgMCwgc3RlbSA9IHZvaWQgMCkge1xuICAgIHRoaXMuc2FsdGVyID0gbmV3IFNhbHRlcih7IHFiNjQ6IHNhbHQsIHRpZXIgfSk7XG4gICAgdGhpcy5fc3RlbSA9IHN0ZW0gPT0gdm9pZCAwID8gXCJcIiA6IHN0ZW07XG4gIH1cbiAgZ2V0IHNhbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FsdGVyLnFiNjQ7XG4gIH1cbiAgZ2V0IHN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZW07XG4gIH1cbiAgZ2V0IHRpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FsdGVyLnRpZXI7XG4gIH1cbiAgY3JlYXRlKGNvZGVzID0gdm9pZCAwLCBjb3VudCA9IDEsIGNvZGUgPSBNdHJEZXguRWQyNTUxOV9TZWVkLCB0cmFuc2ZlcmFibGUgPSB0cnVlLCBwaWR4ID0gMCwgcmlkeCA9IDAsIGtpZHggPSAwLCB0ZW1wID0gZmFsc2UpIHtcbiAgICBjb25zdCBzaWduZXJzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgcGF0aHMgPSBuZXcgQXJyYXkoKTtcbiAgICBpZiAoY29kZXMgPT0gdm9pZCAwKSB7XG4gICAgICBjb2RlcyA9IG5ldyBBcnJheShjb3VudCkuZmlsbChjb2RlKTtcbiAgICB9XG4gICAgY29kZXMuZm9yRWFjaCgoY29kZTIsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcGF0aCA9IHRoaXMuc3RlbSA9PSBcIlwiID8gcGlkeC50b1N0cmluZygxNikgOiB0aGlzLnN0ZW0gKyByaWR4LnRvU3RyaW5nKDE2KSArIChraWR4ICsgaWR4KS50b1N0cmluZygxNik7XG4gICAgICBzaWduZXJzLnB1c2goXG4gICAgICAgIHRoaXMuc2FsdGVyLnNpZ25lcihjb2RlMiwgdHJhbnNmZXJhYmxlLCBwYXRoLCB0aGlzLnRpZXIsIHRlbXApXG4gICAgICApO1xuICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEtleXMoc2lnbmVycywgcGF0aHMpO1xuICB9XG59O1xudmFyIENyZWF0b3J5ID0gY2xhc3Mge1xuICBfbWFrZTtcbiAgY29uc3RydWN0b3IoYWxnbyA9IFwic2FsdHlcIiAvKiBzYWx0eSAqLykge1xuICAgIHN3aXRjaCAoYWxnbykge1xuICAgICAgY2FzZSBcInJhbmR5XCIgLyogcmFuZHkgKi86XG4gICAgICAgIHRoaXMuX21ha2UgPSB0aGlzLl9tYWtlUmFuZHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNhbHR5XCIgLyogc2FsdHkgKi86XG4gICAgICAgIHRoaXMuX21ha2UgPSB0aGlzLl9tYWtlU2FsdHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhbGdvPSR7YWxnb31gKTtcbiAgICB9XG4gIH1cbiAgbWFrZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2UoLi4uYXJncyk7XG4gIH1cbiAgX21ha2VSYW5keSgpIHtcbiAgICByZXR1cm4gbmV3IFJhbmR5Q3JlYXRvcigpO1xuICB9XG4gIF9tYWtlU2FsdHkoLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgU2FsdHlDcmVhdG9yKC4uLmFyZ3MpO1xuICB9XG59O1xuZnVuY3Rpb24gb3Blbk1hbmFnZXIocGFzc2NvZGUsIHNhbHQpIHtcbiAgaWYgKHBhc3Njb2RlLmxlbmd0aCA8IDIxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnJhbiAocGFzc2NvZGUgc2VlZCBtYXRlcmlhbCkgdG9vIHNob3J0LlwiKTtcbiAgfVxuICBjb25zdCBicmFuID0gTXRyRGV4LlNhbHRfMTI4ICsgXCJBXCIgKyBwYXNzY29kZS5zdWJzdHJpbmcoMCwgMjEpO1xuICBjb25zdCBzaWduZXIgPSBuZXcgU2FsdGVyKHsgcWI2NDogYnJhbiB9KS5zaWduZXIoXG4gICAgTXRyRGV4LkVkMjU1MTlfU2VlZCxcbiAgICBmYWxzZVxuICApO1xuICBjb25zdCBzZWVkID0gc2lnbmVyLnFiNjQ7XG4gIGNvbnN0IGFlaWQgPSBzaWduZXIudmVyZmVyLnFiNjQ7XG4gIGxldCBhbGdvO1xuICBjb25zdCBzYWx0ZXIgPSBzYWx0ICE9IHZvaWQgMCA/IG5ldyBTYWx0ZXIoeyBxYjY0OiBzYWx0IH0pIDogdm9pZCAwO1xuICBpZiAoc2FsdCAhPSB2b2lkIDApIHtcbiAgICBhbGdvID0gXCJzYWx0eVwiIC8qIHNhbHR5ICovO1xuICB9IGVsc2Uge1xuICAgIGFsZ28gPSBcInJhbmR5XCIgLyogcmFuZHkgKi87XG4gIH1cbiAgcmV0dXJuIG5ldyBNYW5hZ2VyKHsgc2VlZCwgYWVpZCwgYWxnbywgc2FsdGVyIH0pO1xufVxudmFyIE1hbmFnZXIgPSBjbGFzcyB7XG4gIF9zZWVkO1xuICBfc2FsdDtcbiAgX2VuY3J5cHRlcjtcbiAgX2RlY3J5cHRlcjtcbiAgX2tzO1xuICBjb25zdHJ1Y3Rvcih7IGtzLCBzZWVkLCBhZWlkLCBwaWR4LCBhbGdvLCBzYWx0ZXIsIHRpZXIgfSkge1xuICAgIHRoaXMuX2tzID0ga3MgPT0gdm9pZCAwID8gbmV3IEtlZXBlcigpIDoga3M7XG4gICAgdGhpcy5fc2VlZCA9IHNlZWQ7XG4gICAgdGhpcy5fZW5jcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX2RlY3J5cHRlciA9IHZvaWQgMDtcbiAgICBhZWlkID0gYWVpZCA9PSB2b2lkIDAgPyB2b2lkIDAgOiBhZWlkO1xuICAgIHBpZHggPSBwaWR4ID09IHZvaWQgMCA/IDAgOiBwaWR4O1xuICAgIGFsZ28gPSBhbGdvID09IHZvaWQgMCA/IFwic2FsdHlcIiAvKiBzYWx0eSAqLyA6IGFsZ287XG4gICAgY29uc3Qgc2FsdCA9IHNhbHRlcj8ucWI2NDtcbiAgICB0aWVyID0gdGllciA9PSB2b2lkIDAgPyBcImxvd1wiIC8qIGxvdyAqLyA6IHRpZXI7XG4gICAgaWYgKHRoaXMucGlkeCA9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucGlkeCA9IHBpZHg7XG4gICAgfVxuICAgIGlmICh0aGlzLmFsZ28gPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmFsZ28gPSBhbGdvO1xuICAgIH1cbiAgICBpZiAodGhpcy5zYWx0ID09IHZvaWQgMCkge1xuICAgICAgdGhpcy5zYWx0ID0gc2FsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMudGllciA9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGllciA9IHRpZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLmFlaWQgPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFlaWQoYWVpZCwgdGhpcy5fc2VlZCk7XG4gICAgfVxuICB9XG4gIGdldCBrcygpIHtcbiAgICByZXR1cm4gdGhpcy5fa3M7XG4gIH1cbiAgZ2V0IGVuY3J5cHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVyO1xuICB9XG4gIGdldCBkZWNyeXB0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRlcjtcbiAgfVxuICBnZXQgc2VlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VlZDtcbiAgfVxuICBnZXQgYWVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rcy5nZXRHYmxzKFwiYWVpZFwiKTtcbiAgfVxuICBnZXQgcGlkeCgpIHtcbiAgICBjb25zdCBwaWR4ID0gdGhpcy5rcy5nZXRHYmxzKFwicGlkeFwiKTtcbiAgICBpZiAocGlkeCAhPSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBwYXJzZUludChwaWR4LCAxNik7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0IHBpZHgocGlkeCkge1xuICAgIHRoaXMua3MucGluR2JscyhcInBpZHhcIiwgcGlkeC50b1N0cmluZygxNikpO1xuICB9XG4gIGdldCBzYWx0KCkge1xuICAgIGlmICh0aGlzLl9kZWNyeXB0ZXIgPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2FsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2FsdCA9IHRoaXMua3MuZ2V0R2JscyhcInNhbHRcIik7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGVyLmRlY3J5cHQoYihzYWx0KSkucWI2NDtcbiAgICB9XG4gIH1cbiAgc2V0IHNhbHQoc2FsdCkge1xuICAgIGlmICh0aGlzLl9lbmNyeXB0ZXIgPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zYWx0ID0gc2FsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FsdCA9IHRoaXMuX2VuY3J5cHRlci5lbmNyeXB0KGIoc2FsdCkpLnFiNjQ7XG4gICAgICB0aGlzLmtzLnBpbkdibHMoXCJzYWx0XCIsIHNhbHQpO1xuICAgIH1cbiAgfVxuICBnZXQgdGllcigpIHtcbiAgICByZXR1cm4gdGhpcy5rcy5nZXRHYmxzKFwidGllclwiKTtcbiAgfVxuICBzZXQgdGllcih0aWVyKSB7XG4gICAgdGhpcy5rcy5waW5HYmxzKFwidGllclwiLCB0aWVyKTtcbiAgfVxuICBnZXQgYWxnbygpIHtcbiAgICBjb25zdCBhID0gdGhpcy5rcy5nZXRHYmxzKFwiYWxnb1wiKTtcbiAgICBjb25zdCB0YSA9IGE7XG4gICAgcmV0dXJuIEFsZ29zW3RhXTtcbiAgfVxuICBzZXQgYWxnbyhhbGdvKSB7XG4gICAgdGhpcy5rcy5waW5HYmxzKFwiYWxnb1wiLCBhbGdvKTtcbiAgfVxuICB1cGRhdGVBZWlkKGFlaWQsIHNlZWQpIHtcbiAgICBpZiAodGhpcy5hZWlkICE9IHZvaWQgMCkge1xuICAgICAgY29uc3Qgc2VlZDIgPSBiKHRoaXMuX3NlZWQpO1xuICAgICAgaWYgKHRoaXMuX3NlZWQgPT0gdm9pZCAwIHx8ICF0aGlzLl9lbmNyeXB0ZXI/LnZlcmlmeVNlZWQoc2VlZDIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTGFzdCBzZWVkIG1pc3Npbmcgb3IgcHJvdmlkZWQgbGFzdCBzZWVkIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vdCBhc3NvY2lhdGVkIHdpdGggbGFzdCBhZWlkPSR7dGhpcy5hZWlkfS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFlaWQgIT0gXCJcIiAmJiBhZWlkICE9IHZvaWQgMCkge1xuICAgICAgaWYgKGFlaWQgIT0gdGhpcy5hZWlkKSB7XG4gICAgICAgIHRoaXMuX2VuY3J5cHRlciA9IG5ldyBFbmNyeXB0ZXIoe30sIGIoYWVpZCkpO1xuICAgICAgICBpZiAoc2VlZCA9PSB2b2lkIDAgfHwgIXRoaXMuX2VuY3J5cHRlci52ZXJpZnlTZWVkKGIoc2VlZCkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWVkIG1pc3Npbmcgb3IgcHJvdmlkZWQgc2VlZCBub3QgYXNzb2NpYXRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgIHdpdGggcHJvdmlkZWQgYWVpZD0ke2FlaWR9LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmFsZ28gPT0gXCJyYW5keVwiIC8qIHJhbmR5ICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBNYW5hZ2VyIGNvbmZpZ3VyYXRpb24sIGVuY3J5cHRpb24gbXVzdCBiZSB1c2VkIHdpdGggUmFuZHkga2V5IGNyZWF0aW9uLlwiXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbmNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHNhbHQgPSB0aGlzLnNhbHQ7XG4gICAgaWYgKHNhbHQgIT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnNhbHQgPSBzYWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVjcnlwdGVyICE9IHZvaWQgMCkge1xuICAgICAgZm9yIChjb25zdCBba2V5cywgZGF0YV0gb2YgdGhpcy5rcy5wcm1zRWxlbWVudHMoKSkge1xuICAgICAgICBpZiAoZGF0YS5zYWx0ICE9IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHNhbHRlciA9IHRoaXMuX2RlY3J5cHRlci5kZWNyeXB0KGIoZGF0YS5zYWx0KSk7XG4gICAgICAgICAgZGF0YS5zYWx0ID0gdGhpcy5fZW5jcnlwdGVyID09IHZvaWQgMCA/IHNhbHRlci5xYjY0IDogdGhpcy5fZW5jcnlwdGVyLmVuY3J5cHQobnVsbCwgc2FsdGVyKTtcbiAgICAgICAgICB0aGlzLmtzLnBpblBybXMoa2V5cywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3B1YktleSwgc2lnbmVyXSBvZiB0aGlzLmtzLnByaXNFbGVtZW50cyhcbiAgICAgICAgdGhpcy5fZGVjcnlwdGVyXG4gICAgICApKSB7XG4gICAgICAgIHRoaXMua3MucGluUHJpcyhwdWJLZXksIHNpZ25lciwgdGhpcy5fZW5jcnlwdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5rcy5waW5HYmxzKFwiYWVpZFwiLCBhZWlkKTtcbiAgICB0aGlzLl9zZWVkID0gc2VlZDtcbiAgICB0aGlzLl9kZWNyeXB0ZXIgPSBzZWVkICE9IHZvaWQgMCA/IG5ldyBEZWNyeXB0ZXIoe30sIGIoc2VlZCkpIDogdm9pZCAwO1xuICB9XG4gIGluY2VwdCh7XG4gICAgaWNvZGVzID0gdm9pZCAwLFxuICAgIGljb3VudCA9IDEsXG4gICAgaWNvZGUgPSBNdHJEZXguRWQyNTUxOV9TZWVkLFxuICAgIG5jb2RlcyA9IHZvaWQgMCxcbiAgICBuY291bnQgPSAxLFxuICAgIG5jb2RlID0gTXRyRGV4LkVkMjU1MTlfU2VlZCxcbiAgICBkY29kZSA9IE10ckRleC5CbGFrZTNfMjU2LFxuICAgIGFsZ28gPSB2b2lkIDAsXG4gICAgc2FsdCA9IHZvaWQgMCxcbiAgICBzdGVtID0gdm9pZCAwLFxuICAgIHRpZXIgPSB2b2lkIDAsXG4gICAgcm9vdGVkID0gdHJ1ZSxcbiAgICB0cmFuc2ZlcmFibGUgPSB0cnVlLFxuICAgIHRlbXAgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKHJvb3RlZCAmJiBhbGdvID09IHZvaWQgMCkge1xuICAgICAgYWxnbyA9IHRoaXMuYWxnbztcbiAgICB9XG4gICAgaWYgKHJvb3RlZCAmJiBzYWx0ID09IHZvaWQgMCkge1xuICAgICAgc2FsdCA9IHRoaXMuc2FsdDtcbiAgICB9XG4gICAgaWYgKHJvb3RlZCAmJiB0aWVyID09IHZvaWQgMCkge1xuICAgICAgdGllciA9IHRoaXMudGllcjtcbiAgICB9XG4gICAgY29uc3QgcGlkeCA9IHRoaXMucGlkeDtcbiAgICBjb25zdCByaWR4ID0gMDtcbiAgICBjb25zdCBraWR4ID0gMDtcbiAgICBjb25zdCBjcmVhdG9yID0gbmV3IENyZWF0b3J5KGFsZ28pLm1ha2Uoc2FsdCwgdGllciwgc3RlbSk7XG4gICAgaWYgKGljb2RlcyA9PSB2b2lkIDApIHtcbiAgICAgIGlmIChpY291bnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpY291bnQ9JHtpY291bnR9IG11c3QgYmUgPj0gMC5gKTtcbiAgICAgIH1cbiAgICAgIGljb2RlcyA9IG5ldyBBcnJheShpY291bnQpLmZpbGwoaWNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBpa2V5cyA9IGNyZWF0b3IuY3JlYXRlKFxuICAgICAgaWNvZGVzLFxuICAgICAgMCxcbiAgICAgIE10ckRleC5FZDI1NTE5X1NlZWQsXG4gICAgICB0cmFuc2ZlcmFibGUsXG4gICAgICBwaWR4LFxuICAgICAgcmlkeCxcbiAgICAgIGtpZHgsXG4gICAgICB0ZW1wXG4gICAgKTtcbiAgICBjb25zdCB2ZXJmZXJzID0gQXJyYXkuZnJvbShcbiAgICAgIGlrZXlzLnNpZ25lcnMsXG4gICAgICAoc2lnbmVyKSA9PiBzaWduZXIudmVyZmVyXG4gICAgKTtcbiAgICBpZiAobmNvZGVzID09IHZvaWQgMCkge1xuICAgICAgaWYgKG5jb3VudCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5jb3VudD0ke25jb3VudH0gbXVzdCBiZSA+PSAwLmApO1xuICAgICAgfVxuICAgICAgbmNvZGVzID0gbmV3IEFycmF5KG5jb3VudCkuZmlsbChuY29kZSk7XG4gICAgfVxuICAgIGNvbnN0IG5rZXlzID0gY3JlYXRvci5jcmVhdGUoXG4gICAgICBuY29kZXMsXG4gICAgICAwLFxuICAgICAgTXRyRGV4LkVkMjU1MTlfU2VlZCxcbiAgICAgIHRyYW5zZmVyYWJsZSxcbiAgICAgIHBpZHgsXG4gICAgICByaWR4ICsgMSxcbiAgICAgIGtpZHggKyBpY29kZXMubGVuZ3RoLFxuICAgICAgdGVtcFxuICAgICk7XG4gICAgY29uc3QgZGlnZXJzID0gQXJyYXkuZnJvbShcbiAgICAgIG5rZXlzLnNpZ25lcnMsXG4gICAgICAoc2lnbmVyKSA9PiBuZXcgRGlnZXIoeyBjb2RlOiBkY29kZSB9LCBzaWduZXIudmVyZmVyLnFiNjRiKVxuICAgICk7XG4gICAgY29uc3QgcHAgPSBuZXcgUHJlUHJtKCk7XG4gICAgcHAucGlkeCA9IHBpZHg7XG4gICAgcHAuYWxnbyA9IGFsZ287XG4gICAgcHAuc2FsdCA9IGNyZWF0b3Iuc2FsdC5sZW5ndGggPT0gMCB8fCB0aGlzLmVuY3J5cHRlciA9PSB2b2lkIDAgPyBcIlwiIDogdGhpcy5lbmNyeXB0ZXIuZW5jcnlwdChiKGNyZWF0b3Iuc2FsdCkpLnFiNjQ7XG4gICAgcHAuc3RlbSA9IGNyZWF0b3Iuc3RlbTtcbiAgICBwcC50aWVyID0gY3JlYXRvci50aWVyO1xuICAgIGNvbnN0IGR0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b1N0cmluZygpO1xuICAgIGNvbnN0IG53ID0gbmV3IFB1YkxvdCgpO1xuICAgIG53LnB1YnMgPSBBcnJheS5mcm9tKHZlcmZlcnMsICh2ZXJmZXIpID0+IHZlcmZlci5xYjY0KTtcbiAgICBudy5yaWR4ID0gcmlkeDtcbiAgICBudy5raWR4ID0ga2lkeDtcbiAgICBudy5kdCA9IGR0O1xuICAgIGNvbnN0IG50ID0gbmV3IFB1YkxvdCgpO1xuICAgIG50LnB1YnMgPSBBcnJheS5mcm9tKFxuICAgICAgbmtleXMuc2lnbmVycyxcbiAgICAgIChzaWduZXIpID0+IHNpZ25lci52ZXJmZXIucWI2NFxuICAgICk7XG4gICAgbnQucmlkeCA9IHJpZHggKyAxO1xuICAgIG50LmtpZHggPSBraWR4ICsgaWNvZGVzLmxlbmd0aDtcbiAgICBudC5kdCA9IGR0O1xuICAgIGNvbnN0IHBzID0gbmV3IFByZVNpdCgpO1xuICAgIHBzLm5ldyA9IG53O1xuICAgIHBzLm54dCA9IG50O1xuICAgIGNvbnN0IHByZSA9IHZlcmZlcnNbMF0ucWI2NDtcbiAgICBpZiAoIXRoaXMua3MucHV0UHJlcyhwcmUsIHZlcmZlcnNbMF0ucWI2NGIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgaW5jZXB0ZWQgcHJlPSR7cHJlfS5gKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmtzLnB1dFBybXMocHJlLCBwcCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBpbmNlcHRlZCBwcm0gZm9yIHByZT0ke3ByZX0uYCk7XG4gICAgfVxuICAgIHRoaXMucGlkeCA9IHBpZHggKyAxO1xuICAgIGlmICghdGhpcy5rcy5wdXRTaXRzKHByZSwgcHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgaW5jZXB0ZWQgc2l0IGZvciBwcmU9JHtwcmV9LmApO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmNyeXB0ZXIgIT0gdm9pZCAwKSB7XG4gICAgICBpa2V5cy5zaWduZXJzLmZvckVhY2goKHNpZ25lcikgPT4ge1xuICAgICAgICB0aGlzLmtzLnB1dFByaXMoc2lnbmVyLnZlcmZlci5xYjY0LCBzaWduZXIsIHRoaXMuZW5jcnlwdGVyKTtcbiAgICAgIH0pO1xuICAgICAgbmtleXMuc2lnbmVycy5mb3JFYWNoKChzaWduZXIpID0+IHtcbiAgICAgICAgdGhpcy5rcy5wdXRQcmlzKHNpZ25lci52ZXJmZXIucWI2NCwgc2lnbmVyLCB0aGlzLmVuY3J5cHRlcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2VuY3J5cHRlciA9PSB2b2lkIDAgJiYgaWtleXMucGF0aHMgIT0gdm9pZCAwICYmIG5rZXlzLnBhdGhzICE9IHZvaWQgMCkge1xuICAgICAgaWtleXMucGF0aHMuZm9yRWFjaCgocGF0aCwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGlrZXlzLnNpZ25lcnNbaWR4XTtcbiAgICAgICAgY29uc3QgcHB0ID0gbmV3IFB1YlBhdGgoKTtcbiAgICAgICAgcHB0LnBhdGggPSBwYXRoO1xuICAgICAgICBwcHQuY29kZSA9IGljb2Rlc1tpZHhdO1xuICAgICAgICBwcHQudGllciA9IHBwLnRpZXI7XG4gICAgICAgIHBwdC50ZW1wID0gdGVtcDtcbiAgICAgICAgdGhpcy5rcy5wdXRQdGhzKHNpZ25lci52ZXJmZXIucWI2NCwgcHB0KTtcbiAgICAgIH0pO1xuICAgICAgbmtleXMucGF0aHMuZm9yRWFjaCgocGF0aCwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IG5rZXlzLnNpZ25lcnNbaWR4XTtcbiAgICAgICAgY29uc3QgcHB0ID0gbmV3IFB1YlBhdGgoKTtcbiAgICAgICAgcHB0LnBhdGggPSBwYXRoO1xuICAgICAgICBwcHQuY29kZSA9IG5jb2Rlc1tpZHhdO1xuICAgICAgICBwcHQudGllciA9IHBwLnRpZXI7XG4gICAgICAgIHBwdC50ZW1wID0gdGVtcDtcbiAgICAgICAgdGhpcy5rcy5wdXRQdGhzKHNpZ25lci52ZXJmZXIucWI2NCwgcHB0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiaW52YWxpZCBjb25maWd1cmF0aW9uLCByYW5keSBrZXlzIHdpdGhvdXQgZW5jcnlwdGlvblwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBwdWJTZXQgPSBuZXcgUHViU2V0KCk7XG4gICAgcHViU2V0LnB1YnMgPSBwcy5uZXcucHVicztcbiAgICB0aGlzLmtzLnB1dFB1YnMocmlLZXkocHJlLCByaWR4KSwgcHViU2V0KTtcbiAgICBjb25zdCBueHRQdWJTZXQgPSBuZXcgUHViU2V0KCk7XG4gICAgbnh0UHViU2V0LnB1YnMgPSBwcy5ueHQucHVicztcbiAgICB0aGlzLmtzLnB1dFB1YnMocmlLZXkocHJlLCByaWR4ICsgMSksIG54dFB1YlNldCk7XG4gICAgcmV0dXJuIFt2ZXJmZXJzLCBkaWdlcnNdO1xuICB9XG4gIG1vdmUob2xkLCBnbnUpIHtcbiAgICBpZiAob2xkID09IGdudSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5rcy5nZXRQcmVzKG9sZCkgPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbmV4aXN0ZW50IG9sZCBwcmU9JHtvbGR9LCBub3RoaW5nIHRvIGFzc2lnbi5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMua3MuZ2V0UHJlcyhnbnUpICE9IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVleGlzdGVudCBuZXcgcHJlPSR7Z251fSBtYXkgbm90IGNsb2JiZXIuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZHBybSA9IHRoaXMua3MuZ2V0UHJtcyhvbGQpO1xuICAgIGlmIChvbGRwcm0gPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb25leGlzdGVudCBvbGQgcHJtIGZvciBwcmU9JHtvbGR9LCBub3RoaW5nIHRvIG1vdmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMua3MuZ2V0UHJtcyhnbnUpICE9IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUHJlZXhpc3RlbnQgbmV3IHBybSBmb3IgcHJlPSR7Z251fSBtYXkgbm90IGNsb2JiZXIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkc2l0ID0gdGhpcy5rcy5nZXRTaXRzKG9sZCk7XG4gICAgaWYgKG9sZHNpdCA9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vbmV4aXN0ZW50IG9sZCBzaXQgZm9yIHByZT0ke29sZH0sIG5vdGhpbmcgdG8gbW92ZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5rcy5nZXRTaXRzKGdudSkgIT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQcmVleGlzdGVudCBuZXcgc2l0IGZvciBwcmU9JHtnbnV9IG1heSBub3QgY2xvYmJlci5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMua3MucHV0UHJtcyhnbnUsIG9sZHBybSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBtb3ZpbmcgcHJtIGZyb20gb2xkIHByZT0ke29sZH0gdG8gbmV3IHByZT0ke2dudX0uYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rcy5yZW1Qcm1zKG9sZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5rcy5wdXRTaXRzKGdudSwgb2xkc2l0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIG1vdmluZyBzaXQgZnJvbSBvbGQgcHJlPSR7b2xkfSB0byBuZXcgcHJlPSR7Z251fS5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtzLnJlbVNpdHMob2xkKTtcbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBwbCA9IHRoaXMua3MuZ2V0UHVicyhyaUtleShvbGQsIGkpKTtcbiAgICAgIGlmIChwbCA9PSB2b2lkIDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMua3MucHV0UHVicyhyaUtleShnbnUsIGkpLCBwbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgbW92aW5nIHB1YnMgYXQgcHJlPSR7b2xkfSByaT0ke2l9IHRvIG5ldyBwcmU9JHtnbnV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaSA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMua3MucGluUHJlcyhvbGQsIGIoZ251KSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBhc3NpZ2luZyBuZXcgcHJlPSR7Z251fSB0byBvbGQgcHJlPSR7b2xkfS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMua3MucHV0UHJlcyhnbnUsIGIoZ251KSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIGFzc2lnaW5nIG5ldyBwcmU9JHtnbnV9LmApO1xuICAgIH1cbiAgfVxuICByb3RhdGUoe1xuICAgIHByZSxcbiAgICBuY29kZXMgPSB2b2lkIDAsXG4gICAgbmNvdW50ID0gMSxcbiAgICBuY29kZSA9IE10ckRleC5FZDI1NTE5X1NlZWQsXG4gICAgZGNvZGUgPSBNdHJEZXguQmxha2UzXzI1NixcbiAgICB0cmFuc2ZlcmFibGUgPSB0cnVlLFxuICAgIHRlbXAgPSBmYWxzZSxcbiAgICBlcmFzZSA9IHRydWVcbiAgfSkge1xuICAgIGNvbnN0IHBwID0gdGhpcy5rcy5nZXRQcm1zKHByZSk7XG4gICAgaWYgKHBwID09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0IHRvIHJvdGF0ZSBub25leGlzdGVudCBwcmU9JHtwcmV9LmApO1xuICAgIH1cbiAgICBjb25zdCBwcyA9IHRoaXMua3MuZ2V0U2l0cyhwcmUpO1xuICAgIGlmIChwcyA9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdCB0byByb3RhdGUgbm9uZXhpc3RlbnQgcHJlPSR7cHJlfS5gKTtcbiAgICB9XG4gICAgaWYgKHBzLm54dC5wdWJzID09IHZvaWQgMCB8fCBwcy5ueHQucHVicy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0IHRvIHJvdGF0ZSBub250cmFuc2ZlcmFibGUgcHJlPSR7cHJlfS5gKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkID0gcHMub2xkO1xuICAgIHBzLm9sZCA9IHBzLm5ldztcbiAgICBwcy5uZXcgPSBwcy5ueHQ7XG4gICAgaWYgKHRoaXMuYWVpZCAhPSB2b2lkIDAgJiYgdGhpcy5kZWNyeXB0ZXIgPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVW5hdXRob3JpemVkIGRlY3J5cHRpb24gYXR0ZW1wdC4gIEFlaWQgYnV0IG5vIGRlY3J5cHRlci5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdmVyZmVycyA9IG5ldyBBcnJheSgpO1xuICAgIHBzLm5ldy5wdWJzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVjcnlwdGVyICE9IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSB0aGlzLmtzLmdldFByaXMocHViLCB0aGlzLmRlY3J5cHRlcik7XG4gICAgICAgIGlmIChzaWduZXIgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHByaWtleSBpbiBkYiBmb3IgcHVia2V5PSR7cHVifWApO1xuICAgICAgICB9XG4gICAgICAgIHZlcmZlcnMucHVzaChzaWduZXIudmVyZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcmZlcnMucHVzaChuZXcgVmVyZmVyKHsgcWI2NDogcHViIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgc2FsdCA9IHBwLnNhbHQ7XG4gICAgaWYgKHNhbHQgIT0gdm9pZCAwICYmIHNhbHQgIT0gXCJcIikge1xuICAgICAgaWYgKHRoaXMuZGVjcnlwdGVyID09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb246IEFJRCBzYWx0IHdpdGggbm8gZW5jcnlwdGlvblwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzYWx0ID0gdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChiKHNhbHQpKS5xYjY0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzYWx0ID0gdGhpcy5zYWx0O1xuICAgIH1cbiAgICBjb25zdCBjcmVhdG9yID0gbmV3IENyZWF0b3J5KHBwLmFsZ28pLm1ha2Uoc2FsdCwgcHAudGllciwgcHAuc3RlbSk7XG4gICAgaWYgKG5jb2RlcyA9PSB2b2lkIDApIHtcbiAgICAgIGlmIChuY291bnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb3VudD0ke25jb3VudH0gbXVzdCBiZSA+PSAwYCk7XG4gICAgICB9XG4gICAgICBuY29kZXMgPSBuZXcgQXJyYXkobmNvdW50KS5maWxsKG5jb2RlKTtcbiAgICB9XG4gICAgY29uc3QgcGlkeCA9IHBwLnBpZHg7XG4gICAgY29uc3QgcmlkeCA9IHBzLm5ldy5yaWR4ICsgMTtcbiAgICBjb25zdCBraWR4ID0gcHMubnh0LmtpZHggKyBwcy5uZXcucHVicy5sZW5ndGg7XG4gICAgY29uc3Qga2V5cyA9IGNyZWF0b3IuY3JlYXRlKFxuICAgICAgbmNvZGVzLFxuICAgICAgMCxcbiAgICAgIFwiXCIsXG4gICAgICB0cmFuc2ZlcmFibGUsXG4gICAgICBwaWR4LFxuICAgICAgcmlkeCxcbiAgICAgIGtpZHgsXG4gICAgICB0ZW1wXG4gICAgKTtcbiAgICBjb25zdCBkaWdlcnMgPSBBcnJheS5mcm9tKFxuICAgICAga2V5cy5zaWduZXJzLFxuICAgICAgKHNpZ25lcikgPT4gbmV3IERpZ2VyKHsgY29kZTogZGNvZGUgfSwgc2lnbmVyLnZlcmZlci5xYjY0YilcbiAgICApO1xuICAgIGNvbnN0IGR0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b1N0cmluZygpO1xuICAgIHBzLm54dCA9IG5ldyBQdWJMb3QoKTtcbiAgICBwcy5ueHQucHVicyA9IEFycmF5LmZyb20oXG4gICAgICBrZXlzLnNpZ25lcnMsXG4gICAgICAoc2lnbmVyKSA9PiBzaWduZXIudmVyZmVyLnFiNjRcbiAgICApO1xuICAgIHBzLm54dC5yaWR4ID0gcmlkeDtcbiAgICBwcy5ueHQua2lkeCA9IGtpZHg7XG4gICAgcHMubnh0LmR0ID0gZHQ7XG4gICAgaWYgKCF0aGlzLmtzLnBpblNpdHMocHJlLCBwcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvYmxlbSB1cGRhdGluZyBwdWJzaXQgZGIgZm9yIHByZT0ke3ByZX0uYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuY3J5cHRlciAhPSB2b2lkIDApIHtcbiAgICAgIGtleXMuc2lnbmVycy5mb3JFYWNoKChzaWduZXIpID0+IHtcbiAgICAgICAgdGhpcy5rcy5wdXRQcmlzKHNpZ25lci52ZXJmZXIucWI2NCwgc2lnbmVyLCB0aGlzLmVuY3J5cHRlcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2VuY3J5cHRlciA9PSB2b2lkIDAgJiYga2V5cy5wYXRocyAhPSB2b2lkIDApIHtcbiAgICAgIGtleXMucGF0aHMuZm9yRWFjaCgocGF0aCwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGtleXMuc2lnbmVyc1tpZHhdO1xuICAgICAgICBjb25zdCBwcHQgPSBuZXcgUHViUGF0aCgpO1xuICAgICAgICBwcHQucGF0aCA9IHBhdGg7XG4gICAgICAgIHBwdC50aWVyID0gcHAudGllcjtcbiAgICAgICAgcHB0LnRlbXAgPSB0ZW1wO1xuICAgICAgICB0aGlzLmtzLnB1dFB0aHMoc2lnbmVyLnZlcmZlci5xYjY0LCBwcHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJpbnZhbGlkIGNvbmZpZ3VyYXRpb24sIHJhbmR5IGtleXMgd2l0aG91dCBlbmNyeXB0aW9uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG5ld1BzID0gbmV3IFB1YlNldCgpO1xuICAgIG5ld1BzLnB1YnMgPSBwcy5ueHQucHVicztcbiAgICB0aGlzLmtzLnB1dFB1YnMocmlLZXkocHJlLCBwcy5ueHQucmlkeCksIG5ld1BzKTtcbiAgICBpZiAoZXJhc2UpIHtcbiAgICAgIG9sZC5wdWJzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgICB0aGlzLmtzLnJlbVByaXMocHViKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW3ZlcmZlcnMsIGRpZ2Vyc107XG4gIH1cbiAgc2lnbih7XG4gICAgc2VyLFxuICAgIHB1YnMgPSB2b2lkIDAsXG4gICAgdmVyZmVycyA9IHZvaWQgMCxcbiAgICBpbmRleGVkID0gdHJ1ZSxcbiAgICBpbmRpY2VzID0gdm9pZCAwLFxuICAgIG9uZGljZXMgPSB2b2lkIDBcbiAgfSkge1xuICAgIGNvbnN0IHNpZ25lcnMgPSBuZXcgQXJyYXkoKTtcbiAgICBpZiAocHVicyA9PSB2b2lkIDAgJiYgdmVyZmVycyA9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB1YnMgb3IgdmVyZmVycyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKHB1YnMgIT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5hZWlkICE9IHZvaWQgMCAmJiB0aGlzLmRlY3J5cHRlciA9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5hdXRob3JpemVkIGRlY3J5cHRpb24gYXR0ZW1wdC4gIEFlaWQgYnV0IG5vIGRlY3J5cHRlci5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHVicy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVjcnlwdGVyICE9IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHNpZ25lciA9IHRoaXMua3MuZ2V0UHJpcyhwdWIsIHRoaXMuZGVjcnlwdGVyKTtcbiAgICAgICAgICBpZiAoc2lnbmVyID09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgTWlzc2luZyBwcmlrZXkgaW4gZGIgZm9yIHB1YmtleT0ke3B1Yn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB2ZXJmZXIgPSBuZXcgVmVyZmVyKHsgcWI2NDogcHViIH0pO1xuICAgICAgICAgIGNvbnN0IHBwdCA9IHRoaXMua3MuZ2V0UHRocyhwdWIpO1xuICAgICAgICAgIGlmIChwcHQgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBNaXNzaW5nIHByaWtleSBpbiBkYiBmb3IgcHVia2V5PSR7cHVifWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNhbHRlciA9IG5ldyBTYWx0ZXIoeyBxYjY0OiB0aGlzLnNhbHQgfSk7XG4gICAgICAgICAgc2lnbmVycy5wdXNoKFxuICAgICAgICAgICAgc2FsdGVyLnNpZ25lcihcbiAgICAgICAgICAgICAgcHB0LmNvZGUsXG4gICAgICAgICAgICAgIHZlcmZlci50cmFuc2ZlcmFibGUsXG4gICAgICAgICAgICAgIHBwdC5wYXRoLFxuICAgICAgICAgICAgICBwcHQudGllcixcbiAgICAgICAgICAgICAgcHB0LnRlbXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVyZmVycy5mb3JFYWNoKCh2ZXJmZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVjcnlwdGVyICE9IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHNpZ25lciA9IHRoaXMua3MuZ2V0UHJpcyh2ZXJmZXIucWI2NCwgdGhpcy5kZWNyeXB0ZXIpO1xuICAgICAgICAgIGlmIChzaWduZXIgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBNaXNzaW5nIHByaWtleSBpbiBkYiBmb3IgcHVia2V5PSR7dmVyZmVyLnFiNjR9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHB0ID0gdGhpcy5rcy5nZXRQdGhzKHZlcmZlci5xYjY0KTtcbiAgICAgICAgICBpZiAocHB0ID09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgTWlzc2luZyBwcmlrZXkgaW4gZGIgZm9yIHB1YmtleT0ke3ZlcmZlci5xYjY0fWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNhbHRlciA9IG5ldyBTYWx0ZXIoeyBxYjY0OiB0aGlzLnNhbHQgfSk7XG4gICAgICAgICAgc2lnbmVycy5wdXNoKFxuICAgICAgICAgICAgc2FsdGVyLnNpZ25lcihcbiAgICAgICAgICAgICAgcHB0LmNvZGUsXG4gICAgICAgICAgICAgIHZlcmZlci50cmFuc2ZlcmFibGUsXG4gICAgICAgICAgICAgIHBwdC5wYXRoLFxuICAgICAgICAgICAgICBwcHQudGllcixcbiAgICAgICAgICAgICAgcHB0LnRlbXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZGljZXMgIT0gdm9pZCAwICYmIGluZGljZXMubGVuZ3RoICE9IHNpZ25lcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNaXNtYXRjaCBpbmRpY2VzIGxlbmd0aD0ke2luZGljZXMubGVuZ3RofSBhbmQgcmVzdWx0YW50IHNpZ25lcnMgbGVuZ3RoPSR7c2lnbmVycy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9uZGljZXMgIT0gdm9pZCAwICYmIG9uZGljZXMubGVuZ3RoICE9IHNpZ25lcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNaXNtYXRjaCBvbmRpY2VzIGxlbmd0aD0ke29uZGljZXMubGVuZ3RofSBhbmQgcmVzdWx0YW50IHNpZ25lcnMgbGVuZ3RoPSR7c2lnbmVycy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ZWQpIHtcbiAgICAgIGNvbnN0IHNpZ2VycyA9IG5ldyBBcnJheSgpO1xuICAgICAgc2lnbmVycy5mb3JFYWNoKChzaWduZXIsIGlkeCkgPT4ge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKGluZGljZXMgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgaSA9IGluZGljZXNbaWR4XTtcbiAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgc2lnbmluZyBpbmRleCA9ICR7aX0sIG5vdCB3aG9sZSBudW1iZXIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IGlkeDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbztcbiAgICAgICAgaWYgKG9uZGljZXMgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgbyA9IG9uZGljZXNbaWR4XTtcbiAgICAgICAgICBpZiAobyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIG90aGVyIHNpZ25pbmcgaW5kZXggPSB7b30sIG5vdCBOb25lIG9yIG5vdCB3aG9sZSBudW1iZXIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25seSA9IG8gPT0gdm9pZCAwO1xuICAgICAgICBzaWdlcnMucHVzaChzaWduZXIuc2lnbihzZXIsIGksIG9ubHksIG8pKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNpZ2VycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2lnYXJzID0gbmV3IEFycmF5KCk7XG4gICAgICBzaWduZXJzLmZvckVhY2goKHNpZ25lcikgPT4ge1xuICAgICAgICBjaWdhcnMucHVzaChzaWduZXIuc2lnbihzZXIpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNpZ2FycztcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiByaUtleShwcmUsIHJpZHgpIHtcbiAgcmV0dXJuIHByZSArIFwiLlwiICsgcmlkeC50b1N0cmluZygxNikucGFkU3RhcnQoMzIsIFwiMFwiKTtcbn1cbnZhciBLZWVwZXIgPSBjbGFzcyB7XG4gIF9nYmxzO1xuICBfcHJpcztcbiAgX3B0aHM7XG4gIF9wcmVzO1xuICBfcHJtcztcbiAgX3NpdHM7XG4gIF9wdWJzO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9nYmxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9zaXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXRHYmxzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9nYmxzLmdldChrZXkpO1xuICB9XG4gIHBpbkdibHMoa2V5LCB2YWwpIHtcbiAgICB0aGlzLl9nYmxzLnNldChrZXksIHZhbCk7XG4gIH1cbiAgcHJtc0VsZW1lbnRzKCkge1xuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheSgpO1xuICAgIHRoaXMuX3BybXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgb3V0LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGdldFBybXMoa2V5cykge1xuICAgIHJldHVybiB0aGlzLl9wcm1zLmdldChrZXlzKTtcbiAgfVxuICBwaW5Qcm1zKGtleXMsIGRhdGEpIHtcbiAgICB0aGlzLl9wcm1zLnNldChrZXlzLCBkYXRhKTtcbiAgfVxuICBwdXRQcm1zKGtleXMsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5fcHJtcy5oYXMoa2V5cykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcHJtcy5zZXQoa2V5cywgZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVtUHJtcyhrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BybXMuZGVsZXRlKGtleXMpO1xuICB9XG4gIHByaXNFbGVtZW50cyhkZWNyeXB0ZXIpIHtcbiAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkoKTtcbiAgICB0aGlzLl9wcmlzLmZvckVhY2goZnVuY3Rpb24odmFsLCBwdWJLZXkpIHtcbiAgICAgIGNvbnN0IHZlcmZlciA9IG5ldyBWZXJmZXIoeyBxYjY0OiBwdWJLZXkgfSk7XG4gICAgICBjb25zdCBzaWduZXIgPSBkZWNyeXB0ZXIuZGVjcnlwdCh2YWwsIG51bGwsIHZlcmZlci50cmFuc2ZlcmFibGUpO1xuICAgICAgb3V0LnB1c2goW3B1YktleSwgc2lnbmVyXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBwaW5QcmlzKHB1YktleSwgc2lnbmVyLCBlbmNyeXB0ZXIpIHtcbiAgICBjb25zdCBjaXBoZXIgPSBlbmNyeXB0ZXIuZW5jcnlwdChudWxsLCBzaWduZXIpO1xuICAgIHRoaXMuX3ByaXMuc2V0KHB1YktleSwgY2lwaGVyLnFiNjRiKTtcbiAgfVxuICBwdXRQcmlzKHB1YktleSwgc2lnbmVyLCBlbmNyeXB0ZXIpIHtcbiAgICBpZiAodGhpcy5fcHJpcy5oYXMocHViS2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjaXBoZXIgPSBlbmNyeXB0ZXIuZW5jcnlwdChudWxsLCBzaWduZXIpO1xuICAgIHRoaXMuX3ByaXMuc2V0KHB1YktleSwgY2lwaGVyLnFiNjRiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRQcmlzKHB1YktleSwgZGVjcnlwdGVyKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fcHJpcy5nZXQocHViS2V5KTtcbiAgICBpZiAodmFsID09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgdmVyZmVyID0gbmV3IFZlcmZlcih7IHFiNjQ6IHB1YktleSB9KTtcbiAgICByZXR1cm4gZGVjcnlwdGVyLmRlY3J5cHQodmFsLCBudWxsLCB2ZXJmZXIudHJhbnNmZXJhYmxlKTtcbiAgfVxuICBwaW5QdGhzKHB1YktleSwgdmFsKSB7XG4gICAgdGhpcy5fcHRocy5zZXQocHViS2V5LCB2YWwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHB1dFB0aHMocHViS2V5LCB2YWwpIHtcbiAgICBpZiAodGhpcy5fcHRocy5oYXMocHViS2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9wdGhzLnNldChwdWJLZXksIHZhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0UHRocyhwdWJLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHRocy5nZXQocHViS2V5KTtcbiAgfVxuICByZW1QcmlzKHB1YktleSkge1xuICAgIHRoaXMuX3ByaXMuZGVsZXRlKHB1YktleSk7XG4gIH1cbiAgZ2V0UHJlcyhwcmUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlcy5nZXQocHJlKTtcbiAgfVxuICBwaW5QcmVzKHByZSwgdmFsKSB7XG4gICAgdGhpcy5fcHJlcy5zZXQocHJlLCB2YWwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHB1dFByZXMocHJlLCB2YWwpIHtcbiAgICBpZiAodGhpcy5fcHJlcy5oYXMocHJlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9wcmVzLnNldChwcmUsIHZhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0U2l0cyhrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpdHMuZ2V0KGtleXMpO1xuICB9XG4gIHB1dFNpdHMocHJlLCB2YWwpIHtcbiAgICBpZiAodGhpcy5fc2l0cy5oYXMocHJlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zaXRzLnNldChwcmUsIHZhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcGluU2l0cyhwcmUsIHZhbCkge1xuICAgIHRoaXMuX3NpdHMuc2V0KHByZSwgdmFsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW1TaXRzKGtleXMpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l0cy5kZWxldGUoa2V5cyk7XG4gIH1cbiAgZ2V0UHVicyhrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YnMuZ2V0KGtleXMpO1xuICB9XG4gIHB1dFB1YnMoa2V5cywgZGF0YSkge1xuICAgIGlmICh0aGlzLl9wdWJzLmhhcyhrZXlzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9wdWJzLnNldChrZXlzLCBkYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS90aG9sZGVyLnRzXG5pbXBvcnQgeyBmb3JtYXQsIHN1bSwgZnJhY3Rpb24gfSBmcm9tIFwibWF0aGpzXCI7XG52YXIgVGhvbGRlciA9IGNsYXNzIHtcbiAgX3dlaWdodGVkID0gZmFsc2U7XG4gIF90aG9sZCA9IHZvaWQgMDtcbiAgX3NpemUgPSAwO1xuICBfbnVtYmVyID0gdm9pZCAwO1xuICBfc2F0aXNmeSA9IHZvaWQgMDtcbiAgLy8gcHJpdmF0ZSBfYmV4dGVyOiBhbnlcbiAgY29uc3RydWN0b3Ioa2FyZ3MpIHtcbiAgICBpZiAoa2FyZ3MudGhvbGQgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Rob2xkKGthcmdzLnRob2xkKTtcbiAgICB9IGVsc2UgaWYgKGthcmdzLmxpbWVuICE9IHZvaWQgMCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc0xpbWVuKGthcmdzLmxpbWVuKTtcbiAgICB9IGVsc2UgaWYgKGthcmdzLnNpdGggIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc1NpdGgoa2FyZ3Muc2l0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdGhyZXNob2xkIGV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9XG4gIGdldCB3ZWlnaHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2VpZ2h0ZWQ7XG4gIH1cbiAgZ2V0IHRob2xkKCkge1xuICAgIHJldHVybiB0aGlzLl90aG9sZDtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuICBnZXQgbGltZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bWJlcj8ucWI2NGI7XG4gIH1cbiAgZ2V0IHNpdGgoKSB7XG4gICAgaWYgKHRoaXMud2VpZ2h0ZWQpIHtcbiAgICAgIGxldCBzaXRoID0gdGhpcy50aG9sZC5tYXAoKGNsYXVzZSkgPT4ge1xuICAgICAgICByZXR1cm4gY2xhdXNlLm1hcCgoYykgPT4ge1xuICAgICAgICAgIGlmICgwIDwgTnVtYmVyKGMpICYmIE51bWJlcihjKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoYywgeyBmcmFjdGlvbjogXCJyYXRpb1wiIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KGMsIHsgZnJhY3Rpb246IFwiZGVjaW1hbFwiIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChzaXRoLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHNpdGggPSBzaXRoWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRob2xkLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc2l0aCk7XG4gIH1cbiAgZ2V0IG51bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2VpZ2h0ZWQgPyB2b2lkIDAgOiB0aGlzLl90aG9sZDtcbiAgfVxuICBfcHJvY2Vzc1Rob2xkKHRob2xkKSB7XG4gICAgaWYgKHR5cGVvZiB0aG9sZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Vud2VpZ2h0ZWQodGhvbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9jZXNzV2VpZ2h0ZWQodGhvbGQpO1xuICAgIH1cbiAgfVxuICBfcHJvY2Vzc0xpbWVuKGxpbWVuKSB7XG4gICAgY29uc3QgbWF0dGVyID0gbmV3IE1hdHRlcih7IHFiNjQ6IGxpbWVuIH0pO1xuICAgIGlmIChOdW1EZXguaGFzKG1hdHRlci5jb2RlKSkge1xuICAgICAgY29uc3QgbnVtYmVyID0gbmV3IENlc3JOdW1iZXIoe1xuICAgICAgICByYXc6IG1hdHRlci5yYXcsXG4gICAgICAgIGNvZGU6IG1hdHRlci5jb2RlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NVbndlaWdodGVkKG51bWJlci5udW0pO1xuICAgIH0gZWxzZSBpZiAoQmV4RGV4LmhhcyhtYXR0ZXIuY29kZSkpIHtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIGZvciBsaW1lbj1cIiArIG1hdHRlci5jb2RlKTtcbiAgICB9XG4gIH1cbiAgX3Byb2Nlc3NTaXRoKHNpdGgpIHtcbiAgICBpZiAodHlwZW9mIHNpdGggPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Vud2VpZ2h0ZWQoc2l0aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2l0aCA9PSBcInN0cmluZ1wiICYmIHNpdGguaW5kZXhPZihcIltcIikgPT0gLTEpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NVbndlaWdodGVkKHBhcnNlSW50KHNpdGgsIDE2KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBfc2l0aCA9IHNpdGg7XG4gICAgICBpZiAodHlwZW9mIHNpdGggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBfc2l0aCA9IEpTT04ucGFyc2Uoc2l0aCk7XG4gICAgICB9XG4gICAgICBpZiAoX3NpdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgd2VpZ2h0IGxpc3RcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXNrID0gX3NpdGgubWFwKCh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCAhPT0gXCJzdHJpbmdcIjtcbiAgICAgIH0pO1xuICAgICAgaWYgKG1hc2subGVuZ3RoID4gMCAmJiAhbWFzay5ldmVyeSgoeCkgPT4geCkpIHtcbiAgICAgICAgX3NpdGggPSBbX3NpdGhdO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjIG9mIF9zaXRoKSB7XG4gICAgICAgIGNvbnN0IG1hc2syID0gYy5tYXAoKHgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3RyaW5nXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWFzazIubGVuZ3RoID4gMCAmJiAhbWFzazIuZXZlcnkoKHgpID0+IHgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIHNpdGgsIHNvbWUgd2VpZ2h0cyBpbiBjbGF1c2UgXCIgKyBtYXNrMiArIFwiIGFyZSBub24gc3RyaW5nXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0aG9sZCA9IHRoaXMuX3Byb2Nlc3NDbGF1c2VzKF9zaXRoKTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NXZWlnaHRlZCh0aG9sZCk7XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzQ2xhdXNlcyhzaXRoKSB7XG4gICAgY29uc3QgdGhvbGQgPSBuZXcgQXJyYXkoKTtcbiAgICBzaXRoLmZvckVhY2goKGNsYXVzZSkgPT4ge1xuICAgICAgdGhvbGQucHVzaChcbiAgICAgICAgY2xhdXNlLm1hcCgodykgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLndlaWdodCh3KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRob2xkO1xuICB9XG4gIF9wcm9jZXNzVW53ZWlnaHRlZCh0aG9sZCkge1xuICAgIGlmICh0aG9sZCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1wb3NpdGl2ZSBpbnQgdGhyZXNob2xkID0ge3Rob2xkfS5cIik7XG4gICAgfVxuICAgIHRoaXMuX3Rob2xkID0gdGhvbGQ7XG4gICAgdGhpcy5fd2VpZ2h0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zaXplID0gdGhpcy5fdGhvbGQ7XG4gICAgdGhpcy5fc2F0aXNmeSA9IHRoaXMuX3NhdGlzZnlfbnVtZXJpYztcbiAgICB0aGlzLl9udW1iZXIgPSBuZXcgQ2Vzck51bWJlcih7fSwgdGhvbGQpO1xuICB9XG4gIF9wcm9jZXNzV2VpZ2h0ZWQodGhvbGQpIHtcbiAgICBmb3IgKGNvbnN0IGNsYXVzZSBvZiB0aG9sZCkge1xuICAgICAgaWYgKE51bWJlcihzdW0oY2xhdXNlKSkgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgc2l0aCBjbGF1c2U6IFwiICsgdGhvbGQgKyBcImFsbCBjbGF1c2Ugd2VpZ2h0IHN1bXMgbXVzdCBiZSA+PSAxXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdGhvbGQgPSB0aG9sZDtcbiAgICB0aGlzLl93ZWlnaHRlZCA9IHRydWU7XG4gICAgdGhpcy5fc2l6ZSA9IHRob2xkLnJlZHVjZSgoYWNjLCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBhY2MgKyBjdXJyZW50VmFsdWUubGVuZ3RoO1xuICAgIH0sIDApO1xuICAgIHRoaXMuX3NhdGlzZnkgPSB0aGlzLl9zYXRpc2Z5X3dlaWdodGVkO1xuICB9XG4gIHdlaWdodCh3KSB7XG4gICAgcmV0dXJuIGZyYWN0aW9uKHcpO1xuICB9XG4gIF9zYXRpc2Z5X251bWVyaWMoaW5kaWNlcykge1xuICAgIHJldHVybiB0aGlzLnRob2xkID4gMCAmJiBpbmRpY2VzLmxlbmd0aCA+PSB0aGlzLnRob2xkO1xuICB9XG4gIF9zYXRpc2Z5X3dlaWdodGVkKGluZGljZXMpIHtcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhlcyA9IG5ldyBTZXQoaW5kaWNlcy5zb3J0KCkpO1xuICAgIGNvbnN0IHNhdHMgPSBuZXcgQXJyYXkoaW5kaWNlcy5sZW5ndGgpLmZpbGwoZmFsc2UpO1xuICAgIGZvciAoY29uc3QgaWR4IG9mIGluZGV4ZXMpIHtcbiAgICAgIHNhdHNbaWR4XSA9IHRydWU7XG4gICAgfVxuICAgIGxldCB3aW8gPSAwO1xuICAgIGZvciAoY29uc3QgY2xhdXNlIG9mIHRoaXMudGhvbGQpIHtcbiAgICAgIGxldCBjdyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHcgb2YgY2xhdXNlKSB7XG4gICAgICAgIGlmIChzYXRzW3dpb10pIHtcbiAgICAgICAgICBjdyArPSBOdW1iZXIodyk7XG4gICAgICAgIH1cbiAgICAgICAgd2lvICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoY3cgPCAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2F0aXNmeShpbmRpY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NhdGlzZnkoaW5kaWNlcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2NvcmUvZXZlbnRpbmcudHNcbnZhciBNYXhJbnRUaG9sZCA9IDIgKiogMzIgLSAxO1xuZnVuY3Rpb24gcm90YXRlKHtcbiAgcHJlID0gdm9pZCAwLFxuICBrZXlzLFxuICBkaWcgPSB2b2lkIDAsXG4gIGlsayA9IElsa3Mucm90LFxuICBzbiA9IDEsXG4gIGlzaXRoID0gdm9pZCAwLFxuICBuZGlncyA9IHZvaWQgMCxcbiAgbnNpdGggPSB2b2lkIDAsXG4gIHdpdHMgPSB2b2lkIDAsXG4gIGN1dHMgPSB2b2lkIDAsXG4gIGFkZHMgPSB2b2lkIDAsXG4gIHRvYWQgPSB2b2lkIDAsXG4gIGRhdGEgPSB2b2lkIDAsXG4gIHZlcnNpb24gPSB2b2lkIDAsXG4gIGtpbmQgPSB2b2lkIDAsXG4gIGludGl2ZSA9IHRydWVcbn0pIHtcbiAgY29uc3QgdnMgPSB2ZXJzaWZ5KFwiS0VSSVwiIC8qIEtFUkkgKi8sIHZlcnNpb24sIGtpbmQsIDApO1xuICBjb25zdCBfaWxrID0gaWxrO1xuICBpZiAoX2lsayAhPSBJbGtzLnJvdCAmJiBfaWxrICE9IElsa3MuZHJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlsayA9ICR7aWxrfSBmb3Igcm90IG9yIGRydC5gKTtcbiAgfVxuICBjb25zdCBzbmVyID0gbmV3IENlc3JOdW1iZXIoe30sIHNuKTtcbiAgaWYgKHNuZXIubnVtIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzbiA9IDB4JHtzbmVyLm51bWh9IGZvciByb3Qgb3IgZHJ0LmApO1xuICB9XG4gIGxldCBfaXNpdDtcbiAgaWYgKGlzaXRoID09IHZvaWQgMCkge1xuICAgIF9pc2l0ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKGtleXMubGVuZ3RoIC8gMikpO1xuICB9IGVsc2Uge1xuICAgIF9pc2l0ID0gaXNpdGg7XG4gIH1cbiAgY29uc3QgdGhvbGRlciA9IG5ldyBUaG9sZGVyKHsgc2l0aDogX2lzaXQgfSk7XG4gIGlmICh0aG9sZGVyLm51bSAhPSB2b2lkIDAgJiYgdGhvbGRlci5udW0gPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpdGggPSAke3Rob2xkZXIubnVtfSBsZXNzIHRoYW4gMS5gKTtcbiAgfVxuICBpZiAodGhvbGRlci5zaXplID4ga2V5cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2l0aCA9ICR7dGhvbGRlci5udW19IGZvciBrZXlzID0gJHtrZXlzfWApO1xuICB9XG4gIGxldCBfbmRpZ3M7XG4gIGlmIChuZGlncyA9PT0gdm9pZCAwKSB7XG4gICAgX25kaWdzID0gW107XG4gIH0gZWxzZSB7XG4gICAgX25kaWdzID0gbmRpZ3M7XG4gIH1cbiAgbGV0IF9uc2l0aDtcbiAgaWYgKG5zaXRoID09PSB2b2lkIDApIHtcbiAgICBfbnNpdGggPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoX25kaWdzLmxlbmd0aCAvIDIpKTtcbiAgfSBlbHNlIHtcbiAgICBfbnNpdGggPSBuc2l0aDtcbiAgfVxuICBjb25zdCBudGhvbGRlciA9IG5ldyBUaG9sZGVyKHsgc2l0aDogX25zaXRoIH0pO1xuICBpZiAobnRob2xkZXIubnVtICE9IHZvaWQgMCAmJiBudGhvbGRlci5udW0gPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpdGggPSAke250aG9sZGVyLm51bX0gbGVzcyB0aGFuIDEuYCk7XG4gIH1cbiAgaWYgKG50aG9sZGVyLnNpemUgPiBfbmRpZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpdGggPSAke250aG9sZGVyLm51bX0gZm9yIG5kaWdzID0gJHtuZGlnc31gKTtcbiAgfVxuICBsZXQgX3dpdHM7XG4gIGlmICh3aXRzID09PSB2b2lkIDApIHtcbiAgICBfd2l0cyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIF93aXRzID0gd2l0cztcbiAgfVxuICBjb25zdCB3aXRzZXQgPSBuZXcgU2V0KF93aXRzKTtcbiAgaWYgKHdpdHNldC5zaXplICE9IF93aXRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRzID0gJHt3aXRzfSwgaGFzIGR1cGxpY2F0ZXMuYCk7XG4gIH1cbiAgbGV0IF9jdXRzO1xuICBpZiAoY3V0cyA9PT0gdm9pZCAwKSB7XG4gICAgX2N1dHMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICBfY3V0cyA9IGN1dHM7XG4gIH1cbiAgY29uc3QgY3V0c2V0ID0gbmV3IFNldChfY3V0cyk7XG4gIGlmIChjdXRzZXQuc2l6ZSAhPSBfY3V0cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY3V0cyA9ICR7Y3V0c30sIGhhcyBkdXBsaWNhdGVzLmApO1xuICB9XG4gIGxldCBfYWRkcztcbiAgaWYgKGFkZHMgPT09IHZvaWQgMCkge1xuICAgIF9hZGRzID0gW107XG4gIH0gZWxzZSB7XG4gICAgX2FkZHMgPSBhZGRzO1xuICB9XG4gIGNvbnN0IGFkZHNldCA9IG5ldyBTZXQoX2FkZHMpO1xuICBjb25zdCB3aXRhZGRzZXQgPSBuZXcgU2V0KFsuLi53aXRzZXRdLmZpbHRlcigoeCkgPT4gYWRkc2V0Lmhhcyh4KSkpO1xuICBpZiAod2l0YWRkc2V0LnNpemUgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgbWVtYmVyIGNvbWJpbmF0aW9uIGFtb25nIHdpdHMgPSAke3dpdHN9LCBhbmQgYWRkcyA9ICR7YWRkc30uYFxuICAgICk7XG4gIH1cbiAgY29uc3QgY3V0YWRkc2V0ID0gbmV3IFNldChbLi4uY3V0c2V0XS5maWx0ZXIoKHgpID0+IGFkZHNldC5oYXMoeCkpKTtcbiAgaWYgKGN1dGFkZHNldC5zaXplID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIG1lbWJlciBjb21iaW5hdGlvbiBhbW9uZyBjdXRzID0gJHtjdXRzfSwgYW5kIGFkZHMgPSAke2FkZHN9LmBcbiAgICApO1xuICB9XG4gIGNvbnN0IG5ld2l0c2V0ZGlmZiA9IG5ldyBTZXQoX3dpdHMpO1xuICBfY3V0cy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBuZXdpdHNldGRpZmYuZGVsZXRlKHYpO1xuICB9KTtcbiAgY29uc3QgbmV3aXRzZXQgPSBuZXcgU2V0KFxuICAgIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCogbmV3aXRzZXRkaWZmO1xuICAgICAgeWllbGQqIGFkZHNldDtcbiAgICB9KClcbiAgKTtcbiAgaWYgKG5ld2l0c2V0LnNpemUgIT0gd2l0c2V0LnNpemUgLSBjdXRzZXQuc2l6ZSArIGFkZHNldC5zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgbWVtYmVyIGNvbWJpbmF0aW9uIGFtb25nIHdpdHMgPSAke3dpdHN9LCBjdXRzID0gJHtjdXRzfSwgYW5kIGFkZHMgPSAke2FkZHN9LmBcbiAgICApO1xuICB9XG4gIGxldCBfdG9hZDtcbiAgaWYgKHRvYWQgPT09IHZvaWQgMCkge1xuICAgIGlmIChuZXdpdHNldC5zaXplID09IDApIHtcbiAgICAgIF90b2FkID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RvYWQgPSBhbXBsZShuZXdpdHNldC5zaXplKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3RvYWQgPSB0b2FkO1xuICB9XG4gIGlmIChuZXdpdHNldC5zaXplID4gMCkge1xuICAgIGlmIChfdG9hZCA8IDEgfHwgX3RvYWQgPiBuZXdpdHNldC5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9hZCA9ICR7X3RvYWR9IGZvciB3aXQgPSAke3dpdHN9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChfdG9hZCAhPSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9hZCA9ICR7X3RvYWR9IGZvciB3aXQgPSAke3dpdHN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IF9rZWQgPSB7XG4gICAgdjogdnMsXG4gICAgdDogX2lsayxcbiAgICBkOiBcIlwiLFxuICAgIGk6IHByZSxcbiAgICBzOiBzbmVyLm51bWgsXG4gICAgcDogZGlnLFxuICAgIGt0OiB0aG9sZGVyLm51bSAmJiBpbnRpdmUgJiYgdGhvbGRlci5udW0gIT09IHZvaWQgMCAmJiB0aG9sZGVyLm51bSA8PSBNYXhJbnRUaG9sZCA/IHRob2xkZXIubnVtLnRvU3RyaW5nKDE2KSA6IHRob2xkZXIuc2l0aCxcbiAgICBrOiBrZXlzLFxuICAgIG50OiBudGhvbGRlci5udW0gJiYgaW50aXZlICYmIG50aG9sZGVyLm51bSAhPT0gdm9pZCAwICYmIG50aG9sZGVyLm51bSA8PSBNYXhJbnRUaG9sZCA/IG50aG9sZGVyLm51bS50b1N0cmluZygxNikgOiBudGhvbGRlci5zaXRoLFxuICAgIG46IF9uZGlncyxcbiAgICBidDogX3RvYWQgJiYgaW50aXZlICYmIF90b2FkICE9PSB2b2lkIDAgJiYgX3RvYWQgPD0gTWF4SW50VGhvbGQgPyBfdG9hZCA6IF90b2FkLnRvU3RyaW5nKDE2KSxcbiAgICBicjogY3V0cyxcbiAgICBiYTogYWRkcyxcbiAgICBhOiBkYXRhICE9IHZvaWQgMCA/IGRhdGEgOiBbXVxuICB9O1xuICBjb25zdCBbLCBrZWRdID0gU2FpZGVyLnNhaWRpZnkoX2tlZCk7XG4gIHJldHVybiBuZXcgU2VyZGVyKGtlZCk7XG59XG5mdW5jdGlvbiBhbXBsZShuLCBmLCB3ZWFrID0gdHJ1ZSkge1xuICBuID0gTWF0aC5tYXgoMCwgbik7XG4gIGxldCBmMTtcbiAgaWYgKGYgPT0gdm9pZCAwKSB7XG4gICAgZjEgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKE1hdGgubWF4KDAsIG4gLSAxKSAvIDMpKTtcbiAgICBjb25zdCBmMiA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChNYXRoLm1heCgwLCBuIC0gMSkgLyAzKSk7XG4gICAgaWYgKHdlYWspIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgICAgbixcbiAgICAgICAgTWF0aC5jZWlsKChuICsgZjEgKyAxKSAvIDIpLFxuICAgICAgICBNYXRoLmNlaWwoKG4gKyBmMiArIDEpIC8gMilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgICAgbixcbiAgICAgICAgTWF0aC5tYXgoMCwgbiAtIGYxLCBNYXRoLmNlaWwoKG4gKyBmMSArIDEpIC8gMikpXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmID0gTWF0aC5tYXgoMCwgZik7XG4gICAgY29uc3QgbTEgPSBNYXRoLmNlaWwoKG4gKyBmICsgMSkgLyAyKTtcbiAgICBjb25zdCBtMiA9IE1hdGgubWF4KDAsIG4gLSBmKTtcbiAgICBpZiAobTIgPCBtMSAmJiBuID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGY9JHtmfSBpcyB0b28gYmlnIGZvciBuPSR7bn0uYCk7XG4gICAgfVxuICAgIGlmICh3ZWFrKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obiwgbTEsIG0yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKG4sIE1hdGgubWF4KG0xLCBtMikpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5jZXB0KHtcbiAga2V5cyxcbiAgaXNpdGgsXG4gIG5kaWdzLFxuICBuc2l0aCxcbiAgdG9hZCxcbiAgd2l0cyxcbiAgY25mZyxcbiAgZGF0YSxcbiAgdmVyc2lvbiA9IFZlcnNpb25hZ2UsXG4gIGtpbmQgPSBcIkpTT05cIiAvKiBKU09OICovLFxuICBjb2RlLFxuICBpbnRpdmUgPSBmYWxzZSxcbiAgZGVscHJlXG59KSB7XG4gIGNvbnN0IHZzID0gdmVyc2lmeShcIktFUklcIiAvKiBLRVJJICovLCB2ZXJzaW9uLCBraW5kLCAwKTtcbiAgY29uc3QgaWxrID0gZGVscHJlID09IHZvaWQgMCA/IElsa3MuaWNwIDogSWxrcy5kaXA7XG4gIGNvbnN0IHNuZXIgPSBuZXcgQ2Vzck51bWJlcih7fSwgMCk7XG4gIGlmIChpc2l0aCA9PSB2b2lkIDApIHtcbiAgICBpc2l0aCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChrZXlzLmxlbmd0aCAvIDIpKTtcbiAgfVxuICBjb25zdCB0aG9sZGVyID0gbmV3IFRob2xkZXIoeyBzaXRoOiBpc2l0aCB9KTtcbiAgaWYgKHRob2xkZXIubnVtICE9IHZvaWQgMCAmJiB0aG9sZGVyLm51bSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2l0aCA9ICR7dGhvbGRlci5udW19IGxlc3MgdGhhbiAxLmApO1xuICB9XG4gIGlmICh0aG9sZGVyLnNpemUgPiBrZXlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaXRoID0gJHt0aG9sZGVyLm51bX0gZm9yIGtleXMgJHtrZXlzfWApO1xuICB9XG4gIGlmIChuZGlncyA9PSB2b2lkIDApIHtcbiAgICBuZGlncyA9IG5ldyBBcnJheSgpO1xuICB9XG4gIGlmIChuc2l0aCA9PSB2b2lkIDApIHtcbiAgICBuc2l0aCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChuZGlncy5sZW5ndGggLyAyKSk7XG4gIH1cbiAgY29uc3QgbnRob2xkZXIgPSBuZXcgVGhvbGRlcih7IHNpdGg6IG5zaXRoIH0pO1xuICBpZiAobnRob2xkZXIubnVtICE9IHZvaWQgMCAmJiBudGhvbGRlci5udW0gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5zaXRoID0gJHtudGhvbGRlci5udW19IGxlc3MgdGhhbiAwLmApO1xuICB9XG4gIGlmIChudGhvbGRlci5zaXplID4ga2V5cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnNpdGggPSAke250aG9sZGVyLm51bX0gZm9yIGtleXMgJHtuZGlnc31gKTtcbiAgfVxuICB3aXRzID0gd2l0cyA9PSB2b2lkIDAgPyBbXSA6IHdpdHM7XG4gIGlmIChuZXcgU2V0KHdpdHMpLnNpemUgIT0gd2l0cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2l0cyA9ICR7d2l0c30sIGhhcyBkdXBsaWNhdGVzLmApO1xuICB9XG4gIGlmICh0b2FkID09IHZvaWQgMCkge1xuICAgIGlmICh3aXRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0b2FkID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9hZCA9IGFtcGxlKHdpdHMubGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdG9hZGVyID0gbmV3IENlc3JOdW1iZXIoe30sIHRvYWQpO1xuICBpZiAod2l0cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHRvYWRlci5udW0gPCAxIHx8IHRvYWRlci5udW0gPiB3aXRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvYWQgPSAke3RvYWRlci5udW19IGZvciB3aXRzID0gJHt3aXRzfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodG9hZGVyLm51bSAhPSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9hZCA9ICR7dG9hZGVyLm51bX0gZm9yIHdpdHMgPSAke3dpdHN9YCk7XG4gICAgfVxuICB9XG4gIGNuZmcgPSBjbmZnID09IHZvaWQgMCA/IG5ldyBBcnJheSgpIDogY25mZztcbiAgZGF0YSA9IGRhdGEgPT0gdm9pZCAwID8gbmV3IEFycmF5KCkgOiBkYXRhO1xuICBsZXQga2VkID0ge1xuICAgIHY6IHZzLFxuICAgIHQ6IGlsayxcbiAgICBkOiBcIlwiLFxuICAgIGk6IFwiXCIsXG4gICAgczogc25lci5udW1oLFxuICAgIGt0OiBpbnRpdmUgJiYgdGhvbGRlci5udW0gIT0gdm9pZCAwID8gdGhvbGRlci5udW0gOiB0aG9sZGVyLnNpdGgsXG4gICAgazoga2V5cyxcbiAgICBudDogaW50aXZlICYmIHRob2xkZXIubnVtICE9IHZvaWQgMCA/IG50aG9sZGVyLm51bSA6IG50aG9sZGVyLnNpdGgsXG4gICAgbjogbmRpZ3MsXG4gICAgYnQ6IGludGl2ZSA/IHRvYWRlci5udW0gOiB0b2FkZXIubnVtaCxcbiAgICBiOiB3aXRzLFxuICAgIGM6IGNuZmcsXG4gICAgYTogZGF0YVxuICB9O1xuICBpZiAoZGVscHJlICE9IHZvaWQgMCkge1xuICAgIGtlZFtcImRpXCJdID0gZGVscHJlO1xuICAgIGlmIChjb2RlID09IHZvaWQgMCkge1xuICAgICAgY29kZSA9IE10ckRleC5CbGFrZTNfMjU2O1xuICAgIH1cbiAgfVxuICBsZXQgcHJlZml4ZXI7XG4gIGlmIChkZWxwcmUgPT0gdm9pZCAwICYmIGNvZGUgPT0gdm9pZCAwICYmIGtleXMubGVuZ3RoID09IDEpIHtcbiAgICBwcmVmaXhlciA9IG5ldyBQcmVmaXhlcih7IHFiNjQ6IGtleXNbMF0gfSk7XG4gICAgaWYgKHByZWZpeGVyLmRpZ2VzdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBjb2RlLCBkaWdlc3RpdmU9JHtwcmVmaXhlci5jb2RlfSwgbXVzdCBiZSBkZXJpdmVkIGZyb20ga2VkLmBcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByZWZpeGVyID0gbmV3IFByZWZpeGVyKHsgY29kZSB9LCBrZWQpO1xuICAgIGlmIChkZWxwcmUgIT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIXByZWZpeGVyLmRpZ2VzdGl2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgZGVyaXZhdGlvbiBjb2RlID0gJHtwcmVmaXhlci5jb2RlfSBmb3IgZGVsZWdhdGlvbi4gTXVzdCBiZSBkaWdlc3RpdmVgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGtlZFtcImlcIl0gPSBwcmVmaXhlci5xYjY0O1xuICBpZiAocHJlZml4ZXIuZGlnZXN0aXZlKSB7XG4gICAga2VkW1wiZFwiXSA9IHByZWZpeGVyLnFiNjQ7XG4gIH0gZWxzZSB7XG4gICAgWywga2VkXSA9IFNhaWRlci5zYWlkaWZ5KGtlZCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTZXJkZXIoa2VkKTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2l6ZShzZXJkZXIsIHNpZ2Vycywgc2VhbCwgd2lnZXJzLCBjaWdhcnMsIHBpcGVsaW5lZCA9IGZhbHNlKSB7XG4gIGxldCBtc2cgPSBuZXcgVWludDhBcnJheShiKHNlcmRlci5yYXcpKTtcbiAgbGV0IGF0YyA9IG5ldyBVaW50OEFycmF5KCk7XG4gIGlmIChzaWdlcnMgPT0gdm9pZCAwICYmIHdpZ2VycyA9PSB2b2lkIDAgJiYgY2lnYXJzID09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNaXNzaW5nIGF0dGFjaGVkIHNpZ25hdHVyZXMgb24gbWVzc2FnZSA9ICR7c2VyZGVyLmtlZH0uYFxuICAgICk7XG4gIH1cbiAgaWYgKHNpZ2VycyAhPSB2b2lkIDApIHtcbiAgICBpZiAoc2VhbCAhPSB2b2lkIDApIHtcbiAgICAgIGlmIChzZWFsWzBdID09IFwiU2VhbEV2ZW50XCIpIHtcbiAgICAgICAgYXRjID0gY29uY2F0KFxuICAgICAgICAgIGF0YyxcbiAgICAgICAgICBuZXcgQ291bnRlcih7IGNvZGU6IEN0ckRleC5UcmFuc0lkeFNpZ0dyb3VwcywgY291bnQ6IDEgfSkucWI2NGJcbiAgICAgICAgKTtcbiAgICAgICAgYXRjID0gY29uY2F0KGF0YywgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlYWxbMV0uaSkpO1xuICAgICAgICBhdGMgPSBjb25jYXQoXG4gICAgICAgICAgYXRjLFxuICAgICAgICAgIG5ldyBTZXFuZXIoeyBzbjogcGFyc2VJbnQoc2VhbFsxXS5zKSB9KS5xYjY0YlxuICAgICAgICApO1xuICAgICAgICBhdGMgPSBjb25jYXQoYXRjLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VhbFsxXS5kKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlYWxbMF0gPT0gXCJTZWFsTGFzdFwiKSB7XG4gICAgICAgIGF0YyA9IGNvbmNhdChcbiAgICAgICAgICBhdGMsXG4gICAgICAgICAgbmV3IENvdW50ZXIoe1xuICAgICAgICAgICAgY29kZTogQ3RyRGV4LlRyYW5zTGFzdElkeFNpZ0dyb3VwcyxcbiAgICAgICAgICAgIGNvdW50OiAxXG4gICAgICAgICAgfSkucWI2NGJcbiAgICAgICAgKTtcbiAgICAgICAgYXRjID0gY29uY2F0KGF0YywgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlYWxbMV0uaSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhdGMgPSBjb25jYXQoXG4gICAgICBhdGMsXG4gICAgICBuZXcgQ291bnRlcih7XG4gICAgICAgIGNvZGU6IEN0ckRleC5Db250cm9sbGVySWR4U2lncyxcbiAgICAgICAgY291bnQ6IHNpZ2Vycy5sZW5ndGhcbiAgICAgIH0pLnFiNjRiXG4gICAgKTtcbiAgICBzaWdlcnMuZm9yRWFjaCgoc2lnZXIpID0+IHtcbiAgICAgIGF0YyA9IGNvbmNhdChhdGMsIHNpZ2VyLnFiNjRiKTtcbiAgICB9KTtcbiAgfVxuICBpZiAod2lnZXJzICE9IHZvaWQgMCkge1xuICAgIGF0YyA9IGNvbmNhdChcbiAgICAgIGF0YyxcbiAgICAgIG5ldyBDb3VudGVyKHtcbiAgICAgICAgY29kZTogQ3RyRGV4LkNvbnRyb2xsZXJJZHhTaWdzLFxuICAgICAgICBjb3VudDogd2lnZXJzLmxlbmd0aFxuICAgICAgfSkucWI2NGJcbiAgICApO1xuICAgIHdpZ2Vycy5mb3JFYWNoKCh3aWdlcikgPT4ge1xuICAgICAgaWYgKHdpZ2VyLnZlcmZlciAmJiAhKHdpZ2VyLnZlcmZlci5jb2RlIGluIE5vblRyYW5zRGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEF0dGVtcHQgdG8gdXNlIHRyYW5mZXJhYmxlIHByZWZpeD0ke3dpZ2VyLnZlcmZlci5xYjY0fSBmb3IgcmVjZWlwdC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhdGMgPSBjb25jYXQoYXRjLCB3aWdlci5xYjY0Yik7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNpZ2FycyAhPSB2b2lkIDApIHtcbiAgICBhdGMgPSBjb25jYXQoXG4gICAgICBhdGMsXG4gICAgICBuZXcgQ291bnRlcih7XG4gICAgICAgIGNvZGU6IEN0ckRleC5Db250cm9sbGVySWR4U2lncyxcbiAgICAgICAgY291bnQ6IGNpZ2Fycy5sZW5ndGhcbiAgICAgIH0pLnFiNjRiXG4gICAgKTtcbiAgICBjaWdhcnMuZm9yRWFjaCgoY2lnYXIpID0+IHtcbiAgICAgIGlmIChjaWdhci52ZXJmZXIgJiYgIShjaWdhci52ZXJmZXIuY29kZSBpbiBOb25UcmFuc0RleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0IHRvIHVzZSB0cmFuZmVyYWJsZSBwcmVmaXg9JHtjaWdhci52ZXJmZXIucWI2NH0gZm9yIHJlY2VpcHQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYXRjID0gY29uY2F0KGF0YywgY2lnYXIucWI2NGIpO1xuICAgIH0pO1xuICB9XG4gIGlmIChwaXBlbGluZWQpIHtcbiAgICBpZiAoYXRjLmxlbmd0aCAlIDQgIT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBhdHRhY2htZW50cyBzaXplPSR7YXRjLmxlbmd0aH0sIG5vbmludGVncmFsIHF1YWRsZXRzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIG1zZyA9IGNvbmNhdChcbiAgICAgIG1zZyxcbiAgICAgIG5ldyBDb3VudGVyKHtcbiAgICAgICAgY29kZTogQ3RyRGV4LkF0dGFjaGVkTWF0ZXJpYWxRdWFkbGV0cyxcbiAgICAgICAgY291bnQ6IE1hdGguZmxvb3IoYXRjLmxlbmd0aCAvIDQpXG4gICAgICB9KS5xYjY0YlxuICAgICk7XG4gIH1cbiAgbXNnID0gY29uY2F0KG1zZywgYXRjKTtcbiAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIGludGVyYWN0KGFyZ3MpIHtcbiAgbGV0IHsgcHJlLCBkaWcsIHNuLCBkYXRhLCB2ZXJzaW9uLCBraW5kIH0gPSBhcmdzO1xuICBjb25zdCB2cyA9IHZlcnNpZnkoXCJLRVJJXCIgLyogS0VSSSAqLywgdmVyc2lvbiwga2luZCwgMCk7XG4gIGNvbnN0IGlsayA9IElsa3MuaXhuO1xuICBjb25zdCBzbmVyID0gbmV3IENlc3JOdW1iZXIoe30sIHNuKTtcbiAgaWYgKHNuZXIubnVtIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzbiA9IDB4JHtzbmVyLm51bWh9IGZvciBpeG4uYCk7XG4gIH1cbiAgZGF0YSA9IGRhdGEgPT0gdm9pZCAwID8gbmV3IEFycmF5KCkgOiBkYXRhO1xuICBsZXQga2VkID0ge1xuICAgIHY6IHZzLFxuICAgIHQ6IGlsayxcbiAgICBkOiBcIlwiLFxuICAgIGk6IHByZSxcbiAgICBzOiBzbmVyLm51bWgsXG4gICAgcDogZGlnLFxuICAgIGE6IGRhdGFcbiAgfTtcbiAgWywga2VkXSA9IFNhaWRlci5zYWlkaWZ5KGtlZCk7XG4gIHJldHVybiBuZXcgU2VyZGVyKGtlZCk7XG59XG5mdW5jdGlvbiByZXBseShyb3V0ZSA9IFwiXCIsIGRhdGEsIHN0YW1wLCB2ZXJzaW9uLCBraW5kID0gXCJKU09OXCIgLyogSlNPTiAqLykge1xuICBjb25zdCB2cyA9IHZlcnNpZnkoXCJLRVJJXCIgLyogS0VSSSAqLywgdmVyc2lvbiwga2luZCwgMCk7XG4gIGlmIChkYXRhID09IHZvaWQgMCkge1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuICBjb25zdCBfc2FkID0ge1xuICAgIHY6IHZzLFxuICAgIHQ6IElsa3MucnB5LFxuICAgIGQ6IFwiXCIsXG4gICAgZHQ6IHN0YW1wID8/ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiWlwiLCBcIjAwMCswMDowMFwiKSxcbiAgICByOiByb3V0ZSxcbiAgICBhOiBkYXRhXG4gIH07XG4gIGNvbnN0IFssIHNhZF0gPSBTYWlkZXIuc2FpZGlmeShfc2FkKTtcbiAgY29uc3Qgc2FpZGVyID0gbmV3IFNhaWRlcih7IHFiNjQ6IHNhZFtcImRcIl0gfSk7XG4gIGlmICghc2FpZGVyLnZlcmlmeShzYWQsIHRydWUsIHRydWUsIGtpbmQsIFwiZFwiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2FpZCA9ICR7c2FpZGVyLnFiNjR9IGZvciByZXBseSBtc2c9JHtzYWR9LmApO1xuICByZXR1cm4gbmV3IFNlcmRlcihzYWQpO1xufVxuXG4vLyBzcmMva2VyaS9hcHAvaGFiZXJ5LnRzXG52YXIgVHJhaXRDb2RleCA9IGNsYXNzIHtcbiAgRXN0T25seSA9IFwiRU9cIjtcbiAgLy8gT25seSBhbGxvdyBlc3RhYmxpc2htZW50IGV2ZW50c1xuICBEb05vdERlbGVnYXRlID0gXCJETkRcIjtcbiAgLy8gRG90IG5vdCBhbGxvdyBkZWxlZ2F0ZWQgaWRlbnRpZmllcnNcbiAgTm9CYWNrZXJzID0gXCJOQlwiO1xuICAvLyBEbyBub3QgYWxsb3cgYmFja2Vyc1xufTtcbnZhciBUcmFpdERleCA9IG5ldyBUcmFpdENvZGV4KCk7XG52YXIgSGFiID0gY2xhc3Mge1xuICBuYW1lO1xuICBzZXJkZXI7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGljcCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zZXJkZXIgPSBpY3A7XG4gIH1cbiAgZ2V0IHByZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJkZXIua2VkW1wiaVwiXTtcbiAgfVxufTtcbnZhciBIYWJlcnkgPSBjbGFzcyB7XG4gIF9uYW1lO1xuICBfbWdyO1xuICBfaGFicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHsgbmFtZSwgcGFzc2NvZGUsIHNlZWQsIGFlaWQsIHBpZHgsIHNhbHQgfSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIGlmIChwYXNzY29kZSAhPSB2b2lkIDAgJiYgc2VlZCA9PSB2b2lkIDApIHtcbiAgICAgIGlmIChwYXNzY29kZS5sZW5ndGggPCAyMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcmFuIChwYXNzY29kZSBzZWVkIG1hdGVyaWFsKSB0b28gc2hvcnQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnJhbiA9IE10ckRleC5TYWx0XzEyOCArIFwiQVwiICsgcGFzc2NvZGUuc3Vic3RyaW5nKDAsIDIxKTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IG5ldyBTYWx0ZXIoeyBxYjY0OiBicmFuIH0pLnNpZ25lcihcbiAgICAgICAgTXRyRGV4LkVkMjU1MTlfU2VlZCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBzZWVkID0gc2lnbmVyLnFiNjQ7XG4gICAgICBpZiAoYWVpZCA9PSB2b2lkIDApIHtcbiAgICAgICAgYWVpZCA9IHNpZ25lci52ZXJmZXIucWI2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFsZ287XG4gICAgY29uc3Qgc2FsdGVyID0gc2FsdCAhPSB2b2lkIDAgPyBuZXcgU2FsdGVyKHsgcWI2NDogc2FsdCB9KSA6IHZvaWQgMDtcbiAgICBpZiAoc2FsdCAhPSB2b2lkIDApIHtcbiAgICAgIGFsZ28gPSBcInNhbHR5XCIgLyogc2FsdHkgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsZ28gPSBcInJhbmR5XCIgLyogcmFuZHkgKi87XG4gICAgfVxuICAgIHRoaXMuX21nciA9IG5ldyBNYW5hZ2VyKHtcbiAgICAgIHNlZWQsXG4gICAgICBhZWlkLFxuICAgICAgcGlkeCxcbiAgICAgIGFsZ28sXG4gICAgICBzYWx0ZXJcbiAgICB9KTtcbiAgfVxuICBnZXQgbWdyKCkge1xuICAgIHJldHVybiB0aGlzLl9tZ3I7XG4gIH1cbiAgZ2V0IGhhYnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5faGFicy52YWx1ZXMoKSk7XG4gIH1cbiAgaGFiQnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5faGFicy5nZXQobmFtZSk7XG4gIH1cbiAgbWFrZUhhYihuYW1lLCB7XG4gICAgY29kZSA9IE10ckRleC5CbGFrZTNfMjU2LFxuICAgIHRyYW5zZmVyYWJsZSA9IHRydWUsXG4gICAgaXNpdGggPSB2b2lkIDAsXG4gICAgaWNvdW50ID0gMSxcbiAgICBuc2l0aCA9IHZvaWQgMCxcbiAgICBuY291bnQgPSB2b2lkIDAsXG4gICAgdG9hZCA9IHZvaWQgMCxcbiAgICB3aXRzID0gdm9pZCAwLFxuICAgIGRlbHByZSA9IHZvaWQgMCxcbiAgICBlc3RPbmx5ID0gZmFsc2UsXG4gICAgRG5EID0gZmFsc2UsXG4gICAgZGF0YSA9IHZvaWQgMFxuICB9KSB7XG4gICAgaWYgKG5zaXRoID09IHZvaWQgMCkge1xuICAgICAgbnNpdGggPSBpc2l0aDtcbiAgICB9XG4gICAgaWYgKG5jb3VudCA9PSB2b2lkIDApIHtcbiAgICAgIG5jb3VudCA9IGljb3VudDtcbiAgICB9XG4gICAgaWYgKCF0cmFuc2ZlcmFibGUpIHtcbiAgICAgIG5jb3VudCA9IDA7XG4gICAgICBuc2l0aCA9IFwiMFwiO1xuICAgICAgY29kZSA9IE10ckRleC5FZDI1NTE5TjtcbiAgICB9XG4gICAgY29uc3QgW3ZlcmZlcnMsIGRpZ2Vyc10gPSB0aGlzLl9tZ3IuaW5jZXB0KHtcbiAgICAgIGljb3VudCxcbiAgICAgIG5jb3VudCxcbiAgICAgIHN0ZW06IHRoaXMubmFtZSxcbiAgICAgIHRyYW5zZmVyYWJsZSxcbiAgICAgIHRlbXA6IGZhbHNlXG4gICAgfSk7XG4gICAgaWNvdW50ID0gdmVyZmVycy5sZW5ndGg7XG4gICAgbmNvdW50ID0gZGlnZXJzICE9IHZvaWQgMCA/IGRpZ2Vycy5sZW5ndGggOiAwO1xuICAgIGlmIChpc2l0aCA9PSB2b2lkIDApIHtcbiAgICAgIGlzaXRoID0gYCR7TWF0aC5tYXgoMSwgTWF0aC5jZWlsKGljb3VudCAvIDIpKS50b1N0cmluZygxNil9YDtcbiAgICB9XG4gICAgaWYgKG5zaXRoID09IHZvaWQgMCkge1xuICAgICAgbnNpdGggPSBgJHtNYXRoLm1heCgxLCBNYXRoLmNlaWwobmNvdW50IC8gMikpLnRvU3RyaW5nKDE2KX1gO1xuICAgIH1cbiAgICBjb25zdCBjbmZnID0gbmV3IEFycmF5KCk7XG4gICAgaWYgKGVzdE9ubHkpIHtcbiAgICAgIGNuZmcucHVzaChUcmFpdERleC5Fc3RPbmx5KTtcbiAgICB9XG4gICAgaWYgKERuRCkge1xuICAgICAgY25mZy5wdXNoKFRyYWl0RGV4LkRvTm90RGVsZWdhdGUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbSh2ZXJmZXJzLCAodmVyZmVyKSA9PiB2ZXJmZXIucWI2NCk7XG4gICAgY29uc3QgbmRpZ3MgPSBBcnJheS5mcm9tKGRpZ2VycywgKGRpZ2VyKSA9PiBkaWdlci5xYjY0KTtcbiAgICBjb25zdCBpY3AgPSBpbmNlcHQoe1xuICAgICAga2V5cyxcbiAgICAgIGlzaXRoLFxuICAgICAgbmRpZ3MsXG4gICAgICBuc2l0aCxcbiAgICAgIHRvYWQsXG4gICAgICB3aXRzLFxuICAgICAgY25mZyxcbiAgICAgIGRhdGEsXG4gICAgICBjb2RlLFxuICAgICAgZGVscHJlXG4gICAgfSk7XG4gICAgY29uc3QgaGFiID0gbmV3IEhhYihuYW1lLCBpY3ApO1xuICAgIHRoaXMuX2hhYnMuc2V0KG5hbWUsIGhhYik7XG4gICAgcmV0dXJuIGhhYjtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvYXBwL2NvbnRyb2xsZXIudHNcbnZhciBBZ2VudCA9IGNsYXNzIHtcbiAgcHJlO1xuICBhbmNob3I7XG4gIHZlcmZlcjtcbiAgc3RhdGU7XG4gIHNuO1xuICBzYWlkO1xuICBjb25zdHJ1Y3RvcihhZ2VudCkge1xuICAgIHRoaXMucHJlID0gXCJcIjtcbiAgICB0aGlzLmFuY2hvciA9IFwiXCI7XG4gICAgdGhpcy52ZXJmZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuc24gPSAwO1xuICAgIHRoaXMuc2FpZCA9IFwiXCI7XG4gICAgdGhpcy5wYXJzZShhZ2VudCk7XG4gIH1cbiAgcGFyc2UoYWdlbnQpIHtcbiAgICBjb25zdCBbc3RhdGUsIHZlcmZlcl0gPSB0aGlzLmV2ZW50KGFnZW50KTtcbiAgICB0aGlzLnNuID0gbmV3IENlc3JOdW1iZXIoe30sIHZvaWQgMCwgc3RhdGVbXCJzXCJdKS5udW07XG4gICAgdGhpcy5zYWlkID0gc3RhdGVbXCJkXCJdO1xuICAgIGlmIChzdGF0ZVtcImV0XCJdICE9PSBJbGtzLmRpcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY2VwdGlvbiBldmVudCB0eXBlICR7c3RhdGVbXCJldFwiXX1gKTtcbiAgICB9XG4gICAgdGhpcy5wcmUgPSBzdGF0ZVtcImlcIl07XG4gICAgaWYgKCFzdGF0ZVtcImRpXCJdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhbmNob3IgdG8gY29udHJvbGxlciBBSURcIik7XG4gICAgfVxuICAgIHRoaXMuYW5jaG9yID0gc3RhdGVbXCJkaVwiXTtcbiAgICB0aGlzLnZlcmZlciA9IHZlcmZlcjtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH1cbiAgZXZlbnQoZXZ0KSB7XG4gICAgaWYgKGV2dFtcImtcIl0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFnZW50IGluY2VwdGlvbiBldmVudCBjYW4gb25seSBoYXZlIG9uZSBrZXlgKTtcbiAgICB9XG4gICAgY29uc3QgdmVyZmVyID0gbmV3IFZlcmZlcih7IHFiNjQ6IGV2dFtcImtcIl1bMF0gfSk7XG4gICAgaWYgKGV2dFtcIm5cIl0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFnZW50IGluY2VwdGlvbiBldmVudCBjYW4gb25seSBoYXZlIG9uZSBuZXh0IGtleWApO1xuICAgIH1cbiAgICBjb25zdCBkaWdlciA9IG5ldyBEaWdlcih7IHFiNjQ6IGV2dFtcIm5cIl1bMF0gfSk7XG4gICAgY29uc3QgdGhvbGRlciA9IG5ldyBUaG9sZGVyKHsgc2l0aDogZXZ0W1wia3RcIl0gfSk7XG4gICAgaWYgKHRob2xkZXIubnVtICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdGhyZXNob2xkICR7dGhvbGRlci5udW19LCBtdXN0IGJlIDFgKTtcbiAgICB9XG4gICAgY29uc3QgbnRob2xkZXIgPSBuZXcgVGhvbGRlcih7IHNpdGg6IGV2dFtcIm50XCJdIH0pO1xuICAgIGlmIChudGhvbGRlci5udW0gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGludmFsaWQgbmV4dCB0aHJlc2hvbGQgJHtudGhvbGRlci5udW19LCBtdXN0IGJlIDFgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW2V2dCwgdmVyZmVyLCBkaWdlcl07XG4gIH1cbn07XG52YXIgQ29udHJvbGxlciA9IGNsYXNzIHtcbiAgYnJhbjtcbiAgc3RlbTtcbiAgdGllcjtcbiAgcmlkeDtcbiAgc2FsdGVyO1xuICBzaWduZXI7XG4gIG5zaWduZXI7XG4gIHNlcmRlcjtcbiAga2V5cztcbiAgbmRpZ3M7XG4gIGNvbnN0cnVjdG9yKGJyYW4sIHRpZXIsIHJpZHggPSAwLCBzdGF0ZSA9IG51bGwpIHtcbiAgICB0aGlzLmJyYW4gPSBNdHJEZXguU2FsdF8xMjggKyBcIkFcIiArIGJyYW4uc3Vic3RyaW5nKDAsIDIxKTtcbiAgICB0aGlzLnN0ZW0gPSBcInNpZ25pZnk6Y29udHJvbGxlclwiO1xuICAgIHRoaXMudGllciA9IHRpZXI7XG4gICAgdGhpcy5yaWR4ID0gcmlkeDtcbiAgICB0aGlzLnNhbHRlciA9IG5ldyBTYWx0ZXIoeyBxYjY0OiB0aGlzLmJyYW4sIHRpZXI6IHRoaXMudGllciB9KTtcbiAgICBjb25zdCBjcmVhdG9yID0gbmV3IFNhbHR5Q3JlYXRvcihcbiAgICAgIHRoaXMuc2FsdGVyLnFiNjQsXG4gICAgICB0aGlzLnRpZXIsXG4gICAgICB0aGlzLnN0ZW1cbiAgICApO1xuICAgIHRoaXMuc2lnbmVyID0gY3JlYXRvci5jcmVhdGUoXG4gICAgICB2b2lkIDAsXG4gICAgICAxLFxuICAgICAgTXRyRGV4LkVkMjU1MTlfU2VlZCxcbiAgICAgIHRydWUsXG4gICAgICAwLFxuICAgICAgdGhpcy5yaWR4LFxuICAgICAgMCxcbiAgICAgIGZhbHNlXG4gICAgKS5zaWduZXJzLnBvcCgpO1xuICAgIHRoaXMubnNpZ25lciA9IGNyZWF0b3IuY3JlYXRlKFxuICAgICAgdm9pZCAwLFxuICAgICAgMSxcbiAgICAgIE10ckRleC5FZDI1NTE5X1NlZWQsXG4gICAgICB0cnVlLFxuICAgICAgMCxcbiAgICAgIHRoaXMucmlkeCArIDEsXG4gICAgICAwLFxuICAgICAgZmFsc2VcbiAgICApLnNpZ25lcnMucG9wKCk7XG4gICAgdGhpcy5rZXlzID0gW3RoaXMuc2lnbmVyLnZlcmZlci5xYjY0XTtcbiAgICB0aGlzLm5kaWdzID0gW1xuICAgICAgbmV3IERpZ2VyKHsgY29kZTogTXRyRGV4LkJsYWtlM18yNTYgfSwgdGhpcy5uc2lnbmVyLnZlcmZlci5xYjY0YikucWI2NFxuICAgIF07XG4gICAgaWYgKHN0YXRlID09IG51bGwgfHwgc3RhdGVbXCJlZVwiXVtcInNcIl0gPT0gMCkge1xuICAgICAgdGhpcy5zZXJkZXIgPSBpbmNlcHQoe1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICAgIGlzaXRoOiBcIjFcIixcbiAgICAgICAgbnNpdGg6IFwiMVwiLFxuICAgICAgICBuZGlnczogdGhpcy5uZGlncyxcbiAgICAgICAgY29kZTogTXRyRGV4LkJsYWtlM18yNTYsXG4gICAgICAgIHRvYWQ6IFwiMFwiLFxuICAgICAgICB3aXRzOiBbXVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VyZGVyID0gbmV3IFNlcmRlcihzdGF0ZVtcImVlXCJdKTtcbiAgICB9XG4gIH1cbiAgYXBwcm92ZURlbGVnYXRpb24oX2FnZW50KSB7XG4gICAgY29uc3Qgc2VxbmVyID0gbmV3IFNlcW5lcih7IHNuOiBfYWdlbnQuc24gfSk7XG4gICAgY29uc3QgYW5jaG9yID0geyBpOiBfYWdlbnQucHJlLCBzOiBzZXFuZXIuc25oLCBkOiBfYWdlbnQuc2FpZCB9O1xuICAgIGNvbnN0IHNuID0gbmV3IENlc3JOdW1iZXIoe30sIHZvaWQgMCwgdGhpcy5zZXJkZXIua2VkW1wic1wiXSkubnVtICsgMTtcbiAgICB0aGlzLnNlcmRlciA9IGludGVyYWN0KHtcbiAgICAgIHByZTogdGhpcy5zZXJkZXIucHJlLFxuICAgICAgZGlnOiB0aGlzLnNlcmRlci5rZWRbXCJkXCJdLFxuICAgICAgc24sXG4gICAgICBkYXRhOiBbYW5jaG9yXSxcbiAgICAgIHZlcnNpb246IFZlcnNpb25hZ2UsXG4gICAgICBraW5kOiBcIkpTT05cIiAvKiBKU09OICovXG4gICAgfSk7XG4gICAgcmV0dXJuIFt0aGlzLnNpZ25lci5zaWduKHRoaXMuc2VyZGVyLnJhdywgMCkucWI2NF07XG4gIH1cbiAgZ2V0IHByZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJkZXIucHJlO1xuICB9XG4gIGdldCBldmVudCgpIHtcbiAgICBjb25zdCBzaWdlciA9IHRoaXMuc2lnbmVyLnNpZ24odGhpcy5zZXJkZXIucmF3LCAwKTtcbiAgICByZXR1cm4gW3RoaXMuc2VyZGVyLCBzaWdlcl07XG4gIH1cbiAgZ2V0IHZlcmZlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmVyLnZlcmZlcigpO1xuICB9XG4gIGRlcml2ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAhPSB2b2lkIDAgJiYgc3RhdGVbXCJlZVwiXVtcInNcIl0gPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gaW5jZXB0KHtcbiAgICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgICBpc2l0aDogXCIxXCIsXG4gICAgICAgIG5zaXRoOiBcIjFcIixcbiAgICAgICAgbmRpZ3M6IHRoaXMubmRpZ3MsXG4gICAgICAgIGNvZGU6IE10ckRleC5CbGFrZTNfMjU2LFxuICAgICAgICB0b2FkOiBcIjBcIixcbiAgICAgICAgd2l0czogW11cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFNlcmRlcih7IGtlZDogc3RhdGUuY29udHJvbGxlcltcImVlXCJdIH0pO1xuICAgIH1cbiAgfVxuICByb3RhdGUoYnJhbiwgYWlkcykge1xuICAgIGNvbnN0IG5icmFuID0gTXRyRGV4LlNhbHRfMTI4ICsgXCJBXCIgKyBicmFuLnN1YnN0cmluZygwLCAyMSk7XG4gICAgY29uc3QgbnNhbHRlciA9IG5ldyBTYWx0ZXIoeyBxYjY0OiBuYnJhbiwgdGllcjogdGhpcy50aWVyIH0pO1xuICAgIGNvbnN0IG5zaWduZXIgPSB0aGlzLnNhbHRlci5zaWduZXIodm9pZCAwLCBmYWxzZSk7XG4gICAgY29uc3QgY3JlYXRvciA9IG5ldyBTYWx0eUNyZWF0b3IoXG4gICAgICB0aGlzLnNhbHRlci5xYjY0LFxuICAgICAgdGhpcy50aWVyLFxuICAgICAgdGhpcy5zdGVtXG4gICAgKTtcbiAgICBjb25zdCBzaWduZXIgPSBjcmVhdG9yLmNyZWF0ZShcbiAgICAgIHZvaWQgMCxcbiAgICAgIDEsXG4gICAgICBNdHJEZXguRWQyNTUxOV9TZWVkLFxuICAgICAgdHJ1ZSxcbiAgICAgIDAsXG4gICAgICB0aGlzLnJpZHggKyAxLFxuICAgICAgMCxcbiAgICAgIGZhbHNlXG4gICAgKS5zaWduZXJzLnBvcCgpO1xuICAgIGNvbnN0IG5jcmVhdG9yID0gbmV3IFNhbHR5Q3JlYXRvcihuc2FsdGVyLnFiNjQsIHRoaXMudGllciwgdGhpcy5zdGVtKTtcbiAgICB0aGlzLnNpZ25lciA9IG5jcmVhdG9yLmNyZWF0ZShcbiAgICAgIHZvaWQgMCxcbiAgICAgIDEsXG4gICAgICBNdHJEZXguRWQyNTUxOV9TZWVkLFxuICAgICAgdHJ1ZSxcbiAgICAgIDAsXG4gICAgICB0aGlzLnJpZHgsXG4gICAgICAwLFxuICAgICAgZmFsc2VcbiAgICApLnNpZ25lcnMucG9wKCk7XG4gICAgdGhpcy5uc2lnbmVyID0gbmNyZWF0b3IuY3JlYXRlKFxuICAgICAgdm9pZCAwLFxuICAgICAgMSxcbiAgICAgIE10ckRleC5FZDI1NTE5X1NlZWQsXG4gICAgICB0cnVlLFxuICAgICAgMCxcbiAgICAgIHRoaXMucmlkeCArIDEsXG4gICAgICAwLFxuICAgICAgZmFsc2VcbiAgICApLnNpZ25lcnMucG9wKCk7XG4gICAgdGhpcy5rZXlzID0gW3RoaXMuc2lnbmVyLnZlcmZlci5xYjY0LCBzaWduZXI/LnZlcmZlci5xYjY0XTtcbiAgICB0aGlzLm5kaWdzID0gW25ldyBEaWdlcih7fSwgdGhpcy5uc2lnbmVyLnZlcmZlci5xYjY0YikucWI2NF07XG4gICAgY29uc3Qgcm90ID0gcm90YXRlKHtcbiAgICAgIHByZTogdGhpcy5wcmUsXG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICBkaWc6IHRoaXMuc2VyZGVyLmtlZFtcImRcIl0sXG4gICAgICBpc2l0aDogW1wiMVwiLCBcIjBcIl0sXG4gICAgICBuc2l0aDogXCIxXCIsXG4gICAgICBuZGlnczogdGhpcy5uZGlnc1xuICAgIH0pO1xuICAgIGNvbnN0IHNpZ3MgPSBbXG4gICAgICBzaWduZXI/LnNpZ24oYihyb3QucmF3KSwgMSwgZmFsc2UsIDApLnFiNjQsXG4gICAgICB0aGlzLnNpZ25lci5zaWduKHJvdC5yYXcsIDApLnFiNjRcbiAgICBdO1xuICAgIGNvbnN0IGVuY3J5cHRlciA9IG5ldyBFbmNyeXB0ZXIoe30sIGIobnNpZ25lci52ZXJmZXIucWI2NCkpO1xuICAgIGNvbnN0IGRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoe30sIG5zaWduZXIucWI2NGIpO1xuICAgIGNvbnN0IHN4bHQgPSBlbmNyeXB0ZXIuZW5jcnlwdChiKHRoaXMuYnJhbikpLnFiNjQ7XG4gICAgY29uc3Qga2V5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgYWlkIG9mIGFpZHMpIHtcbiAgICAgIGNvbnN0IHByZSA9IGFpZFtcInByZWZpeFwiXTtcbiAgICAgIGlmIChcInNhbHR5XCIgaW4gYWlkKSB7XG4gICAgICAgIGNvbnN0IHNhbHR5ID0gYWlkW1wic2FsdHlcIl07XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IG5ldyBDaXBoZXIoeyBxYjY0OiBzYWx0eVtcInN4bHRcIl0gfSk7XG4gICAgICAgIGNvbnN0IGRueHQgPSBkZWNyeXB0ZXIuZGVjcnlwdChudWxsLCBjaXBoZXIpLnFiNjQ7XG4gICAgICAgIGNvbnN0IGFjcmVhdG9yID0gbmV3IFNhbHR5Q3JlYXRvcihcbiAgICAgICAgICBkbnh0LFxuICAgICAgICAgIHNhbHR5W1widGllclwiXSxcbiAgICAgICAgICBzYWx0eVtcInN0ZW1cIl1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc2lnbmVycyA9IGFjcmVhdG9yLmNyZWF0ZShcbiAgICAgICAgICBzYWx0eVtcImljb2Rlc1wiXSxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgTXRyRGV4LkVkMjU1MTlfU2VlZCxcbiAgICAgICAgICBzYWx0eVtcInRyYW5zZmVyYWJsZVwiXSxcbiAgICAgICAgICBzYWx0eVtcInBpZHhcIl0sXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzYWx0eVtcImtpZHhcIl0sXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgX3NpZ25lcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWduZXIyIG9mIHNpZ25lcnMuc2lnbmVycykge1xuICAgICAgICAgIF9zaWduZXJzLnB1c2goc2lnbmVyMi52ZXJmZXIucWI2NCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVicyA9IGFpZFtcInN0YXRlXCJdW1wia1wiXTtcbiAgICAgICAgaWYgKHB1YnMuam9pbihcIixcIikgIT0gX3NpZ25lcnMuam9pbihcIixcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNhbHR5IEFJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3hsdCA9IGVuY3J5cHRlci5lbmNyeXB0KGIoZG54dCkpLnFiNjQ7XG4gICAgICAgIGtleXNbcHJlXSA9IHtcbiAgICAgICAgICBzeGx0OiBhc3hsdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChcInJhbmR5XCIgaW4gYWlkKSB7XG4gICAgICAgIGNvbnN0IHJhbmR5ID0gYWlkW1wicmFuZHlcIl07XG4gICAgICAgIGNvbnN0IHByeHMgPSByYW5keVtcInByeHNcIl07XG4gICAgICAgIGNvbnN0IG54dHMgPSByYW5keVtcIm54dHNcIl07XG4gICAgICAgIGNvbnN0IG5wcnhzID0gW107XG4gICAgICAgIGNvbnN0IHNpZ25lcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcnggb2YgcHJ4cykge1xuICAgICAgICAgIGNvbnN0IGNpcGhlciA9IG5ldyBDaXBoZXIoeyBxYjY0OiBwcnggfSk7XG4gICAgICAgICAgY29uc3QgZHNpZ25lciA9IGRlY3J5cHRlci5kZWNyeXB0KG51bGwsIGNpcGhlciwgdHJ1ZSk7XG4gICAgICAgICAgc2lnbmVycy5wdXNoKGRzaWduZXIpO1xuICAgICAgICAgIG5wcnhzLnB1c2goZW5jcnlwdGVyLmVuY3J5cHQoYihkc2lnbmVyLnFiNjQpKS5xYjY0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJzID0gYWlkW1wic3RhdGVcIl1bXCJrXCJdO1xuICAgICAgICBjb25zdCBfc2lnbmVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpZ25lcjIgb2Ygc2lnbmVycykge1xuICAgICAgICAgIF9zaWduZXJzLnB1c2goc2lnbmVyMi52ZXJmZXIucWI2NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YnMuam9pbihcIixcIikgIT0gX3NpZ25lcnMuam9pbihcIixcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgdW5hYmxlIHRvIHJvdGF0ZSwgdmFsaWRhdGlvbiBvZiBlbmNyeXB0ZWQgcHVibGljIGtleXMgJHtwdWJzfSBmYWlsZWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBubnh0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG54dCBvZiBueHRzKSB7XG4gICAgICAgICAgbm54dHMucHVzaCh0aGlzLnJlY3J5cHQobnh0LCBkZWNyeXB0ZXIsIGVuY3J5cHRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGtleXNbcHJlXSA9IHtcbiAgICAgICAgICBwcnhzOiBucHJ4cyxcbiAgICAgICAgICBueHRzOiBubnh0c1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhaWQgdHlwZSBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICByb3Q6IHJvdC5rZWQsXG4gICAgICBzaWdzLFxuICAgICAgc3hsdCxcbiAgICAgIGtleXNcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJlY3J5cHQoZW5jLCBkZWNyeXB0ZXIsIGVuY3J5cHRlcikge1xuICAgIGNvbnN0IGNpcGhlciA9IG5ldyBDaXBoZXIoeyBxYjY0OiBlbmMgfSk7XG4gICAgY29uc3QgZG54dCA9IGRlY3J5cHRlci5kZWNyeXB0KG51bGwsIGNpcGhlcikucWI2NDtcbiAgICByZXR1cm4gZW5jcnlwdGVyLmVuY3J5cHQoYihkbnh0KSkucWI2NDtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9odHRwaW5nLnRzXG5pbXBvcnQge1xuICBzZXJpYWxpemVEaWN0aW9uYXJ5LFxuICBwYXJzZURpY3Rpb25hcnlcbn0gZnJvbSBcInN0cnVjdHVyZWQtaGVhZGVyc1wiO1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlcjkgfSBmcm9tIFwiYnVmZmVyXCI7XG52YXIgSEVBREVSX1NJR19JTlBVVCA9IG5vcm1hbGl6ZShcIlNpZ25hdHVyZS1JbnB1dFwiKTtcbnZhciBIRUFERVJfU0lHX1RJTUUgPSBub3JtYWxpemUoXCJTaWduaWZ5LVRpbWVzdGFtcFwiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZShoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKCk7XG59XG5mdW5jdGlvbiBzaWdpbnB1dChzaWduZXIsIHtcbiAgbmFtZSxcbiAgbWV0aG9kLFxuICBwYXRoLFxuICBoZWFkZXJzLFxuICBmaWVsZHMsXG4gIGV4cGlyZXMsXG4gIG5vbmNlLFxuICBhbGcsXG4gIGtleWlkLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IGl0ZW1zID0gbmV3IEFycmF5KCk7XG4gIGNvbnN0IGlmaWVsZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaWYgKGZpZWxkLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgXCJAbWV0aG9kXCI6XG4gICAgICAgICAgaXRlbXMucHVzaChgXCIke2ZpZWxkfVwiOiAke21ldGhvZH1gKTtcbiAgICAgICAgICBpZmllbGRzLnB1c2goW2ZpZWxkLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJAcGF0aFwiOlxuICAgICAgICAgIGl0ZW1zLnB1c2goYFwiJHtmaWVsZH1cIjogJHtwYXRofWApO1xuICAgICAgICAgIGlmaWVsZHMucHVzaChbZmllbGQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCldKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFoZWFkZXJzLmhhcyhmaWVsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmaWVsZHMucHVzaChbZmllbGQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCldKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbm9ybWFsaXplKGhlYWRlcnMuZ2V0KGZpZWxkKSk7XG4gICAgICBpdGVtcy5wdXNoKGBcIiR7ZmllbGR9XCI6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbmFtZVBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IG5vdyA9IE1hdGguZmxvb3Iobm93VVRDKCkuZ2V0VGltZSgpIC8gMWUzKTtcbiAgbmFtZVBhcmFtcy5zZXQoXCJjcmVhdGVkXCIsIG5vdyk7XG4gIGNvbnN0IHZhbHVlcyA9IFtcbiAgICBgKCR7aWZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZFswXSkuam9pbihcIiBcIil9KWAsXG4gICAgYGNyZWF0ZWQ9JHtub3d9YFxuICBdO1xuICBpZiAoZXhwaXJlcyAhPSB2b2lkIDApIHtcbiAgICB2YWx1ZXMucHVzaChgZXhwaXJlcz0ke2V4cGlyZXN9YCk7XG4gICAgbmFtZVBhcmFtcy5zZXQoXCJleHBpcmVzXCIsIGV4cGlyZXMpO1xuICB9XG4gIGlmIChub25jZSAhPSB2b2lkIDApIHtcbiAgICB2YWx1ZXMucHVzaChgbm9uY2U9JHtub25jZX1gKTtcbiAgICBuYW1lUGFyYW1zLnNldChcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxuICBpZiAoa2V5aWQgIT0gdm9pZCAwKSB7XG4gICAgdmFsdWVzLnB1c2goYGtleWlkPSR7a2V5aWR9YCk7XG4gICAgbmFtZVBhcmFtcy5zZXQoXCJrZXlpZFwiLCBrZXlpZCk7XG4gIH1cbiAgaWYgKGNvbnRleHQgIT0gdm9pZCAwKSB7XG4gICAgdmFsdWVzLnB1c2goYGNvbnRleHQ9JHtjb250ZXh0fWApO1xuICAgIG5hbWVQYXJhbXMuc2V0KFwiY29udGV4dFwiLCBjb250ZXh0KTtcbiAgfVxuICBpZiAoYWxnICE9IHZvaWQgMCkge1xuICAgIHZhbHVlcy5wdXNoKGBhbGc9JHthbGd9YCk7XG4gICAgbmFtZVBhcmFtcy5zZXQoXCJhbGdcIiwgYWxnKTtcbiAgfVxuICBjb25zdCBzaWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW25hbWUsIFtpZmllbGRzLCBuYW1lUGFyYW1zXV1dKTtcbiAgY29uc3QgcGFyYW1zID0gdmFsdWVzLmpvaW4oXCI7XCIpO1xuICBpdGVtcy5wdXNoKGBcIkBzaWduYXR1cmUtcGFyYW1zOiAke3BhcmFtc31cImApO1xuICBjb25zdCBzZXIgPSBpdGVtcy5qb2luKFwiXFxuXCIpO1xuICBjb25zdCBzaWcgPSBzaWduZXIuc2lnbihiKHNlcikpO1xuICByZXR1cm4gW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgIFtIRUFERVJfU0lHX0lOUFVULCBgJHtzZXJpYWxpemVEaWN0aW9uYXJ5KHNpZCl9YF1cbiAgICBdKSxcbiAgICBzaWdcbiAgXTtcbn1cbnZhciBVbnF1YWxpZmllZCA9IGNsYXNzIHtcbiAgX3JhdztcbiAgY29uc3RydWN0b3IocmF3KSB7XG4gICAgdGhpcy5fcmF3ID0gcmF3O1xuICB9XG4gIGdldCBxYjY0KCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRVcmwoQnVmZmVyOS5mcm9tKHRoaXMuX3JhdykpO1xuICB9XG4gIGdldCBxYjY0YigpIHtcbiAgICByZXR1cm4gYih0aGlzLnFiNjQpO1xuICB9XG59O1xudmFyIElucHV0YWdlID0gY2xhc3Mge1xuICBuYW1lO1xuICBmaWVsZHM7XG4gIGNyZWF0ZWQ7XG4gIGV4cGlyZXM7XG4gIG5vbmNlO1xuICBhbGc7XG4gIGtleWlkO1xuICBjb250ZXh0O1xufTtcbmZ1bmN0aW9uIGRlc2lnaW5wdXQodmFsdWUpIHtcbiAgY29uc3Qgc2lkID0gcGFyc2VEaWN0aW9uYXJ5KHZhbHVlKTtcbiAgY29uc3Qgc2lnaW5wdXRzID0gbmV3IEFycmF5KCk7XG4gIHNpZC5mb3JFYWNoKCh2YWx1ZTIsIGtleSkgPT4ge1xuICAgIGNvbnN0IHNpZ2lucHV0MiA9IG5ldyBJbnB1dGFnZSgpO1xuICAgIHNpZ2lucHV0Mi5uYW1lID0ga2V5O1xuICAgIGxldCBsaXN0O1xuICAgIGxldCBwYXJhbXM7XG4gICAgW2xpc3QsIHBhcmFtc10gPSB2YWx1ZTI7XG4gICAgc2lnaW5wdXQyLmZpZWxkcyA9IGxpc3QubWFwKChpdGVtKSA9PiBpdGVtWzBdKTtcbiAgICBpZiAoIXBhcmFtcy5oYXMoXCJjcmVhdGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwibWlzc2luZyByZXF1aXJlZCBgY3JlYXRlZGAgZmllbGQgZnJvbSBzaWduYXR1cmUgaW5wdXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgc2lnaW5wdXQyLmNyZWF0ZWQgPSBwYXJhbXMuZ2V0KFwiY3JlYXRlZFwiKTtcbiAgICBpZiAocGFyYW1zLmhhcyhcImV4cGlyZXNcIikpIHtcbiAgICAgIHNpZ2lucHV0Mi5leHBpcmVzID0gcGFyYW1zLmdldChcImV4cGlyZXNcIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaGFzKFwibm9uY2VcIikpIHtcbiAgICAgIHNpZ2lucHV0Mi5ub25jZSA9IHBhcmFtcy5nZXQoXCJub25jZVwiKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5oYXMoXCJhbGdcIikpIHtcbiAgICAgIHNpZ2lucHV0Mi5hbGcgPSBwYXJhbXMuZ2V0KFwiYWxnXCIpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmhhcyhcImtleWlkXCIpKSB7XG4gICAgICBzaWdpbnB1dDIua2V5aWQgPSBwYXJhbXMuZ2V0KFwia2V5aWRcIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaGFzKFwiY29udGV4dFwiKSkge1xuICAgICAgc2lnaW5wdXQyLmNvbnRleHQgPSBwYXJhbXMuZ2V0KFwiY29udGV4dFwiKTtcbiAgICB9XG4gICAgc2lnaW5wdXRzLnB1c2goc2lnaW5wdXQyKTtcbiAgfSk7XG4gIHJldHVybiBzaWdpbnB1dHM7XG59XG5mdW5jdGlvbiBwYXJzZVJhbmdlSGVhZGVycyhoZWFkZXIsIHR5cCkge1xuICBpZiAoaGVhZGVyICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGF0YSA9IGhlYWRlci5yZXBsYWNlKGAke3R5cH0gYCwgXCJcIik7XG4gICAgY29uc3QgdmFsdWVzID0gZGF0YS5zcGxpdChcIi9cIik7XG4gICAgY29uc3Qgcm5nID0gdmFsdWVzWzBdLnNwbGl0KFwiLVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBhcnNlSW50KHJuZ1swXSksXG4gICAgICBlbmQ6IHBhcnNlSW50KHJuZ1sxXSksXG4gICAgICB0b3RhbDogcGFyc2VJbnQodmFsdWVzWzFdKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IDAsIGVuZDogMCwgdG90YWw6IDAgfTtcbiAgfVxufVxuXG4vLyBzcmMva2VyaS9hcHAvYWlkaW5nLnRzXG52YXIgSWRlbnRpZmllciA9IGNsYXNzIHtcbiAgY2xpZW50O1xuICAvKipcbiAgICogSWRlbnRpZmllclxuICAgKiBAcGFyYW0ge0lkZW50aWZpZXJEZXBzfSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IG1hbmFnZWQgaWRlbnRpZmllcnNcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gU3RhcnQgaW5kZXggb2YgbGlzdCBvZiBub3RpZmljYXRpb25zLCBkZWZhdWx0cyB0byAwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPTI0XSBFbmQgaW5kZXggb2YgbGlzdCBvZiBub3RpZmljYXRpb25zLCBkZWZhdWx0cyB0byAyNFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIGxpc3Qgb2YgbWFuYWdlZCBpZGVudGlmaWVyc1xuICAgKi9cbiAgYXN5bmMgbGlzdChzdGFydCA9IDAsIGVuZCA9IDI0KSB7XG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBleHRyYUhlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGFpZHM9JHtzdGFydH0tJHtlbmR9YCk7XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnNgO1xuICAgIGNvbnN0IGRhdGEgPSBudWxsO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhLCBleHRyYUhlYWRlcnMpO1xuICAgIGNvbnN0IGNyID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC1yYW5nZVwiKTtcbiAgICBjb25zdCByYW5nZTIgPSBwYXJzZVJhbmdlSGVhZGVycyhjciwgXCJhaWRzXCIpO1xuICAgIGNvbnN0IGFpZHMgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcmFuZ2UyLnN0YXJ0LFxuICAgICAgZW5kOiByYW5nZTIuZW5kLFxuICAgICAgdG90YWw6IHJhbmdlMi50b3RhbCxcbiAgICAgIGFpZHNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gZm9yIGEgbWFuYWdlZCBpZGVudGlmaWVyXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgaWRlbnRpZmllciBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0KG5hbWUpIHtcbiAgICBjb25zdCBwYXRoID0gYC9pZGVudGlmaWVycy8ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX1gO1xuICAgIGNvbnN0IGRhdGEgPSBudWxsO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbWFuYWdlZCBpZGVudGlmaWVyXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7Q3JlYXRlSWRlbnRpZmVyQXJnc30gW2thcmdzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7RXZlbnRSZXN1bHR9IFRoZSBpbmNlcHRpb24gcmVzdWx0XG4gICAqL1xuICBhc3luYyBjcmVhdGUobmFtZSwga2FyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGFsZ28gPSBrYXJncy5hbGdvID09IHZvaWQgMCA/IFwic2FsdHlcIiAvKiBzYWx0eSAqLyA6IGthcmdzLmFsZ287XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlID0ga2FyZ3MudHJhbnNmZXJhYmxlID8/IHRydWU7XG4gICAgY29uc3QgaXNpdGggPSBrYXJncy5pc2l0aCA/PyBcIjFcIjtcbiAgICBsZXQgbnNpdGggPSBrYXJncy5uc2l0aCA/PyBcIjFcIjtcbiAgICBsZXQgd2l0cyA9IGthcmdzLndpdHMgPz8gW107XG4gICAgY29uc3QgdG9hZCA9IGthcmdzLnRvYWQgPz8gMDtcbiAgICBsZXQgZGNvZGUgPSBrYXJncy5kY29kZSA/PyBNdHJEZXguQmxha2UzXzI1NjtcbiAgICBjb25zdCBwcm94eSA9IGthcmdzLnByb3h5O1xuICAgIGNvbnN0IGRlbHByZSA9IGthcmdzLmRlbHByZTtcbiAgICBjb25zdCBkYXRhID0ga2FyZ3MuZGF0YSAhPSB2b2lkIDAgPyBba2FyZ3MuZGF0YV0gOiBbXTtcbiAgICBjb25zdCBwcmUgPSBrYXJncy5wcmU7XG4gICAgY29uc3Qgc3RhdGVzID0ga2FyZ3Muc3RhdGVzO1xuICAgIGNvbnN0IHJzdGF0ZXMgPSBrYXJncy5yc3RhdGVzO1xuICAgIGNvbnN0IHByeHMgPSBrYXJncy5wcnhzO1xuICAgIGNvbnN0IG54dHMgPSBrYXJncy5ueHRzO1xuICAgIGNvbnN0IG1oYWIgPSBrYXJncy5taGFiO1xuICAgIGNvbnN0IF9rZXlzID0ga2FyZ3Mua2V5cztcbiAgICBjb25zdCBfbmRpZ3MgPSBrYXJncy5uZGlncztcbiAgICBjb25zdCBicmFuID0ga2FyZ3MuYnJhbjtcbiAgICBjb25zdCBjb3VudCA9IGthcmdzLmNvdW50O1xuICAgIGxldCBuY291bnQgPSBrYXJncy5uY291bnQ7XG4gICAgY29uc3QgdGllciA9IGthcmdzLnRpZXI7XG4gICAgY29uc3QgZXh0ZXJuX3R5cGUgPSBrYXJncy5leHRlcm5fdHlwZTtcbiAgICBjb25zdCBleHRlcm4gPSBrYXJncy5leHRlcm47XG4gICAgaWYgKCF0cmFuc2ZlcmFibGUpIHtcbiAgICAgIG5jb3VudCA9IDA7XG4gICAgICBuc2l0aCA9IDA7XG4gICAgICBkY29kZSA9IE10ckRleC5FZDI1NTE5TjtcbiAgICB9XG4gICAgY29uc3QgeGFyZ3MgPSB7XG4gICAgICB0cmFuc2ZlcmFibGUsXG4gICAgICBpc2l0aCxcbiAgICAgIG5zaXRoLFxuICAgICAgd2l0cyxcbiAgICAgIHRvYWQsXG4gICAgICBwcm94eSxcbiAgICAgIGRlbHByZSxcbiAgICAgIGRjb2RlLFxuICAgICAgZGF0YSxcbiAgICAgIGFsZ28sXG4gICAgICBwcmUsXG4gICAgICBwcnhzLFxuICAgICAgbnh0cyxcbiAgICAgIG1oYWIsXG4gICAgICBzdGF0ZXMsXG4gICAgICByc3RhdGVzLFxuICAgICAga2V5czogX2tleXMsXG4gICAgICBuZGlnczogX25kaWdzLFxuICAgICAgYnJhbixcbiAgICAgIGNvdW50LFxuICAgICAgbmNvdW50LFxuICAgICAgdGllcixcbiAgICAgIGV4dGVybl90eXBlLFxuICAgICAgZXh0ZXJuXG4gICAgfTtcbiAgICBjb25zdCBrZWVwZXIgPSB0aGlzLmNsaWVudC5tYW5hZ2VyLm5ldyhhbGdvLCB0aGlzLmNsaWVudC5waWR4LCB4YXJncyk7XG4gICAgY29uc3QgW2tleXMsIG5kaWdzXSA9IGF3YWl0IGtlZXBlci5pbmNlcHQodHJhbnNmZXJhYmxlKTtcbiAgICB3aXRzID0gd2l0cyAhPT0gdm9pZCAwID8gd2l0cyA6IFtdO1xuICAgIGxldCBzZXJkZXIgPSB2b2lkIDA7XG4gICAgaWYgKGRlbHByZSA9PSB2b2lkIDApIHtcbiAgICAgIHNlcmRlciA9IGluY2VwdCh7XG4gICAgICAgIGtleXMsXG4gICAgICAgIGlzaXRoLFxuICAgICAgICBuZGlncyxcbiAgICAgICAgbnNpdGgsXG4gICAgICAgIHRvYWQsXG4gICAgICAgIHdpdHMsXG4gICAgICAgIGNuZmc6IFtdLFxuICAgICAgICBkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBWZXJzaW9uYWdlLFxuICAgICAgICBraW5kOiBcIkpTT05cIiAvKiBKU09OICovLFxuICAgICAgICBjb2RlOiBkY29kZSxcbiAgICAgICAgaW50aXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmRlciA9IGluY2VwdCh7XG4gICAgICAgIGtleXMsXG4gICAgICAgIGlzaXRoLFxuICAgICAgICBuZGlncyxcbiAgICAgICAgbnNpdGgsXG4gICAgICAgIHRvYWQsXG4gICAgICAgIHdpdHMsXG4gICAgICAgIGNuZmc6IFtdLFxuICAgICAgICBkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBWZXJzaW9uYWdlLFxuICAgICAgICBraW5kOiBcIkpTT05cIiAvKiBKU09OICovLFxuICAgICAgICBjb2RlOiBkY29kZSxcbiAgICAgICAgaW50aXZlOiBmYWxzZSxcbiAgICAgICAgZGVscHJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2lncyA9IGF3YWl0IGtlZXBlci5zaWduKGIoc2VyZGVyLnJhdykpO1xuICAgIGNvbnN0IGpzb25kYXRhID0ge1xuICAgICAgbmFtZSxcbiAgICAgIGljcDogc2VyZGVyLmtlZCxcbiAgICAgIHNpZ3MsXG4gICAgICBwcm94eSxcbiAgICAgIHNtaWRzOiBzdGF0ZXMgIT0gdm9pZCAwID8gc3RhdGVzLm1hcCgoc3RhdGUpID0+IHN0YXRlLmkpIDogdm9pZCAwLFxuICAgICAgcm1pZHM6IHJzdGF0ZXMgIT0gdm9pZCAwID8gcnN0YXRlcy5tYXAoKHN0YXRlKSA9PiBzdGF0ZS5pKSA6IHZvaWQgMFxuICAgIH07XG4gICAganNvbmRhdGFbYWxnb10gPSBrZWVwZXIucGFyYW1zKCk7XG4gICAgdGhpcy5jbGllbnQucGlkeCA9IHRoaXMuY2xpZW50LnBpZHggKyAxO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuY2xpZW50LmZldGNoKFwiL2lkZW50aWZpZXJzXCIsIFwiUE9TVFwiLCBqc29uZGF0YSk7XG4gICAgcmV0dXJuIG5ldyBFdmVudFJlc3VsdChzZXJkZXIsIHNpZ3MsIHJlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGludGVyYWN0aW9uIGV2ZW50IGluIGEgbWFuYWdlZCBpZGVudGlmaWVyXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7YW55fSBbZGF0YV0gT3B0aW9uIGRhdGEgdG8gYmUgYW5jaG9yZWQgaW4gdGhlIGludGVyYWN0aW9uIGV2ZW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEV2ZW50UmVzdWx0Pn0gQSBwcm9taXNlIHRvIHRoZSBpbnRlcmFjdGlvbiBldmVudCByZXN1bHRcbiAgICovXG4gIGFzeW5jIGludGVyYWN0KG5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBoYWIgPSBhd2FpdCB0aGlzLmdldChuYW1lKTtcbiAgICBjb25zdCBwcmUgPSBoYWIucHJlZml4O1xuICAgIGNvbnN0IHN0YXRlID0gaGFiLnN0YXRlO1xuICAgIGNvbnN0IHNuID0gcGFyc2VJbnQoc3RhdGUucywgMTYpO1xuICAgIGNvbnN0IGRpZyA9IHN0YXRlLmQ7XG4gICAgZGF0YSA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuICAgIGNvbnN0IHNlcmRlciA9IGludGVyYWN0KHtcbiAgICAgIHByZSxcbiAgICAgIHNuOiBzbiArIDEsXG4gICAgICBkYXRhLFxuICAgICAgZGlnLFxuICAgICAgdmVyc2lvbjogdm9pZCAwLFxuICAgICAga2luZDogdm9pZCAwXG4gICAgfSk7XG4gICAgY29uc3Qga2VlcGVyID0gdGhpcy5jbGllbnQubWFuYWdlci5nZXQoaGFiKTtcbiAgICBjb25zdCBzaWdzID0gYXdhaXQga2VlcGVyLnNpZ24oYihzZXJkZXIucmF3KSk7XG4gICAgY29uc3QganNvbmRhdGEgPSB7XG4gICAgICBpeG46IHNlcmRlci5rZWQsXG4gICAgICBzaWdzXG4gICAgfTtcbiAgICBqc29uZGF0YVtrZWVwZXIuYWxnb10gPSBrZWVwZXIucGFyYW1zKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2goXG4gICAgICBcIi9pZGVudGlmaWVycy9cIiArIG5hbWUgKyBcIj90eXBlPWl4blwiLFxuICAgICAgXCJQVVRcIixcbiAgICAgIGpzb25kYXRhXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IEV2ZW50UmVzdWx0KHNlcmRlciwgc2lncywgcmVzKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSByb3RhdGlvbiBldmVudCBpbiBhIG1hbmFnZWQgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7Um90YXRlSWRlbnRpZmllckFyZ3N9IFtrYXJnc10gT3B0aW9uYWwgcGFyYW1ldGVycyByZXF1aWVyZWQgdG8gZ2VuZXJhdGUgdGhlIHJvdGF0aW9uIGV2ZW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEV2ZW50UmVzdWx0Pn0gQSBwcm9taXNlIHRvIHRoZSByb3RhdGlvbiBldmVudCByZXN1bHRcbiAgICovXG4gIGFzeW5jIHJvdGF0ZShuYW1lLCBrYXJncyA9IHt9KSB7XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlID0ga2FyZ3MudHJhbnNmZXJhYmxlID8/IHRydWU7XG4gICAgY29uc3QgbmNvZGUgPSBrYXJncy5uY29kZSA/PyBNdHJEZXguRWQyNTUxOV9TZWVkO1xuICAgIGNvbnN0IG5jb3VudCA9IGthcmdzLm5jb3VudCA/PyAxO1xuICAgIGNvbnN0IGhhYiA9IGF3YWl0IHRoaXMuZ2V0KG5hbWUpO1xuICAgIGNvbnN0IHByZSA9IGhhYi5wcmVmaXg7XG4gICAgY29uc3QgZGVsZWdhdGVkID0gaGFiLnN0YXRlLmRpICE9PSBcIlwiO1xuICAgIGNvbnN0IHN0YXRlID0gaGFiLnN0YXRlO1xuICAgIGNvbnN0IGNvdW50ID0gc3RhdGUuay5sZW5ndGg7XG4gICAgY29uc3QgZGlnID0gc3RhdGUuZDtcbiAgICBjb25zdCByaWR4ID0gcGFyc2VJbnQoc3RhdGUucywgMTYpICsgMTtcbiAgICBjb25zdCB3aXRzID0gc3RhdGUuYjtcbiAgICBsZXQgaXNpdGggPSBzdGF0ZS5udDtcbiAgICBsZXQgbnNpdGggPSBrYXJncy5uc2l0aCA/PyBpc2l0aDtcbiAgICBpZiAoaXNpdGggPT0gdm9pZCAwKVxuICAgICAgaXNpdGggPSBgJHtNYXRoLm1heCgxLCBNYXRoLmNlaWwoY291bnQgLyAyKSkudG9TdHJpbmcoMTYpfWA7XG4gICAgaWYgKG5zaXRoID09IHZvaWQgMClcbiAgICAgIG5zaXRoID0gYCR7TWF0aC5tYXgoMSwgTWF0aC5jZWlsKG5jb3VudCAvIDIpKS50b1N0cmluZygxNil9YDtcbiAgICBjb25zdCBjc3QgPSBuZXcgVGhvbGRlcih7IHNpdGg6IGlzaXRoIH0pLnNpdGg7XG4gICAgY29uc3QgbnN0ID0gbmV3IFRob2xkZXIoeyBzaXRoOiBuc2l0aCB9KS5zaXRoO1xuICAgIGNvbnN0IGtlZXBlciA9IHRoaXMuY2xpZW50Lm1hbmFnZXIuZ2V0KGhhYik7XG4gICAgY29uc3QgbmNvZGVzID0ga2FyZ3MubmNvZGVzID8/IG5ldyBBcnJheShuY291bnQpLmZpbGwobmNvZGUpO1xuICAgIGNvbnN0IHN0YXRlcyA9IGthcmdzLnN0YXRlcyA9PSB2b2lkIDAgPyBbXSA6IGthcmdzLnN0YXRlcztcbiAgICBjb25zdCByc3RhdGVzID0ga2FyZ3MucnN0YXRlcyA9PSB2b2lkIDAgPyBbXSA6IGthcmdzLnJzdGF0ZXM7XG4gICAgY29uc3QgW2tleXMsIG5kaWdzXSA9IGF3YWl0IGtlZXBlci5yb3RhdGUoXG4gICAgICBuY29kZXMsXG4gICAgICB0cmFuc2ZlcmFibGUsXG4gICAgICBzdGF0ZXMsXG4gICAgICByc3RhdGVzXG4gICAgKTtcbiAgICBjb25zdCBjdXRzID0ga2FyZ3MuY3V0cyA/PyBbXTtcbiAgICBjb25zdCBhZGRzID0ga2FyZ3MuYWRkcyA/PyBbXTtcbiAgICBjb25zdCBkYXRhID0ga2FyZ3MuZGF0YSAhPSB2b2lkIDAgPyBba2FyZ3MuZGF0YV0gOiBbXTtcbiAgICBjb25zdCB0b2FkID0ga2FyZ3MudG9hZDtcbiAgICBjb25zdCBpbGsgPSBkZWxlZ2F0ZWQgPyBJbGtzLmRydCA6IElsa3Mucm90O1xuICAgIGNvbnN0IHNlcmRlciA9IHJvdGF0ZSh7XG4gICAgICBwcmUsXG4gICAgICBpbGssXG4gICAgICBrZXlzLFxuICAgICAgZGlnLFxuICAgICAgc246IHJpZHgsXG4gICAgICBpc2l0aDogY3N0LFxuICAgICAgbnNpdGg6IG5zdCxcbiAgICAgIG5kaWdzLFxuICAgICAgdG9hZCxcbiAgICAgIHdpdHMsXG4gICAgICBjdXRzLFxuICAgICAgYWRkcyxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICBjb25zdCBzaWdzID0gYXdhaXQga2VlcGVyLnNpZ24oYihzZXJkZXIucmF3KSk7XG4gICAgY29uc3QganNvbmRhdGEgPSB7XG4gICAgICByb3Q6IHNlcmRlci5rZWQsXG4gICAgICBzaWdzLFxuICAgICAgc21pZHM6IHN0YXRlcyAhPSB2b2lkIDAgPyBzdGF0ZXMubWFwKChzdGF0ZTIpID0+IHN0YXRlMi5pKSA6IHZvaWQgMCxcbiAgICAgIHJtaWRzOiByc3RhdGVzICE9IHZvaWQgMCA/IHJzdGF0ZXMubWFwKChzdGF0ZTIpID0+IHN0YXRlMi5pKSA6IHZvaWQgMFxuICAgIH07XG4gICAganNvbmRhdGFba2VlcGVyLmFsZ29dID0ga2VlcGVyLnBhcmFtcygpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKFxuICAgICAgXCIvaWRlbnRpZmllcnMvXCIgKyBuYW1lLFxuICAgICAgXCJQVVRcIixcbiAgICAgIGpzb25kYXRhXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IEV2ZW50UmVzdWx0KHNlcmRlciwgc2lncywgcmVzKTtcbiAgfVxuICAvKipcbiAgICogQXV0aG9yaXplIGFuIGVuZHBvaW50IHByb3ZpZGVyIGluIGEgZ2l2ZW4gcm9sZSBmb3IgYSBtYW5hZ2VkIGlkZW50aWZpZXJcbiAgICogQHJlbWFya3NcbiAgICogVHlwaWNhbGx5IHVzZWQgdG8gYXV0aG9yaXplIHRoZSBhZ2VudCB0byBiZSB0aGUgZW5kcG9pbnQgcHJvdmlkZXIgZm9yIHRoZSBpZGVudGlmaWVyIGluIHRoZSByb2xlIG9mIGBhZ2VudGBcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb3IgYWxpYXMgb2YgdGhlIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvbGUgQXV0aG9yaXplZCByb2xlIGZvciBlaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlaWRdIE9wdGlvbmFsIHFiNjQgb2YgZW5kcG9pbnQgcHJvdmlkZXIgdG8gYmUgYXV0aG9yaXplZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YW1wPW5vd10gT3B0aW9uYWwgZGF0ZS10aW1lLXN0YW1wIFJGQy0zMzM5IHByb2ZpbGUgb2YgaXNvODYwMSBkYXRldGltZS4gTm93IGlzIHRoZSBkZWZhdWx0IGlmIG5vdCBwcm92aWRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFdmVudFJlc3VsdD59IEEgcHJvbWlzZSB0byB0aGUgcmVzdWx0IG9mIHRoZSBhdXRob3JpemF0aW9uXG4gICAqL1xuICBhc3luYyBhZGRFbmRSb2xlKG5hbWUsIHJvbGUsIGVpZCwgc3RhbXApIHtcbiAgICBjb25zdCBoYWIgPSBhd2FpdCB0aGlzLmdldChuYW1lKTtcbiAgICBjb25zdCBwcmUgPSBoYWIucHJlZml4O1xuICAgIGNvbnN0IHJweSA9IHRoaXMubWFrZUVuZFJvbGUocHJlLCByb2xlLCBlaWQsIHN0YW1wKTtcbiAgICBjb25zdCBrZWVwZXIgPSB0aGlzLmNsaWVudC5tYW5hZ2VyLmdldChoYWIpO1xuICAgIGNvbnN0IHNpZ3MgPSBhd2FpdCBrZWVwZXIuc2lnbihiKHJweS5yYXcpKTtcbiAgICBjb25zdCBqc29uZGF0YSA9IHtcbiAgICAgIHJweTogcnB5LmtlZCxcbiAgICAgIHNpZ3NcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuY2xpZW50LmZldGNoKFxuICAgICAgXCIvaWRlbnRpZmllcnMvXCIgKyBuYW1lICsgXCIvZW5kcm9sZXNcIixcbiAgICAgIFwiUE9TVFwiLFxuICAgICAganNvbmRhdGFcbiAgICApO1xuICAgIHJldHVybiBuZXcgRXZlbnRSZXN1bHQocnB5LCBzaWdzLCByZXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiAvZW5kL3JvbGUvYWRkIHJlcGx5IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZSBQcmVmaXggb2YgdGhlIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvbGUgQXV0aG9yaXplZCByb2xlIGZvciBlaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlaWRdIE9wdGlvbmFsIHFiNjQgb2YgZW5kcG9pbnQgcHJvdmlkZXIgdG8gYmUgYXV0aG9yaXplZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YW1wPW5vd10gT3B0aW9uYWwgZGF0ZS10aW1lLXN0YW1wIFJGQy0zMzM5IHByb2ZpbGUgb2YgaXNvODYwMSBkYXRldGltZS4gTm93IGlzIHRoZSBkZWZhdWx0IGlmIG5vdCBwcm92aWRlZFxuICAgKiBAcmV0dXJucyB7U2VyZGVyfSBUaGUgcmVwbHkgbWVzc2FnZVxuICAgKi9cbiAgbWFrZUVuZFJvbGUocHJlLCByb2xlLCBlaWQsIHN0YW1wKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGNpZDogcHJlLFxuICAgICAgcm9sZVxuICAgIH07XG4gICAgaWYgKGVpZCAhPSB2b2lkIDApIHtcbiAgICAgIGRhdGEuZWlkID0gZWlkO1xuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IFwiL2VuZC9yb2xlL2FkZFwiO1xuICAgIHJldHVybiByZXBseShyb3V0ZSwgZGF0YSwgc3RhbXAsIHZvaWQgMCwgXCJKU09OXCIgLyogSlNPTiAqLyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWVtYmVycyBvZiBhIGdyb3VwIGlkZW50aWZpZXJcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvciBhbGlhcyBvZiB0aGUgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSAtIEEgcHJvbWlzZSB0byB0aGUgbGlzdCBvZiBtZW1iZXJzXG4gICAqL1xuICBhc3luYyBtZW1iZXJzKG5hbWUpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChcbiAgICAgIFwiL2lkZW50aWZpZXJzL1wiICsgbmFtZSArIFwiL21lbWJlcnNcIixcbiAgICAgIFwiR0VUXCIsXG4gICAgICB2b2lkIDBcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG59O1xudmFyIEV2ZW50UmVzdWx0ID0gY2xhc3Mge1xuICBfc2VyZGVyO1xuICBfc2lncztcbiAgcHJvbWlzZTtcbiAgY29uc3RydWN0b3Ioc2VyZGVyLCBzaWdzLCBwcm9taXNlKSB7XG4gICAgdGhpcy5fc2VyZGVyID0gc2VyZGVyO1xuICAgIHRoaXMuX3NpZ3MgPSBzaWdzO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIH1cbiAgZ2V0IHNlcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VyZGVyO1xuICB9XG4gIGdldCBzaWdzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWdzO1xuICB9XG4gIGFzeW5jIG9wKCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucHJvbWlzZTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvZW5kL2VuZGluZy50c1xudmFyIEZBTFNZID0gW2ZhbHNlLCAwLCBcIj8wXCIsIFwibm9cIiwgXCJmYWxzZVwiLCBcIkZhbHNlXCIsIFwib2ZmXCJdO1xudmFyIFRSVVRIWSA9IFt0cnVlLCAxLCBcIj8xXCIsIFwieWVzXCIsIFwidHJ1ZVwiLCBcIlRydWVcIiwgXCJvblwiXTtcbnZhciBTaWduYWdlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXJrZXJzLCBpbmRleGVkLCBzaWduZXIsIG9yZGluYWwsIGRpZ2VzdCwga2luZCkge1xuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgdGhpcy5pbmRleGVkID0gaW5kZXhlZDtcbiAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICB0aGlzLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gIH1cbiAgbWFya2VycztcbiAgaW5kZXhlZCA9IGZhbHNlO1xuICBzaWduZXI7XG4gIG9yZGluYWw7XG4gIGRpZ2VzdDtcbiAga2luZDtcbn07XG5mdW5jdGlvbiBzaWduYXR1cmUoc2lnbmFnZXMpIHtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KCk7XG4gIGZvciAoY29uc3Qgc2lnbmFnZSBvZiBzaWduYWdlcykge1xuICAgIGxldCBtYXJrZXJzO1xuICAgIGxldCBpbmRleGVkID0gc2lnbmFnZS5pbmRleGVkO1xuICAgIGNvbnN0IHNpZ25lciA9IHNpZ25hZ2Uuc2lnbmVyO1xuICAgIGNvbnN0IG9yZGluYWwgPSBzaWduYWdlLm9yZGluYWw7XG4gICAgY29uc3QgZGlnZXN0ID0gc2lnbmFnZS5kaWdlc3Q7XG4gICAgY29uc3Qga2luZCA9IHNpZ25hZ2Uua2luZDtcbiAgICBsZXQgdGFncztcbiAgICBpZiAoc2lnbmFnZS5tYXJrZXJzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICB0YWdzID0gQXJyYXkuZnJvbShzaWduYWdlLm1hcmtlcnMua2V5cygpKTtcbiAgICAgIG1hcmtlcnMgPSBBcnJheS5mcm9tKHNpZ25hZ2UubWFya2Vycy52YWx1ZXMoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlcnMgPSBzaWduYWdlLm1hcmtlcnM7XG4gICAgICB0YWdzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuICAgIGlmIChpbmRleGVkID09IHZvaWQgMCkge1xuICAgICAgaW5kZXhlZCA9IG1hcmtlcnNbMF0gaW5zdGFuY2VvZiBTaWdlcjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCB0YWcgPSBcImluZGV4ZWRcIjtcbiAgICBsZXQgdmFsID0gaW5kZXhlZCA/IFwiPzFcIiA6IFwiPzBcIjtcbiAgICBpdGVtcy5wdXNoKGAke3RhZ309XCIke3ZhbH1cImApO1xuICAgIGlmIChzaWduZXIgIT0gdm9pZCAwKSB7XG4gICAgICBpdGVtcy5wdXNoKGBzaWduZXI9XCIke3NpZ25lcn1cImApO1xuICAgIH1cbiAgICBpZiAob3JkaW5hbCAhPSB2b2lkIDApIHtcbiAgICAgIGl0ZW1zLnB1c2goYG9yZGluYWw9XCIke29yZGluYWx9XCJgKTtcbiAgICB9XG4gICAgaWYgKGRpZ2VzdCAhPSB2b2lkIDApIHtcbiAgICAgIGl0ZW1zLnB1c2goYGRpZ2VzdD1cIiR7ZGlnZXN0fVwiYCk7XG4gICAgfVxuICAgIGlmIChraW5kICE9IHZvaWQgMCkge1xuICAgICAgaXRlbXMucHVzaChga2luZD1cIiR7a2luZH1cImApO1xuICAgIH1cbiAgICBtYXJrZXJzLmZvckVhY2goKG1hcmtlciwgaWR4KSA9PiB7XG4gICAgICBsZXQgdGFnMjtcbiAgICAgIGlmICh0YWdzICE9IHZvaWQgMCAmJiB0YWdzLmxlbmd0aCA+IGlkeCkge1xuICAgICAgICB0YWcyID0gdGFnc1tpZHhdO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgaW5zdGFuY2VvZiBTaWdlcikge1xuICAgICAgICBpZiAoIWluZGV4ZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEluZGV4ZWQgc2lnbmF0dXJlIG1hcmtlciAke21hcmtlcn0gd2hlbiBpbmRleGVkIEZhbHNlLmBcbiAgICAgICAgICApO1xuICAgICAgICB0YWcyID0gbWFya2VyLmluZGV4LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5pbmRleGVkIHNpZ25hdHVyZSBtYXJrZXIgJHttYXJrZXJ9IHdoZW4gaW5kZXhlZCBUcnVlLmBcbiAgICAgICAgICApO1xuICAgICAgICB0YWcyID0gbWFya2VyLnZlcmZlci5xYjY0O1xuICAgICAgfVxuICAgICAgdmFsID0gbWFya2VyLnFiNjQ7XG4gICAgICBpdGVtcy5wdXNoKGAke3RhZzJ9PVwiJHt2YWx9XCJgKTtcbiAgICB9KTtcbiAgICB2YWx1ZXMucHVzaChpdGVtcy5qb2luKFwiO1wiKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIZWFkZXJzKFtbXCJTaWduYXR1cmVcIiwgdmFsdWVzLmpvaW4oXCIsXCIpXV0pO1xufVxuZnVuY3Rpb24gZGVzaWduYXR1cmUodmFsdWUpIHtcbiAgY29uc3QgdmFsdWVzID0gdmFsdWUucmVwbGFjZShcIiBcIiwgXCJcIikuc3BsaXQoXCIsXCIpO1xuICBjb25zdCBzaWduYWdlcyA9IG5ldyBBcnJheSgpO1xuICB2YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgY29uc3QgZGljdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdmFsLnNwbGl0KFwiO1wiKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBjb25zdCBzcGxpdHMgPSB2LnNwbGl0KFwiPVwiLCAyKTtcbiAgICAgIGRpY3Quc2V0KHNwbGl0c1swXSwgc3BsaXRzWzFdLnJlcGxhY2VBbGwoJ1wiJywgXCJcIikpO1xuICAgIH0pO1xuICAgIGlmICghZGljdC5oYXMoXCJpbmRleGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTWlzc2luZyBpbmRleGVkIGZpZWxkIGluIFNpZ25hdHVyZSBoZWFkZXIgc2lnbmFnZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGRpY3QuZ2V0KFwiaW5kZXhlZFwiKTtcbiAgICBjb25zdCBpbmRleGVkID0gIUZBTFNZLmluY2x1ZGVzKGl0ZW0pO1xuICAgIGRpY3QuZGVsZXRlKFwiaW5kZXhlZFwiKTtcbiAgICBsZXQgc2lnbmVyO1xuICAgIGlmIChkaWN0LmhhcyhcInNpZ25lclwiKSkge1xuICAgICAgc2lnbmVyID0gZGljdC5nZXQoXCJzaWduZXJcIik7XG4gICAgICBkaWN0LmRlbGV0ZShcInNpZ25lclwiKTtcbiAgICB9XG4gICAgbGV0IG9yZGluYWw7XG4gICAgaWYgKGRpY3QuaGFzKFwib3JkaW5hbFwiKSkge1xuICAgICAgb3JkaW5hbCA9IGRpY3QuZ2V0KFwib3JkaW5hbFwiKTtcbiAgICAgIGRpY3QuZGVsZXRlKFwib3JkaW5hbFwiKTtcbiAgICB9XG4gICAgbGV0IGRpZ2VzdDtcbiAgICBpZiAoZGljdC5oYXMoXCJkaWdlc3RcIikpIHtcbiAgICAgIGRpZ2VzdCA9IGRpY3QuZ2V0KFwiZGlnZXN0XCIpO1xuICAgICAgZGljdC5kZWxldGUoXCJkaWdlc3RcIik7XG4gICAgfVxuICAgIGxldCBraW5kO1xuICAgIGlmIChkaWN0LmhhcyhcImtpbmRcIikpIHtcbiAgICAgIGtpbmQgPSBkaWN0LmdldChcImtpbmRcIik7XG4gICAgICBkaWN0LmRlbGV0ZShcImtpbmRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtpbmQgPSBcIkNFU1JcIjtcbiAgICB9XG4gICAgbGV0IG1hcmtlcnM7XG4gICAgaWYgKGtpbmQgPT0gXCJDRVNSXCIpIHtcbiAgICAgIG1hcmtlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZGljdC5mb3JFYWNoKCh2YWwyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ZWQpIHtcbiAgICAgICAgICBtYXJrZXJzLnNldChrZXksIG5ldyBTaWdlcih7IHFiNjQ6IHZhbDIgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtlcnMuc2V0KGtleSwgbmV3IENpZ2FyKHsgcWI2NDogdmFsMiB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrZXJzID0gZGljdDtcbiAgICB9XG4gICAgc2lnbmFnZXMucHVzaChcbiAgICAgIG5ldyBTaWduYWdlKG1hcmtlcnMsIGluZGV4ZWQsIHNpZ25lciwgb3JkaW5hbCwgZGlnZXN0LCBraW5kKVxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gc2lnbmFnZXM7XG59XG5cbi8vIHNyYy9rZXJpL2NvcmUvYXV0aGluZy50c1xudmFyIEF1dGhlbnRpY2F0ZXIgPSBjbGFzcyBfQXV0aGVudGljYXRlciB7XG4gIHN0YXRpYyBEZWZhdWx0RmllbGRzID0gW1xuICAgIFwiQG1ldGhvZFwiLFxuICAgIFwiQHBhdGhcIixcbiAgICBcInNpZ25pZnktcmVzb3VyY2VcIixcbiAgICBIRUFERVJfU0lHX1RJTUUudG9Mb3dlckNhc2UoKVxuICBdO1xuICBfdmVyZmVyO1xuICBfY3NpZztcbiAgY29uc3RydWN0b3IoY3NpZywgdmVyZmVyKSB7XG4gICAgdGhpcy5fY3NpZyA9IGNzaWc7XG4gICAgdGhpcy5fdmVyZmVyID0gdmVyZmVyO1xuICB9XG4gIHZlcmlmeShoZWFkZXJzLCBtZXRob2QsIHBhdGgpIHtcbiAgICBjb25zdCBzaWdpbnB1dDIgPSBoZWFkZXJzLmdldChIRUFERVJfU0lHX0lOUFVUKTtcbiAgICBpZiAoc2lnaW5wdXQyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlMiA9IGhlYWRlcnMuZ2V0KFwiU2lnbmF0dXJlXCIpO1xuICAgIGlmIChzaWduYXR1cmUyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlucHV0cyA9IGRlc2lnaW5wdXQoc2lnaW5wdXQyKTtcbiAgICBpbnB1dHMgPSBpbnB1dHMuZmlsdGVyKChpbnB1dCkgPT4gaW5wdXQubmFtZSA9PSBcInNpZ25pZnlcIik7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gbmV3IEFycmF5KCk7XG4gICAgICBpbnB1dC5maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgICAgICAgaWYgKGZpZWxkID09IFwiQG1ldGhvZFwiKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBcIiR7ZmllbGR9XCI6ICR7bWV0aG9kfWApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT0gXCJAcGF0aFwiKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBcIiR7ZmllbGR9XCI6ICR7cGF0aH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhlYWRlcnMuaGFzKGZpZWxkKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub3JtYWxpemUoaGVhZGVycy5nZXQoZmllbGQpKTtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYFwiJHtmaWVsZH1cIjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KCk7XG4gICAgICB2YWx1ZXMucHVzaChgKCR7aW5wdXQuZmllbGRzLmpvaW4oXCIgXCIpfSlgKTtcbiAgICAgIHZhbHVlcy5wdXNoKGBjcmVhdGVkPSR7aW5wdXQuY3JlYXRlZH1gKTtcbiAgICAgIGlmIChpbnB1dC5leHBpcmVzICE9IHZvaWQgMCkge1xuICAgICAgICB2YWx1ZXMucHVzaChgZXhwaXJlcz0ke2lucHV0LmV4cGlyZXN9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQubm9uY2UgIT0gdm9pZCAwKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGBub25jZT0ke2lucHV0Lm5vbmNlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0LmtleWlkICE9IHZvaWQgMCkge1xuICAgICAgICB2YWx1ZXMucHVzaChga2V5aWQ9JHtpbnB1dC5rZXlpZH1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5jb250ZXh0ICE9IHZvaWQgMCkge1xuICAgICAgICB2YWx1ZXMucHVzaChgY29udGV4dD0ke2lucHV0LmNvbnRleHR9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQuYWxnICE9IHZvaWQgMCkge1xuICAgICAgICB2YWx1ZXMucHVzaChgYWxnPSR7aW5wdXQuYWxnfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gdmFsdWVzLmpvaW4oXCI7XCIpO1xuICAgICAgaXRlbXMucHVzaChgXCJAc2lnbmF0dXJlLXBhcmFtczogJHtwYXJhbXN9XCJgKTtcbiAgICAgIGNvbnN0IHNlciA9IGl0ZW1zLmpvaW4oXCJcXG5cIik7XG4gICAgICBjb25zdCBzaWduYWdlID0gZGVzaWduYXR1cmUoc2lnbmF0dXJlMik7XG4gICAgICBjb25zdCBjaWcgPSBzaWduYWdlWzBdLm1hcmtlcnMuZ2V0KGlucHV0Lm5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl92ZXJmZXIudmVyaWZ5KGNpZy5yYXcsIHNlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduYXR1cmUgZm9yICR7aW5wdXQua2V5aWR9IGludmFsaWQuYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2lnbihoZWFkZXJzLCBtZXRob2QsIHBhdGgsIGZpZWxkcykge1xuICAgIGlmIChmaWVsZHMgPT0gdm9pZCAwKSB7XG4gICAgICBmaWVsZHMgPSBfQXV0aGVudGljYXRlci5EZWZhdWx0RmllbGRzO1xuICAgIH1cbiAgICBjb25zdCBbaGVhZGVyLCBzaWddID0gc2lnaW5wdXQodGhpcy5fY3NpZywge1xuICAgICAgbmFtZTogXCJzaWduaWZ5XCIsXG4gICAgICBtZXRob2QsXG4gICAgICBwYXRoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGZpZWxkcyxcbiAgICAgIGFsZzogXCJlZDI1NTE5XCIsXG4gICAgICBrZXlpZDogdGhpcy5fY3NpZy52ZXJmZXIucWI2NFxuICAgIH0pO1xuICAgIGhlYWRlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICBjb25zdCBtYXJrZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBtYXJrZXJzLnNldChcInNpZ25pZnlcIiwgc2lnKTtcbiAgICBjb25zdCBzaWduYWdlID0gbmV3IFNpZ25hZ2UobWFya2VycywgZmFsc2UpO1xuICAgIGNvbnN0IHNpZ25lZCA9IHNpZ25hdHVyZShbc2lnbmFnZV0pO1xuICAgIHNpZ25lZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9rZWVwaW5nLnRzXG52YXIgS2V5TWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2FsdGVyLCBleHRlcm5hbE1vZHVsZXMgPSBbXSkge1xuICAgIHRoaXMuc2FsdGVyID0gc2FsdGVyO1xuICAgIHRoaXMuc2FsdGVyID0gc2FsdGVyO1xuICAgIGZvciAoY29uc3QgbW9kIG9mIGV4dGVybmFsTW9kdWxlcykge1xuICAgICAgdGhpcy5tb2R1bGVzW21vZC50eXBlXSA9IG1vZC5tb2R1bGU7XG4gICAgfVxuICB9XG4gIG1vZHVsZXMgPSB7fTtcbiAgbmV3KGFsZ28sIHBpZHgsIGthcmdzKSB7XG4gICAgc3dpdGNoIChhbGdvKSB7XG4gICAgICBjYXNlIFwic2FsdHlcIiAvKiBzYWx0eSAqLzpcbiAgICAgICAgcmV0dXJuIG5ldyBTYWx0eUtlZXBlcihcbiAgICAgICAgICB0aGlzLnNhbHRlcixcbiAgICAgICAgICBwaWR4LFxuICAgICAgICAgIGthcmdzW1wia2lkeFwiXSxcbiAgICAgICAgICBrYXJnc1tcInRpZXJcIl0sXG4gICAgICAgICAga2FyZ3NbXCJ0cmFuc2ZlcmFibGVcIl0sXG4gICAgICAgICAga2FyZ3NbXCJzdGVtXCJdLFxuICAgICAgICAgIGthcmdzW1wiY29kZVwiXSxcbiAgICAgICAgICBrYXJnc1tcImNvdW50XCJdLFxuICAgICAgICAgIGthcmdzW1wiaWNvZGVzXCJdLFxuICAgICAgICAgIGthcmdzW1wibmNvZGVcIl0sXG4gICAgICAgICAga2FyZ3NbXCJuY291bnRcIl0sXG4gICAgICAgICAga2FyZ3NbXCJuY29kZXNcIl0sXG4gICAgICAgICAga2FyZ3NbXCJkY29kZVwiXSxcbiAgICAgICAgICBrYXJnc1tcImJyYW5cIl0sXG4gICAgICAgICAga2FyZ3NbXCJzeGx0XCJdXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwicmFuZHlcIiAvKiByYW5keSAqLzpcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5keUtlZXBlcihcbiAgICAgICAgICB0aGlzLnNhbHRlcixcbiAgICAgICAgICBrYXJnc1tcImNvZGVcIl0sXG4gICAgICAgICAga2FyZ3NbXCJjb3VudFwiXSxcbiAgICAgICAgICBrYXJnc1tcImljb2Rlc1wiXSxcbiAgICAgICAgICBrYXJnc1tcInRyYW5zZmVyYWJsZVwiXSxcbiAgICAgICAgICBrYXJnc1tcIm5jb2RlXCJdLFxuICAgICAgICAgIGthcmdzW1wibmNvdW50XCJdLFxuICAgICAgICAgIGthcmdzW1wibmNvZGVzXCJdLFxuICAgICAgICAgIGthcmdzW1wiZGNvZGVcIl0sXG4gICAgICAgICAga2FyZ3NbXCJwcnhzXCJdLFxuICAgICAgICAgIGthcmdzW1wibnh0c1wiXVxuICAgICAgICApO1xuICAgICAgY2FzZSBcImdyb3VwXCIgLyogZ3JvdXAgKi86XG4gICAgICAgIHJldHVybiBuZXcgR3JvdXBLZWVwZXIoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBrYXJnc1tcIm1oYWJcIl0sXG4gICAgICAgICAga2FyZ3NbXCJzdGF0ZXNcIl0sXG4gICAgICAgICAga2FyZ3NbXCJyc3RhdGVzXCJdLFxuICAgICAgICAgIGthcmdzW1wia2V5c1wiXSxcbiAgICAgICAgICBrYXJnc1tcIm5kaWdzXCJdXG4gICAgICAgICk7XG4gICAgICBjYXNlIFwiZXh0ZXJuXCIgLyogZXh0ZXJuICovOiB7XG4gICAgICAgIGNvbnN0IE1vZHVsZUNvbnN0cnVjdG9yID0gdGhpcy5tb2R1bGVzW2thcmdzLmV4dGVybl90eXBlXTtcbiAgICAgICAgaWYgKCFNb2R1bGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGB1bnN1cHBvcnRlZCBleHRlcm5hbCBtb2R1bGUgdHlwZSAke2thcmdzLmV4dGVybl90eXBlfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTW9kdWxlQ29uc3RydWN0b3IocGlkeCwga2FyZ3MpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhbGdvXCIpO1xuICAgIH1cbiAgfVxuICBnZXQoYWlkKSB7XG4gICAgaWYgKGFpZFtcInNhbHR5XCIgLyogc2FsdHkgKi9dKSB7XG4gICAgICBjb25zdCBrYXJncyA9IGFpZFtcInNhbHR5XCIgLyogc2FsdHkgKi9dO1xuICAgICAgcmV0dXJuIG5ldyBTYWx0eUtlZXBlcihcbiAgICAgICAgdGhpcy5zYWx0ZXIsXG4gICAgICAgIGthcmdzW1wicGlkeFwiXSxcbiAgICAgICAga2FyZ3NbXCJraWR4XCJdLFxuICAgICAgICBrYXJnc1tcInRpZXJcIl0sXG4gICAgICAgIGthcmdzW1widHJhbnNmZXJhYmxlXCJdLFxuICAgICAgICBrYXJnc1tcInN0ZW1cIl0sXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBrYXJnc1tcImljb2Rlc1wiXSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGthcmdzW1wibmNvZGVzXCJdLFxuICAgICAgICBrYXJnc1tcImRjb2RlXCJdLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGthcmdzW1wic3hsdFwiXVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGFpZFtcInJhbmR5XCIgLyogcmFuZHkgKi9dKSB7XG4gICAgICBjb25zdCBwcmUgPSBuZXcgUHJlZml4ZXIoeyBxYjY0OiBhaWRbXCJwcmVmaXhcIl0gfSk7XG4gICAgICBjb25zdCBrYXJncyA9IGFpZFtcInJhbmR5XCIgLyogcmFuZHkgKi9dO1xuICAgICAgcmV0dXJuIG5ldyBSYW5keUtlZXBlcihcbiAgICAgICAgdGhpcy5zYWx0ZXIsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHByZS50cmFuc2ZlcmFibGUsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBbXSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBrYXJnc1tcInByeHNcIl0sXG4gICAgICAgIGthcmdzW1wibnh0c1wiXVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGFpZFtcImdyb3VwXCIgLyogZ3JvdXAgKi9dKSB7XG4gICAgICBjb25zdCBrYXJncyA9IGFpZFtcImdyb3VwXCIgLyogZ3JvdXAgKi9dO1xuICAgICAgcmV0dXJuIG5ldyBHcm91cEtlZXBlcihcbiAgICAgICAgdGhpcyxcbiAgICAgICAga2FyZ3NbXCJtaGFiXCJdLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAga2FyZ3NbXCJrZXlzXCJdLFxuICAgICAgICBrYXJnc1tcIm5kaWdzXCJdXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoYWlkW1wiZXh0ZXJuXCIgLyogZXh0ZXJuICovXSkge1xuICAgICAgY29uc3Qga2FyZ3MgPSBhaWRbXCJleHRlcm5cIiAvKiBleHRlcm4gKi9dO1xuICAgICAgY29uc3QgdHlwID0ga2FyZ3MuZXh0ZXJuX3R5cGU7XG4gICAgICBpZiAodHlwIGluIHRoaXMubW9kdWxlcykge1xuICAgICAgICBjb25zdCBtb2QgPSBuZXcgdGhpcy5tb2R1bGVzW3R5cF0oa2FyZ3NbXCJwaWR4XCJdLCBrYXJncyk7XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4dGVybmFsIG1vZHVsZSB0eXBlICR7dHlwfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsZ28gbm90IGFsbG93ZWQgeWV0YCk7XG4gICAgfVxuICB9XG59O1xudmFyIFNhbHR5S2VlcGVyID0gY2xhc3Mge1xuICBhZWlkO1xuICBlbmNyeXB0ZXI7XG4gIGRlY3J5cHRlcjtcbiAgc2FsdGVyO1xuICBwaWR4O1xuICBraWR4O1xuICB0aWVyO1xuICB0cmFuc2ZlcmFibGU7XG4gIHN0ZW07XG4gIGNvZGU7XG4gIGNvdW50O1xuICBpY29kZXM7XG4gIG5jb2RlO1xuICBuY291bnQ7XG4gIG5jb2RlcztcbiAgZGNvZGU7XG4gIHN4bHQ7XG4gIGJyYW47XG4gIGNyZWF0b3I7XG4gIGFsZ28gPSBcInNhbHR5XCIgLyogc2FsdHkgKi87XG4gIHNpZ25lcnM7XG4gIGNvbnN0cnVjdG9yKHNhbHRlciwgcGlkeCwga2lkeCA9IDAsIHRpZXIgPSBcImxvd1wiIC8qIGxvdyAqLywgdHJhbnNmZXJhYmxlID0gZmFsc2UsIHN0ZW0gPSB2b2lkIDAsIGNvZGUgPSBNdHJEZXguRWQyNTUxOV9TZWVkLCBjb3VudCA9IDEsIGljb2RlcyA9IHZvaWQgMCwgbmNvZGUgPSBNdHJEZXguRWQyNTUxOV9TZWVkLCBuY291bnQgPSAxLCBuY29kZXMgPSB2b2lkIDAsIGRjb2RlID0gTXRyRGV4LkJsYWtlM18yNTYsIGJyYW4gPSB2b2lkIDAsIHN4bHQgPSB2b2lkIDApIHtcbiAgICB0aGlzLnNhbHRlciA9IHNhbHRlcjtcbiAgICBjb25zdCBzaWduZXIgPSB0aGlzLnNhbHRlci5zaWduZXIodm9pZCAwLCB0cmFuc2ZlcmFibGUgPSBmYWxzZSk7XG4gICAgdGhpcy5hZWlkID0gc2lnbmVyLnZlcmZlci5xYjY0O1xuICAgIHRoaXMuZW5jcnlwdGVyID0gbmV3IEVuY3J5cHRlcih7fSwgYih0aGlzLmFlaWQpKTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoe30sIHNpZ25lci5xYjY0Yik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm5jb2RlID0gbmNvZGU7XG4gICAgdGhpcy50aWVyID0gdGllcjtcbiAgICB0aGlzLmljb2RlcyA9IGljb2RlcyA9PSB2b2lkIDAgPyBuZXcgQXJyYXkoY291bnQpLmZpbGwoY29kZSkgOiBpY29kZXM7XG4gICAgdGhpcy5uY29kZXMgPSBuY29kZXMgPT0gdm9pZCAwID8gbmV3IEFycmF5KG5jb3VudCkuZmlsbChuY29kZSkgOiBuY29kZXM7XG4gICAgdGhpcy5kY29kZSA9IGRjb2RlO1xuICAgIHRoaXMucGlkeCA9IHBpZHg7XG4gICAgdGhpcy5raWR4ID0ga2lkeDtcbiAgICB0aGlzLnRyYW5zZmVyYWJsZSA9IHRyYW5zZmVyYWJsZTtcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgdGhpcy5uY291bnQgPSBuY291bnQ7XG4gICAgdGhpcy5zdGVtID0gc3RlbSA9PSB2b2lkIDAgPyBcInNpZ25pZnk6YWlkXCIgOiBzdGVtO1xuICAgIGlmIChicmFuICE9IHZvaWQgMCkge1xuICAgICAgdGhpcy5icmFuID0gTXRyRGV4LlNhbHRfMTI4ICsgXCJBXCIgKyBicmFuLnNsaWNlKDAsIDIxKTtcbiAgICAgIHRoaXMuY3JlYXRvciA9IG5ldyBTYWx0eUNyZWF0b3IodGhpcy5icmFuLCB0aGlzLnRpZXIsIHRoaXMuc3RlbSk7XG4gICAgICB0aGlzLnN4bHQgPSB0aGlzLmVuY3J5cHRlci5lbmNyeXB0KGIodGhpcy5jcmVhdG9yLnNhbHQpKS5xYjY0O1xuICAgIH0gZWxzZSBpZiAoc3hsdCA9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY3JlYXRvciA9IG5ldyBTYWx0eUNyZWF0b3Iodm9pZCAwLCB0aGlzLnRpZXIsIHRoaXMuc3RlbSk7XG4gICAgICB0aGlzLnN4bHQgPSB0aGlzLmVuY3J5cHRlci5lbmNyeXB0KGIodGhpcy5jcmVhdG9yLnNhbHQpKS5xYjY0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN4bHQgPSBzeGx0O1xuICAgICAgY29uc3QgY2lwaCA9IG5ldyBDaXBoZXIoeyBxYjY0OiB0aGlzLnN4bHQgfSk7XG4gICAgICB0aGlzLmNyZWF0b3IgPSBuZXcgU2FsdHlDcmVhdG9yKFxuICAgICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KG51bGwsIGNpcGgpLnFiNjQsXG4gICAgICAgIHRpZXIsXG4gICAgICAgIHRoaXMuc3RlbVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5zaWduZXJzID0gdGhpcy5jcmVhdG9yLmNyZWF0ZShcbiAgICAgIHRoaXMuaWNvZGVzLFxuICAgICAgdGhpcy5uY291bnQsXG4gICAgICB0aGlzLm5jb2RlLFxuICAgICAgdGhpcy50cmFuc2ZlcmFibGUsXG4gICAgICB0aGlzLnBpZHgsXG4gICAgICAwLFxuICAgICAgdGhpcy5raWR4LFxuICAgICAgZmFsc2VcbiAgICApLnNpZ25lcnM7XG4gIH1cbiAgcGFyYW1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzeGx0OiB0aGlzLnN4bHQsXG4gICAgICBwaWR4OiB0aGlzLnBpZHgsXG4gICAgICBraWR4OiB0aGlzLmtpZHgsXG4gICAgICBzdGVtOiB0aGlzLnN0ZW0sXG4gICAgICB0aWVyOiB0aGlzLnRpZXIsXG4gICAgICBpY29kZXM6IHRoaXMuaWNvZGVzLFxuICAgICAgbmNvZGVzOiB0aGlzLm5jb2RlcyxcbiAgICAgIGRjb2RlOiB0aGlzLmRjb2RlLFxuICAgICAgdHJhbnNmZXJhYmxlOiB0aGlzLnRyYW5zZmVyYWJsZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgaW5jZXB0KHRyYW5zZmVyYWJsZSkge1xuICAgIHRoaXMudHJhbnNmZXJhYmxlID0gdHJhbnNmZXJhYmxlO1xuICAgIHRoaXMua2lkeCA9IDA7XG4gICAgY29uc3Qgc2lnbmVycyA9IHRoaXMuY3JlYXRvci5jcmVhdGUoXG4gICAgICB0aGlzLmljb2RlcyxcbiAgICAgIHRoaXMuY291bnQsXG4gICAgICB0aGlzLmNvZGUsXG4gICAgICB0aGlzLnRyYW5zZmVyYWJsZSxcbiAgICAgIHRoaXMucGlkeCxcbiAgICAgIDAsXG4gICAgICB0aGlzLmtpZHgsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgdmVyZmVycyA9IHNpZ25lcnMuc2lnbmVycy5tYXAoKHNpZ25lcikgPT4gc2lnbmVyLnZlcmZlci5xYjY0KTtcbiAgICBjb25zdCBuc2lnbmVycyA9IHRoaXMuY3JlYXRvci5jcmVhdGUoXG4gICAgICB0aGlzLm5jb2RlcyxcbiAgICAgIHRoaXMubmNvdW50LFxuICAgICAgdGhpcy5uY29kZSxcbiAgICAgIHRoaXMudHJhbnNmZXJhYmxlLFxuICAgICAgdGhpcy5waWR4LFxuICAgICAgMCxcbiAgICAgIHRoaXMuaWNvZGVzPy5sZW5ndGgsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgZGlnZXJzID0gbnNpZ25lcnMuc2lnbmVycy5tYXAoXG4gICAgICAobnNpZ25lcikgPT4gbmV3IERpZ2VyKHsgY29kZTogdGhpcy5kY29kZSB9LCBuc2lnbmVyLnZlcmZlci5xYjY0YikucWI2NFxuICAgICk7XG4gICAgcmV0dXJuIFt2ZXJmZXJzLCBkaWdlcnNdO1xuICB9XG4gIGFzeW5jIHJvdGF0ZShuY29kZXMsIHRyYW5zZmVyYWJsZSkge1xuICAgIHRoaXMubmNvZGVzID0gbmNvZGVzO1xuICAgIHRoaXMudHJhbnNmZXJhYmxlID0gdHJhbnNmZXJhYmxlO1xuICAgIGNvbnN0IHNpZ25lcnMgPSB0aGlzLmNyZWF0b3IuY3JlYXRlKFxuICAgICAgdGhpcy5uY29kZXMsXG4gICAgICB0aGlzLm5jb3VudCxcbiAgICAgIHRoaXMubmNvZGUsXG4gICAgICB0aGlzLnRyYW5zZmVyYWJsZSxcbiAgICAgIHRoaXMucGlkeCxcbiAgICAgIDAsXG4gICAgICB0aGlzLmtpZHggKyB0aGlzLmljb2Rlcy5sZW5ndGgsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgdmVyZmVycyA9IHNpZ25lcnMuc2lnbmVycy5tYXAoKHNpZ25lcikgPT4gc2lnbmVyLnZlcmZlci5xYjY0KTtcbiAgICB0aGlzLmtpZHggPSB0aGlzLmtpZHggKyB0aGlzLmljb2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbnNpZ25lcnMgPSB0aGlzLmNyZWF0b3IuY3JlYXRlKFxuICAgICAgdGhpcy5uY29kZXMsXG4gICAgICB0aGlzLm5jb3VudCxcbiAgICAgIHRoaXMubmNvZGUsXG4gICAgICB0aGlzLnRyYW5zZmVyYWJsZSxcbiAgICAgIHRoaXMucGlkeCxcbiAgICAgIDAsXG4gICAgICB0aGlzLmtpZHggKyB0aGlzLmljb2Rlcy5sZW5ndGgsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgZGlnZXJzID0gbnNpZ25lcnMuc2lnbmVycy5tYXAoXG4gICAgICAobnNpZ25lcikgPT4gbmV3IERpZ2VyKHsgY29kZTogdGhpcy5kY29kZSB9LCBuc2lnbmVyLnZlcmZlci5xYjY0YikucWI2NFxuICAgICk7XG4gICAgcmV0dXJuIFt2ZXJmZXJzLCBkaWdlcnNdO1xuICB9XG4gIGFzeW5jIHNpZ24oc2VyLCBpbmRleGVkID0gdHJ1ZSwgaW5kaWNlcyA9IHZvaWQgMCwgb25kaWNlcyA9IHZvaWQgMCkge1xuICAgIGNvbnN0IHNpZ25lcnMgPSB0aGlzLmNyZWF0b3IuY3JlYXRlKFxuICAgICAgdGhpcy5pY29kZXMsXG4gICAgICB0aGlzLm5jb3VudCxcbiAgICAgIHRoaXMubmNvZGUsXG4gICAgICB0aGlzLnRyYW5zZmVyYWJsZSxcbiAgICAgIHRoaXMucGlkeCxcbiAgICAgIDAsXG4gICAgICB0aGlzLmtpZHgsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgaWYgKGluZGV4ZWQpIHtcbiAgICAgIGNvbnN0IHNpZ2VycyA9IFtdO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBbaiwgc2lnbmVyXSBvZiBzaWduZXJzLnNpZ25lcnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChpbmRpY2VzICE9IHZvaWQgMCkge1xuICAgICAgICAgIGkgPSBpbmRpY2VzW2pdO1xuICAgICAgICAgIGlmICh0eXBlb2YgaSAhPSBcIm51bWJlclwiIHx8IGkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHNpZ25pbmcgaW5kZXggPSAke2l9LCBub3Qgd2hvbGUgbnVtYmVyLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSBqO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvID0gMDtcbiAgICAgICAgaWYgKG9uZGljZXMgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgbyA9IG9uZGljZXNbal07XG4gICAgICAgICAgaWYgKG8gPT0gdm9pZCAwIHx8IHR5cGVvZiBvID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG8gIT0gXCJudW1iZXJcIiAmJiBvID49IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgb25kZXggPSAke299LCBub3Qgd2hvbGUgbnVtYmVyLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8gPSBpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ2Vycy5wdXNoKFxuICAgICAgICAgIHNpZ25lci5zaWduKHNlciwgaSwgbyA9PSB2b2lkIDAgPyB0cnVlIDogZmFsc2UsIG8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnZXJzLm1hcCgoc2lnZXIpID0+IHNpZ2VyLnFiNjQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaWdhcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgWywgc2lnbmVyXSBvZiBzaWduZXJzLnNpZ25lcnMuZW50cmllcygpKSB7XG4gICAgICAgIGNpZ2Fycy5wdXNoKHNpZ25lci5zaWduKHNlcikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNpZ2Fycy5tYXAoKGNpZ2FyKSA9PiBjaWdhci5xYjY0KTtcbiAgICB9XG4gIH1cbn07XG52YXIgUmFuZHlLZWVwZXIgPSBjbGFzcyB7XG4gIHNhbHRlcjtcbiAgY29kZTtcbiAgY291bnQ7XG4gIGljb2RlcztcbiAgdHJhbnNmZXJhYmxlO1xuICBuY291bnQ7XG4gIG5jb2RlcztcbiAgbmNvZGU7XG4gIGRjb2RlO1xuICBwcnhzO1xuICBueHRzO1xuICBhZWlkO1xuICBlbmNyeXB0ZXI7XG4gIGRlY3J5cHRlcjtcbiAgY3JlYXRvcjtcbiAgYWxnbyA9IFwicmFuZHlcIiAvKiByYW5keSAqLztcbiAgc2lnbmVycztcbiAgY29uc3RydWN0b3Ioc2FsdGVyLCBjb2RlID0gTXRyRGV4LkVkMjU1MTlfU2VlZCwgY291bnQgPSAxLCBpY29kZXMgPSB2b2lkIDAsIHRyYW5zZmVyYWJsZSA9IGZhbHNlLCBuY29kZSA9IE10ckRleC5FZDI1NTE5X1NlZWQsIG5jb3VudCA9IDEsIG5jb2RlcywgZGNvZGUgPSBNdHJEZXguQmxha2UzXzI1NiwgcHJ4cyA9IHZvaWQgMCwgbnh0cyA9IHZvaWQgMCkge1xuICAgIHRoaXMuc2FsdGVyID0gc2FsdGVyO1xuICAgIHRoaXMuaWNvZGVzID0gaWNvZGVzID09IHZvaWQgMCA/IG5ldyBBcnJheShjb3VudCkuZmlsbChjb2RlKSA6IGljb2RlcztcbiAgICB0aGlzLm5jb2RlcyA9IG5jb2RlcyA9PSB2b2lkIDAgPyBuZXcgQXJyYXkobmNvdW50KS5maWxsKG5jb2RlKSA6IG5jb2RlcztcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubmNvZGUgPSBuY29kZTtcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgdGhpcy5uY291bnQgPSBuY291bnQ7XG4gICAgY29uc3Qgc2lnbmVyID0gdGhpcy5zYWx0ZXIuc2lnbmVyKHZvaWQgMCwgdHJhbnNmZXJhYmxlID0gZmFsc2UpO1xuICAgIHRoaXMuYWVpZCA9IHNpZ25lci52ZXJmZXIucWI2NDtcbiAgICB0aGlzLmVuY3J5cHRlciA9IG5ldyBFbmNyeXB0ZXIoe30sIGIodGhpcy5hZWlkKSk7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHt9LCBzaWduZXIucWI2NGIpO1xuICAgIHRoaXMubnh0cyA9IG54dHMgPz8gW107XG4gICAgdGhpcy5wcnhzID0gcHJ4cyA/PyBbXTtcbiAgICB0aGlzLnRyYW5zZmVyYWJsZSA9IHRyYW5zZmVyYWJsZTtcbiAgICB0aGlzLmljb2RlcyA9IGljb2RlcztcbiAgICB0aGlzLm5jb2RlcyA9IG5jb2RlcztcbiAgICB0aGlzLmRjb2RlID0gZGNvZGU7XG4gICAgdGhpcy5jcmVhdG9yID0gbmV3IFJhbmR5Q3JlYXRvcigpO1xuICAgIHRoaXMuc2lnbmVycyA9IHRoaXMucHJ4cy5tYXAoXG4gICAgICAocHJ4KSA9PiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KFxuICAgICAgICBuZXcgQ2lwaGVyKHsgcWI2NDogcHJ4IH0pLnFiNjRiLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHRoaXMudHJhbnNmZXJhYmxlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG54dHM6IHRoaXMubnh0cyxcbiAgICAgIHByeHM6IHRoaXMucHJ4cyxcbiAgICAgIHRyYW5zZmVyYWJsZTogdGhpcy50cmFuc2ZlcmFibGVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGluY2VwdCh0cmFuc2ZlcmFibGUpIHtcbiAgICB0aGlzLnRyYW5zZmVyYWJsZSA9IHRyYW5zZmVyYWJsZTtcbiAgICBjb25zdCBzaWduZXJzID0gdGhpcy5jcmVhdG9yLmNyZWF0ZShcbiAgICAgIHRoaXMuaWNvZGVzLFxuICAgICAgdGhpcy5jb3VudCxcbiAgICAgIHRoaXMuY29kZSxcbiAgICAgIHRoaXMudHJhbnNmZXJhYmxlXG4gICAgKTtcbiAgICB0aGlzLnByeHMgPSBzaWduZXJzLnNpZ25lcnMubWFwKFxuICAgICAgKHNpZ25lcikgPT4gdGhpcy5lbmNyeXB0ZXIuZW5jcnlwdCh2b2lkIDAsIHNpZ25lcikucWI2NFxuICAgICk7XG4gICAgY29uc3QgdmVyZmVycyA9IHNpZ25lcnMuc2lnbmVycy5tYXAoKHNpZ25lcikgPT4gc2lnbmVyLnZlcmZlci5xYjY0KTtcbiAgICBjb25zdCBuc2lnbmVycyA9IHRoaXMuY3JlYXRvci5jcmVhdGUoXG4gICAgICB0aGlzLm5jb2RlcyxcbiAgICAgIHRoaXMubmNvdW50LFxuICAgICAgdGhpcy5uY29kZSxcbiAgICAgIHRoaXMudHJhbnNmZXJhYmxlXG4gICAgKTtcbiAgICB0aGlzLm54dHMgPSBuc2lnbmVycy5zaWduZXJzLm1hcChcbiAgICAgIChzaWduZXIpID0+IHRoaXMuZW5jcnlwdGVyLmVuY3J5cHQodm9pZCAwLCBzaWduZXIpLnFiNjRcbiAgICApO1xuICAgIGNvbnN0IGRpZ2VycyA9IG5zaWduZXJzLnNpZ25lcnMubWFwKFxuICAgICAgKG5zaWduZXIpID0+IG5ldyBEaWdlcih7IGNvZGU6IHRoaXMuZGNvZGUgfSwgbnNpZ25lci52ZXJmZXIucWI2NGIpLnFiNjRcbiAgICApO1xuICAgIHJldHVybiBbdmVyZmVycywgZGlnZXJzXTtcbiAgfVxuICBhc3luYyByb3RhdGUobmNvZGVzLCB0cmFuc2ZlcmFibGUpIHtcbiAgICB0aGlzLm5jb2RlcyA9IG5jb2RlcztcbiAgICB0aGlzLnRyYW5zZmVyYWJsZSA9IHRyYW5zZmVyYWJsZTtcbiAgICB0aGlzLnByeHMgPSB0aGlzLm54dHM7XG4gICAgY29uc3Qgc2lnbmVycyA9IHRoaXMubnh0cy5tYXAoXG4gICAgICAobnh0KSA9PiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG5ldyBDaXBoZXIoeyBxYjY0OiBueHQgfSksXG4gICAgICAgIHRoaXMudHJhbnNmZXJhYmxlXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCB2ZXJmZXJzID0gc2lnbmVycy5tYXAoKHNpZ25lcikgPT4gc2lnbmVyLnZlcmZlci5xYjY0KTtcbiAgICBjb25zdCBuc2lnbmVycyA9IHRoaXMuY3JlYXRvci5jcmVhdGUoXG4gICAgICB0aGlzLm5jb2RlcyxcbiAgICAgIHRoaXMubmNvdW50LFxuICAgICAgdGhpcy5uY29kZSxcbiAgICAgIHRoaXMudHJhbnNmZXJhYmxlXG4gICAgKTtcbiAgICB0aGlzLm54dHMgPSBuc2lnbmVycy5zaWduZXJzLm1hcChcbiAgICAgIChzaWduZXIpID0+IHRoaXMuZW5jcnlwdGVyLmVuY3J5cHQodm9pZCAwLCBzaWduZXIpLnFiNjRcbiAgICApO1xuICAgIGNvbnN0IGRpZ2VycyA9IG5zaWduZXJzLnNpZ25lcnMubWFwKFxuICAgICAgKG5zaWduZXIpID0+IG5ldyBEaWdlcih7IGNvZGU6IHRoaXMuZGNvZGUgfSwgbnNpZ25lci52ZXJmZXIucWI2NGIpLnFiNjRcbiAgICApO1xuICAgIHJldHVybiBbdmVyZmVycywgZGlnZXJzXTtcbiAgfVxuICBhc3luYyBzaWduKHNlciwgaW5kZXhlZCA9IHRydWUsIGluZGljZXMgPSB2b2lkIDAsIG9uZGljZXMgPSB2b2lkIDApIHtcbiAgICBjb25zdCBzaWduZXJzID0gdGhpcy5wcnhzLm1hcChcbiAgICAgIChwcngpID0+IHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoXG4gICAgICAgIG5ldyBDaXBoZXIoeyBxYjY0OiBwcnggfSkucWI2NGIsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdGhpcy50cmFuc2ZlcmFibGVcbiAgICAgIClcbiAgICApO1xuICAgIGlmIChpbmRleGVkKSB7XG4gICAgICBjb25zdCBzaWdlcnMgPSBbXTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgW2osIHNpZ25lcl0gb2Ygc2lnbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGluZGljZXMgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgaSA9IGluZGljZXNbal07XG4gICAgICAgICAgaWYgKHR5cGVvZiBpICE9IFwibnVtYmVyXCIgfHwgaSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgc2lnbmluZyBpbmRleCA9ICR7aX0sIG5vdCB3aG9sZSBudW1iZXIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IGo7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG8gPSAwO1xuICAgICAgICBpZiAob25kaWNlcyAhPSB2b2lkIDApIHtcbiAgICAgICAgICBvID0gb25kaWNlc1tqXTtcbiAgICAgICAgICBpZiAobyA9PSB2b2lkIDAgfHwgdHlwZW9mIG8gPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbyAhPSBcIm51bWJlclwiICYmIG8gPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCBvbmRleCA9ICR7b30sIG5vdCB3aG9sZSBudW1iZXIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnZXJzLnB1c2goXG4gICAgICAgICAgc2lnbmVyLnNpZ24oc2VyLCBpLCBvID09IHZvaWQgMCA/IHRydWUgOiBmYWxzZSwgbylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaWdlcnMubWFwKChzaWdlcikgPT4gc2lnZXIucWI2NCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNpZ2FycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBbLCBzaWduZXJdIG9mIHNpZ25lcnMuZW50cmllcygpKSB7XG4gICAgICAgIGNpZ2Fycy5wdXNoKHNpZ25lci5zaWduKHNlcikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNpZ2Fycy5tYXAoKGNpZ2FyKSA9PiBjaWdhci5xYjY0KTtcbiAgICB9XG4gIH1cbn07XG52YXIgR3JvdXBLZWVwZXIgPSBjbGFzcyB7XG4gIG1hbmFnZXI7XG4gIG1oYWI7XG4gIGdrZXlzID0gW107XG4gIGdkaWdzID0gW107XG4gIGFsZ28gPSBcImdyb3VwXCIgLyogZ3JvdXAgKi87XG4gIHNpZ25lcnM7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIG1oYWIsIHN0YXRlcyA9IHZvaWQgMCwgcnN0YXRlcyA9IHZvaWQgMCwga2V5cyA9IFtdLCBuZGlncyA9IFtdKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBpZiAoc3RhdGVzICE9IHZvaWQgMCkge1xuICAgICAga2V5cyA9IHN0YXRlcy5tYXAoKHN0YXRlKSA9PiBzdGF0ZVtcImtcIl1bMF0pO1xuICAgIH1cbiAgICBpZiAocnN0YXRlcyAhPSB2b2lkIDApIHtcbiAgICAgIG5kaWdzID0gcnN0YXRlcy5tYXAoKHN0YXRlKSA9PiBzdGF0ZVtcIm5cIl1bMF0pO1xuICAgIH1cbiAgICB0aGlzLmdrZXlzID0gc3RhdGVzPy5tYXAoKHN0YXRlKSA9PiBzdGF0ZVtcImtcIl1bMF0pID8/IGtleXM7XG4gICAgdGhpcy5nZGlncyA9IHJzdGF0ZXM/Lm1hcCgoc3RhdGUpID0+IHN0YXRlW1wiblwiXVswXSkgPz8gbmRpZ3M7XG4gICAgdGhpcy5taGFiID0gbWhhYjtcbiAgICB0aGlzLnNpZ25lcnMgPSBbXTtcbiAgfVxuICBhc3luYyBpbmNlcHQoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmdrZXlzLCB0aGlzLmdkaWdzXTtcbiAgfVxuICBhc3luYyByb3RhdGUoX25jb2RlcywgX3RyYW5zZmVyYWJsZSwgc3RhdGVzLCByc3RhdGVzKSB7XG4gICAgdGhpcy5na2V5cyA9IHN0YXRlcy5tYXAoKHN0YXRlKSA9PiBzdGF0ZVtcImtcIl1bMF0pO1xuICAgIHRoaXMuZ2RpZ3MgPSByc3RhdGVzLm1hcCgoc3RhdGUpID0+IHN0YXRlW1wiblwiXVswXSk7XG4gICAgcmV0dXJuIFt0aGlzLmdrZXlzLCB0aGlzLmdkaWdzXTtcbiAgfVxuICBhc3luYyBzaWduKHNlciwgaW5kZXhlZCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMubWhhYi5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGF0ZSBpbiBtaGFiYCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRoaXMubWhhYltcInN0YXRlXCJdW1wia1wiXVswXTtcbiAgICBjb25zdCBuZGlnID0gdGhpcy5taGFiW1wic3RhdGVcIl1bXCJuXCJdWzBdO1xuICAgIGNvbnN0IGNzaSA9IHRoaXMuZ2tleXMuaW5kZXhPZihrZXkpO1xuICAgIGNvbnN0IHBuaSA9IHRoaXMuZ2RpZ3MuaW5kZXhPZihuZGlnKTtcbiAgICBjb25zdCBta2VlcGVyID0gdGhpcy5tYW5hZ2VyLmdldCh0aGlzLm1oYWIpO1xuICAgIHJldHVybiBhd2FpdCBta2VlcGVyLnNpZ24oc2VyLCBpbmRleGVkLCBbY3NpXSwgW3BuaV0pO1xuICB9XG4gIHBhcmFtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWhhYjogdGhpcy5taGFiLFxuICAgICAga2V5czogdGhpcy5na2V5cyxcbiAgICAgIG5kaWdzOiB0aGlzLmdkaWdzXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvYXBwL2NvbnRhY3RpbmcudHNcbnZhciBDb250YWN0cyA9IGNsYXNzIHtcbiAgY2xpZW50O1xuICAvKipcbiAgICogQ29udGFjdHNcbiAgICogQHBhcmFtIHtTaWduaWZ5Q2xpZW50fSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IGNvbnRhY3RzXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2dyb3VwXSBPcHRpb25hbCBncm91cCBuYW1lIHRvIGZpbHRlciBjb250YWN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbHRlckZpZWxkXSBPcHRpb25hbCBmaWVsZCBuYW1lIHRvIGZpbHRlciBjb250YWN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbHRlclZhbHVlXSBPcHRpb25hbCBmaWVsZCB2YWx1ZSB0byBmaWx0ZXIgY29udGFjdHNcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsaXN0IG9mIGNvbnRhY3RzXG4gICAqL1xuICBhc3luYyBsaXN0KGdyb3VwLCBmaWx0ZXJGaWVsZCwgZmlsdGVyVmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKGdyb3VwICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJncm91cFwiLCBncm91cCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJGaWVsZCAhPT0gdm9pZCAwICYmIGZpbHRlclZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJmaWx0ZXJfZmllbGRcIiwgZmlsdGVyRmllbGQpO1xuICAgICAgcGFyYW1zLmFwcGVuZChcImZpbHRlcl92YWx1ZVwiLCBmaWx0ZXJWYWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBgL2NvbnRhY3RzP2AgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICBjb25zdCBtZXRob2QgPSBcIkdFVFwiO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgbnVsbCk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGNvbnRhY3RcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmUgUHJlZml4IG9mIHRoZSBjb250YWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgY29udGFjdFxuICAgKi9cbiAgYXN5bmMgZ2V0KHByZSkge1xuICAgIGNvbnN0IHBhdGggPSBgL2NvbnRhY3RzL2AgKyBwcmU7XG4gICAgY29uc3QgbWV0aG9kID0gXCJHRVRcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIG51bGwpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBjb250YWN0XG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlIFByZWZpeCBvZiB0aGUgY29udGFjdFxuICAgKiBAcGFyYW0ge2FueX0gaW5mbyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY29udGFjdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb25cbiAgICovXG4gIGFzeW5jIGFkZChwcmUsIGluZm8pIHtcbiAgICBjb25zdCBwYXRoID0gYC9jb250YWN0cy9gICsgcHJlO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgaW5mbyk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGNvbnRhY3RcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmUgUHJlZml4IG9mIHRoZSBjb250YWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKHByZSkge1xuICAgIGNvbnN0IHBhdGggPSBgL2NvbnRhY3RzL2AgKyBwcmU7XG4gICAgY29uc3QgbWV0aG9kID0gXCJERUxFVEVcIjtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb250YWN0XG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlIFByZWZpeCBvZiB0aGUgY29udGFjdFxuICAgKiBAcGFyYW0ge2FueX0gaW5mbyBVcGRhdGVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb250YWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgcmVzdWx0IG9mIHRoZSB1cGRhdGVcbiAgICovXG4gIGFzeW5jIHVwZGF0ZShwcmUsIGluZm8pIHtcbiAgICBjb25zdCBwYXRoID0gYC9jb250YWN0cy9gICsgcHJlO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiUFVUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBpbmZvKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxufTtcbnZhciBDaGFsbGVuZ2VzID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBDaGFsbGVuZ2VzXG4gICAqIEBwYXJhbSB7U2lnbmlmeUNsaWVudH0gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gY2hhbGxlbmdlIHdvcmQgbGlzdCBiYXNlZCBvbiBCSVAzOVxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmVuZ3RoIEludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBzdHJlbmd0aCBvZiB0aGUgY2hhbGxlbmdlLiBUeXBpY2FsbHkgMTI4IG9yIDI1NlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIGxpc3Qgb2YgcmFuZG9tIHdvcmRzXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZShzdHJlbmd0aCA9IDEyOCkge1xuICAgIGNvbnN0IHBhdGggPSBgL2NoYWxsZW5nZXM/c3RyZW5ndGg9JHtzdHJlbmd0aC50b1N0cmluZygpfWA7XG4gICAgY29uc3QgbWV0aG9kID0gXCJHRVRcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIG51bGwpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNwb25kIHRvIGEgY2hhbGxlbmdlIGJ5IHNpZ25pbmcgYSBtZXNzYWdlIHdpdGggdGhlIGxpc3Qgb2Ygd29yZHNcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb3IgYWxpYXMgb2YgdGhlIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlY2lwaWVudCBQcmVmaXggb2YgdGhlIHJlY2lwaWVudCBvZiB0aGUgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB3b3JkcyBMaXN0IG9mIHdvcmRzIHRvIGVtYmVkIGluIHRoZSBzaWduZWQgcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdCBvZiB0aGUgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIHJlc3BvbmQobmFtZSwgcmVjaXBpZW50LCB3b3Jkcykge1xuICAgIGNvbnN0IGhhYiA9IGF3YWl0IHRoaXMuY2xpZW50LmlkZW50aWZpZXJzKCkuZ2V0KG5hbWUpO1xuICAgIGNvbnN0IGV4Y2hhbmdlcyA9IHRoaXMuY2xpZW50LmV4Y2hhbmdlcygpO1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBleGNoYW5nZXMuc2VuZChcbiAgICAgIG5hbWUsXG4gICAgICBcImNoYWxsZW5nZVwiLFxuICAgICAgaGFiLFxuICAgICAgXCIvY2hhbGxlbmdlL3Jlc3BvbnNlXCIsXG4gICAgICB7IHdvcmRzIH0sXG4gICAgICB7fSxcbiAgICAgIFtyZWNpcGllbnRdXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICAvKipcbiAgICogQXNrIEFnZW50IHRvIHZlcmlmeSBhIGdpdmVuIHNlbmRlciBzaWduZWQgdGhlIHByb3ZpZGVkIHdvcmRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgUHJlZml4IG9mIHRoZSBpZGVudGlmaWVyIHRoYXQgd2FzIGNoYWxsZW5nZWRcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB3b3JkcyBMaXN0IG9mIGNoYWxsZW5nZSB3b3JkcyB0byBjaGVjayBmb3JcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRvIHRoZSBsb25nIHJ1bm5pbmcgb3BlcmF0aW9uXG4gICAqL1xuICBhc3luYyB2ZXJpZnkoc291cmNlLCB3b3Jkcykge1xuICAgIGNvbnN0IHBhdGggPSBgL2NoYWxsZW5nZXNfdmVyaWZ5LyR7c291cmNlfWA7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHdvcmRzXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGRhdGEpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrIGNoYWxsZW5nZSByZXNwb25zZSBhcyBzaWduZWQgYW5kIGFjY2VwdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgUHJlZml4IG9mIHRoZSBpZGVudGlmaWVyIHRoYXQgd2FzIGNoYWxsZW5nZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNhaWQgcWI2NCBBSUQgb2YgZXhuIG1lc3NhZ2UgcmVwcmVzZW50aW5nIHRoZSBzaWduZWQgcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgcmVzcG9uZGVkKHNvdXJjZSwgc2FpZCkge1xuICAgIGNvbnN0IHBhdGggPSBgL2NoYWxsZW5nZXNfdmVyaWZ5LyR7c291cmNlfWA7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQVVRcIjtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgc2FpZFxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9hcHAvY29yaW5nLnRzXG5pbXBvcnQgbGlic29kaXVtNiBmcm9tIFwibGlic29kaXVtLXdyYXBwZXJzLXN1bW9cIjtcbmZ1bmN0aW9uIHJhbmRvbVBhc3Njb2RlKCkge1xuICBjb25zdCByYXcgPSBsaWJzb2RpdW02LnJhbmRvbWJ5dGVzX2J1ZigxNik7XG4gIGNvbnN0IHNhbHRlciA9IG5ldyBTYWx0ZXIoeyByYXcgfSk7XG4gIHJldHVybiBzYWx0ZXIucWI2NC5zdWJzdHJpbmcoMiwgMjMpO1xufVxuZnVuY3Rpb24gcmFuZG9tTm9uY2UoKSB7XG4gIGNvbnN0IHNlZWQgPSBsaWJzb2RpdW02LnJhbmRvbWJ5dGVzX2J1ZihsaWJzb2RpdW02LmNyeXB0b19zaWduX1NFRURCWVRFUyk7XG4gIGNvbnN0IHNlZWRxYjY0ID0gbmV3IE1hdHRlcih7IHJhdzogc2VlZCwgY29kZTogTXRyRGV4LkVkMjU1MTlfU2VlZCB9KTtcbiAgcmV0dXJuIHNlZWRxYjY0LnFiNjQ7XG59XG52YXIgT29iaXMgPSBjbGFzcyB7XG4gIGNsaWVudDtcbiAgLyoqXG4gICAqIE9vYmlzXG4gICAqIEBwYXJhbSB7U2lnbmlmeUNsaWVudH0gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBPT0JJKHMpIGZvciBhIG1hbmFnZWQgaW5kZW50aWZpZXIgZm9yIGEgZ2l2ZW4gcm9sZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlIEF1dGhvcml6ZWQgcm9sZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIE9PQkkocylcbiAgICovXG4gIGFzeW5jIGdldChuYW1lLCByb2xlID0gXCJhZ2VudFwiKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnMvJHtuYW1lfS9vb2Jpcz9yb2xlPSR7cm9sZX1gO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBudWxsKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBPT0JJXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb29iaSBUaGUgT09CSSB0byBiZSByZXNvbHZlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FsaWFzXSBPcHRpb25hbCBuYW1lIG9yIGFsaWFzIHRvIGxpbmsgdGhlIE9PQkkgcmVzb2x1dGlvbiB0byBhIGNvbnRhY3RcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uXG4gICAqL1xuICBhc3luYyByZXNvbHZlKG9vYmksIGFsaWFzKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvb29iaXNgO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB1cmw6IG9vYmlcbiAgICB9O1xuICAgIGlmIChhbGlhcyAhPT0gdm9pZCAwKSB7XG4gICAgICBkYXRhLm9vYmlhbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGRhdGEpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG59O1xudmFyIE9wZXJhdGlvbnMgPSBjbGFzcyB7XG4gIGNsaWVudDtcbiAgLyoqXG4gICAqIE9wZXJhdGlvbnNcbiAgICogQHBhcmFtIHtTaWduaWZ5Q2xpZW50fSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3BlcmF0aW9uIHN0YXR1c1xuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvbj59IEEgcHJvbWlzZSB0byB0aGUgc3RhdHVzIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGFzeW5jIGdldChuYW1lKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvb3BlcmF0aW9ucy8ke25hbWV9YDtcbiAgICBjb25zdCBkYXRhID0gbnVsbDtcbiAgICBjb25zdCBtZXRob2QgPSBcIkdFVFwiO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgZGF0YSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3Qgb3BlcmF0aW9uc1xuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2VsZWN0IG9wZXJhdGlvbnMgYnkgdHlwZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25bXT59IEEgbGlzdCBvZiBvcGVyYXRpb25zXG4gICAqL1xuICBhc3luYyBsaXN0KHR5cGUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKHR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zLmFwcGVuZChcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBgL29wZXJhdGlvbnM/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgIGNvbnN0IGRhdGEgPSBudWxsO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIG9wZXJhdGlvblxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBhc3luYyBkZWxldGUobmFtZSkge1xuICAgIGNvbnN0IHBhdGggPSBgL29wZXJhdGlvbnMvJHtuYW1lfWA7XG4gICAgY29uc3QgZGF0YSA9IG51bGw7XG4gICAgY29uc3QgbWV0aG9kID0gXCJERUxFVEVcIjtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBQb2xsIGZvciBvcGVyYXRpb24gdG8gYmVjb21lIGNvbXBsZXRlZC5cbiAgICovXG4gIGFzeW5jIHdhaXQob3AsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG1pblNsZWVwID0gb3B0aW9ucy5taW5TbGVlcCA/PyAxMDtcbiAgICBjb25zdCBtYXhTbGVlcCA9IG9wdGlvbnMubWF4U2xlZXAgPz8gMWU0O1xuICAgIGNvbnN0IGluY3JlYXNlRmFjdG9yID0gb3B0aW9ucy5pbmNyZWFzZUZhY3RvciA/PyA1MDtcbiAgICBpZiAob3AubWV0YWRhdGE/LmRlcGVuZHM/LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCB0aGlzLndhaXQob3AubWV0YWRhdGEuZGVwZW5kcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcC5kb25lID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gb3A7XG4gICAgfVxuICAgIGxldCByZXRyaWVzID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgb3AgPSBhd2FpdCB0aGlzLmdldChvcC5uYW1lKTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5tYXgoXG4gICAgICAgIG1pblNsZWVwLFxuICAgICAgICBNYXRoLm1pbihtYXhTbGVlcCwgMiAqKiByZXRyaWVzICogaW5jcmVhc2VGYWN0b3IpXG4gICAgICApO1xuICAgICAgcmV0cmllcysrO1xuICAgICAgaWYgKG9wLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBLZXlFdmVudHMgPSBjbGFzcyB7XG4gIGNsaWVudDtcbiAgLyoqXG4gICAqIEtleUV2ZW50c1xuICAgKiBAcGFyYW0ge1NpZ25pZnlDbGllbnR9IGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIGtleSBldmVudHMgZm9yIGFuIGlkZW50aWZpZXJcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmUgSWRlbnRpZmllciBwcmVmaXhcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBrZXkgZXZlbnRzXG4gICAqL1xuICBhc3luYyBnZXQocHJlKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvZXZlbnRzP3ByZT0ke3ByZX1gO1xuICAgIGNvbnN0IGRhdGEgPSBudWxsO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxufTtcbnZhciBLZXlTdGF0ZXMgPSBjbGFzcyB7XG4gIGNsaWVudDtcbiAgLyoqXG4gICAqIEtleVN0YXRlc1xuICAgKiBAcGFyYW0ge1NpZ25pZnlDbGllbnR9IGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZW5lIHRoZSBrZXkgc3RhdGUgZm9yIGFuIGlkZW50aWZpZXJcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmUgSWRlbnRpZmllciBwcmVmaXhcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBrZXkgc3RhdGVzXG4gICAqL1xuICBhc3luYyBnZXQocHJlKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvc3RhdGVzP3ByZT0ke3ByZX1gO1xuICAgIGNvbnN0IGRhdGEgPSBudWxsO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGtleSBzdGF0ZSBmb3IgYSBsaXN0IG9mIGlkZW50aWZpZXJzXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByZXMgTGlzdCBvZiBpZGVudGlmaWVyIHByZWZpeGVzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUga2V5IHN0YXRlc1xuICAgKi9cbiAgYXN5bmMgbGlzdChwcmVzKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvc3RhdGVzPyR7cHJlcy5tYXAoKHByZSkgPT4gYHByZT0ke3ByZX1gKS5qb2luKFwiJlwiKX1gO1xuICAgIGNvbnN0IGRhdGEgPSBudWxsO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogUXVlcnkgdGhlIGtleSBzdGF0ZSBvZiBhbiBpZGVudGlmaWVyIGZvciBhIGdpdmVuIHNlcXVlbmNlIG51bWJlciBvciBhbmNob3JcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmUgSWRlbnRpZmllciBwcmVmaXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzbl0gT3B0aW9uYWwgc2VxdWVuY2UgbnVtYmVyXG4gICAqIEBwYXJhbSB7YW55fSBbYW5jaG9yXSBPcHRpb25hbCBhbmNob3JcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uXG4gICAqL1xuICBhc3luYyBxdWVyeShwcmUsIHNuLCBhbmNob3IpIHtcbiAgICBjb25zdCBwYXRoID0gYC9xdWVyaWVzYDtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgcHJlXG4gICAgfTtcbiAgICBpZiAoc24gIT09IHZvaWQgMCkge1xuICAgICAgZGF0YS5zbiA9IHNuO1xuICAgIH1cbiAgICBpZiAoYW5jaG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGRhdGEuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGRhdGEpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL3ZkcmluZy50c1xudmFyIHZkcjtcbigodmRyMikgPT4ge1xuICBmdW5jdGlvbiBpbmNlcHQyKHtcbiAgICBwcmUsXG4gICAgdG9hZCxcbiAgICBub25jZSA9IHJhbmRvbU5vbmNlKCksXG4gICAgYmFrcyA9IFtdLFxuICAgIGNuZmcgPSBbXSxcbiAgICB2ZXJzaW9uID0gVmVyc2lvbmFnZSxcbiAgICBraW5kID0gXCJKU09OXCIgLyogSlNPTiAqLyxcbiAgICBjb2RlID0gTXRyRGV4LkJsYWtlM18yNTZcbiAgfSkge1xuICAgIGNvbnN0IHZzID0gdmVyc2lmeShcIktFUklcIiAvKiBLRVJJICovLCB2ZXJzaW9uLCBraW5kLCAwKTtcbiAgICBjb25zdCBpc24gPSAwO1xuICAgIGNvbnN0IGlsayA9IElsa3MudmNwO1xuICAgIGlmIChjbmZnLmluY2x1ZGVzKFRyYWl0RGV4Lk5vQmFja2VycykgJiYgYmFrcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke2Jha3MubGVuZ3RofSBiYWNrZXJzIHNwZWNpZmllZCBmb3IgTkIgdmNwLCAwIGFsbG93ZWRgXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobmV3IFNldChiYWtzKS5zaXplIDwgYmFrcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYWtzICR7YmFrc30gaGFzIGR1cGxpY2F0ZXNgKTtcbiAgICB9XG4gICAgbGV0IF90b2FkO1xuICAgIGlmICh0b2FkID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChiYWtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBfdG9hZCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdG9hZCA9IGFtcGxlKGJha3MubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3RvYWQgPSArdG9hZDtcbiAgICB9XG4gICAgaWYgKGJha3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKF90b2FkIDwgMSB8fCBfdG9hZCA+IGJha3MubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b2FkICR7X3RvYWR9IGZvciBiYWtzIGluICR7YmFrc31gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF90b2FkICE9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvYWQgJHtfdG9hZH0gZm9yIG5vIGJha3NgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2VkID0ge1xuICAgICAgdjogdnMsXG4gICAgICB0OiBpbGssXG4gICAgICBkOiBcIlwiLFxuICAgICAgaTogXCJcIixcbiAgICAgIGlpOiBwcmUsXG4gICAgICBzOiBcIlwiICsgaXNuLFxuICAgICAgYzogY25mZyxcbiAgICAgIGJ0OiBfdG9hZC50b1N0cmluZygxNiksXG4gICAgICBiOiBiYWtzLFxuICAgICAgbjogbm9uY2VcbiAgICB9O1xuICAgIGNvbnN0IHByZWZpeGVyID0gbmV3IFByZWZpeGVyKHsgY29kZSB9LCBrZWQpO1xuICAgIGtlZC5pID0gcHJlZml4ZXIucWI2NDtcbiAgICBrZWQuZCA9IHByZWZpeGVyLnFiNjQ7XG4gICAgcmV0dXJuIG5ldyBTZXJkZXIoa2VkKTtcbiAgfVxuICB2ZHIyLmluY2VwdCA9IGluY2VwdDI7XG59KSh2ZHIgfHwgKHZkciA9IHt9KSk7XG5cbi8vIHNyYy9rZXJpL2FwcC9jcmVkZW50aWFsaW5nLnRzXG52YXIgQ3JlZGVudGlhbFR5cGVzID0gY2xhc3Mge1xuICBzdGF0aWMgaXNzdWVkID0gXCJpc3N1ZWRcIjtcbiAgc3RhdGljIHJlY2VpdmVkID0gXCJyZWNlaXZlZFwiO1xufTtcbnZhciBDcmVkZW50aWFscyA9IGNsYXNzIHtcbiAgY2xpZW50O1xuICAvKipcbiAgICogQ3JlZGVudGlhbHNcbiAgICogQHBhcmFtIHtTaWduaWZ5Q2xpZW50fSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IGNyZWRlbnRpYWxzXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge0NyZWRlbnRpYWxGaWx0ZXJ9IFtrYXJnc10gT3B0aW9uYWwgcGFyYW1ldGVycyB0byBmaWx0ZXIgdGhlIGNyZWRlbnRpYWxzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgbGlzdCBvZiBjcmVkZW50aWFsc1xuICAgKi9cbiAgYXN5bmMgbGlzdChrYXJncyA9IHt9KSB7XG4gICAgY29uc3QgcGF0aCA9IGAvY3JlZGVudGlhbHMvcXVlcnlgO1xuICAgIGNvbnN0IGZpbHRyID0ga2FyZ3MuZmlsdGVyID09PSB2b2lkIDAgPyB7fSA6IGthcmdzLmZpbHRlcjtcbiAgICBjb25zdCBzb3J0ID0ga2FyZ3Muc29ydCA9PT0gdm9pZCAwID8gW10gOiBrYXJncy5zb3J0O1xuICAgIGNvbnN0IGxpbWl0ID0ga2FyZ3MubGltaXQgPT09IHZvaWQgMCA/IDI1IDoga2FyZ3MubGltaXQ7XG4gICAgY29uc3Qgc2tpcCA9IGthcmdzLnNraXAgPT09IHZvaWQgMCA/IDAgOiBrYXJncy5za2lwO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBmaWx0ZXI6IGZpbHRyLFxuICAgICAgc29ydCxcbiAgICAgIHNraXAsXG4gICAgICBsaW1pdFxuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhLCB2b2lkIDApO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBjcmVkZW50aWFsXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc2FpZCAtIFNBSUQgb2YgdGhlIGNyZWRlbnRpYWxcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUNFU1I9ZmFsc2VdIC0gT3B0aW9uYWwgZmxhZyBleHBvcnQgdGhlIGNyZWRlbnRpYWwgaW4gQ0VTUiBmb3JtYXRcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBjcmVkZW50aWFsXG4gICAqL1xuICBhc3luYyBnZXQoc2FpZCwgaW5jbHVkZUNFU1IgPSBmYWxzZSkge1xuICAgIGNvbnN0IHBhdGggPSBgL2NyZWRlbnRpYWxzLyR7c2FpZH1gO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgaGVhZGVycyA9IGluY2x1ZGVDRVNSID8gbmV3IEhlYWRlcnMoeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbitjZXNyXCIgfSkgOiBuZXcgSGVhZGVycyh7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBudWxsLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaW5jbHVkZUNFU1IgPyBhd2FpdCByZXMudGV4dCgpIDogYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogSXNzdWUgYSBjcmVkZW50aWFsXG4gICAqL1xuICBhc3luYyBpc3N1ZShuYW1lLCBhcmdzKSB7XG4gICAgY29uc3QgaGFiID0gYXdhaXQgdGhpcy5jbGllbnQuaWRlbnRpZmllcnMoKS5nZXQobmFtZSk7XG4gICAgY29uc3QgZXN0T25seSA9IGhhYi5zdGF0ZS5jICE9PSB2b2lkIDAgJiYgaGFiLnN0YXRlLmMuaW5jbHVkZXMoXCJFT1wiKTtcbiAgICBpZiAoZXN0T25seSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXN0YWJsaXNobWVudCBvbmx5IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudC5tYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtYW5hZ2VyIG9uIGNsaWVudFwiKTtcbiAgICB9XG4gICAgY29uc3Qga2VlcGVyID0gdGhpcy5jbGllbnQubWFuYWdlci5nZXQoaGFiKTtcbiAgICBjb25zdCBbLCBzdWJqZWN0XSA9IFNhaWRlci5zYWlkaWZ5KHtcbiAgICAgIGQ6IFwiXCIsXG4gICAgICAuLi5hcmdzLmEsXG4gICAgICBkdDogYXJncy5hLmR0ID8/ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiWlwiLCBcIjAwMCswMDowMFwiKVxuICAgIH0pO1xuICAgIGNvbnN0IFssIGFjZGNdID0gU2FpZGVyLnNhaWRpZnkoe1xuICAgICAgdjogdmVyc2lmeShcIkFDRENcIiAvKiBBQ0RDICovLCB2b2lkIDAsIFwiSlNPTlwiIC8qIEpTT04gKi8sIDApLFxuICAgICAgZDogXCJcIixcbiAgICAgIHU6IGFyZ3MudSxcbiAgICAgIGk6IGFyZ3MuaSA/PyBoYWIucHJlZml4LFxuICAgICAgcmk6IGFyZ3MucmksXG4gICAgICBzOiBhcmdzLnMsXG4gICAgICBhOiBzdWJqZWN0LFxuICAgICAgZTogYXJncy5lLFxuICAgICAgcjogYXJncy5yXG4gICAgfSk7XG4gICAgY29uc3QgWywgaXNzXSA9IFNhaWRlci5zYWlkaWZ5KHtcbiAgICAgIHY6IHZlcnNpZnkoXCJLRVJJXCIgLyogS0VSSSAqLywgdm9pZCAwLCBcIkpTT05cIiAvKiBKU09OICovLCAwKSxcbiAgICAgIHQ6IElsa3MuaXNzLFxuICAgICAgZDogXCJcIixcbiAgICAgIGk6IGFjZGMuZCxcbiAgICAgIHM6IFwiMFwiLFxuICAgICAgcmk6IGFyZ3MucmksXG4gICAgICBkdDogc3ViamVjdC5kdFxuICAgIH0pO1xuICAgIGNvbnN0IHNuID0gcGFyc2VJbnQoaGFiLnN0YXRlLnMsIDE2KTtcbiAgICBjb25zdCBhbmMgPSBpbnRlcmFjdCh7XG4gICAgICBwcmU6IGhhYi5wcmVmaXgsXG4gICAgICBzbjogc24gKyAxLFxuICAgICAgZGF0YTogW1xuICAgICAgICB7XG4gICAgICAgICAgaTogaXNzLmksXG4gICAgICAgICAgczogaXNzLnMsXG4gICAgICAgICAgZDogaXNzLmRcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGRpZzogaGFiLnN0YXRlLmQsXG4gICAgICB2ZXJzaW9uOiB2b2lkIDAsXG4gICAgICBraW5kOiB2b2lkIDBcbiAgICB9KTtcbiAgICBjb25zdCBzaWdzID0gYXdhaXQga2VlcGVyLnNpZ24oYihhbmMucmF3KSk7XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnMvJHtoYWIubmFtZX0vY3JlZGVudGlhbHNgO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBhY2RjLFxuICAgICAgaXNzLFxuICAgICAgaXhuOiBhbmMua2VkLFxuICAgICAgc2lncyxcbiAgICAgIFtrZWVwZXIuYWxnb106IGtlZXBlci5wYXJhbXMoKVxuICAgIH07XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uK2Nlc3JcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycyk7XG4gICAgY29uc3Qgb3AgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2RjOiBuZXcgU2VyZGVyKGFjZGMpLFxuICAgICAgaXNzOiBuZXcgU2VyZGVyKGlzcyksXG4gICAgICBhbmMsXG4gICAgICBvcFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldm9rZSBjcmVkZW50aWFsXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzYWlkIFNBSUQgb2YgdGhlIGNyZWRlbnRpYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGV0aW1lIGRhdGUgdGltZSBvZiByZXZvY2F0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgbG9uZy1ydW5uaW5nIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgcmV2b2tlKG5hbWUsIHNhaWQsIGRhdGV0aW1lKSB7XG4gICAgY29uc3QgaGFiID0gYXdhaXQgdGhpcy5jbGllbnQuaWRlbnRpZmllcnMoKS5nZXQobmFtZSk7XG4gICAgY29uc3QgcHJlID0gaGFiLnByZWZpeDtcbiAgICBjb25zdCB2cyA9IHZlcnNpZnkoXCJLRVJJXCIgLyogS0VSSSAqLywgdm9pZCAwLCBcIkpTT05cIiAvKiBKU09OICovLCAwKTtcbiAgICBjb25zdCBkdCA9IGRhdGV0aW1lID8/ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiWlwiLCBcIjAwMCswMDowMFwiKTtcbiAgICBjb25zdCBjcmVkID0gYXdhaXQgdGhpcy5nZXQoc2FpZCk7XG4gICAgY29uc3QgX3JldiA9IHtcbiAgICAgIHY6IHZzLFxuICAgICAgdDogSWxrcy5yZXYsXG4gICAgICBkOiBcIlwiLFxuICAgICAgaTogc2FpZCxcbiAgICAgIHM6IFwiMVwiLFxuICAgICAgcmk6IGNyZWQuc2FkLnJpLFxuICAgICAgcDogY3JlZC5zdGF0dXMuZCxcbiAgICAgIGR0XG4gICAgfTtcbiAgICBjb25zdCBbLCByZXZdID0gU2FpZGVyLnNhaWRpZnkoX3Jldik7XG4gICAgbGV0IGl4biA9IHt9O1xuICAgIGxldCBzaWdzID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSBoYWIuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmMgIT09IHZvaWQgMCAmJiBzdGF0ZS5jLmluY2x1ZGVzKFwiRU9cIikpIHtcbiAgICAgIHZhciBlc3RPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzdE9ubHkgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc24gPSBwYXJzZUludChzdGF0ZS5zLCAxNik7XG4gICAgY29uc3QgZGlnID0gc3RhdGUuZDtcbiAgICBjb25zdCBkYXRhID0gW1xuICAgICAge1xuICAgICAgICBpOiByZXYuaSxcbiAgICAgICAgczogcmV2LnMsXG4gICAgICAgIGQ6IHJldi5kXG4gICAgICB9XG4gICAgXTtcbiAgICBjb25zdCBrZWVwZXIgPSB0aGlzLmNsaWVudC5tYW5hZ2VyLmdldChoYWIpO1xuICAgIGlmIChlc3RPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc3RhYmxpc2htZW50IG9ubHkgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZXJkZXIgPSBpbnRlcmFjdCh7XG4gICAgICAgIHByZSxcbiAgICAgICAgc246IHNuICsgMSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZGlnLFxuICAgICAgICB2ZXJzaW9uOiB2b2lkIDAsXG4gICAgICAgIGtpbmQ6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBzaWdzID0gYXdhaXQga2VlcGVyLnNpZ24oYihzZXJkZXIucmF3KSk7XG4gICAgICBpeG4gPSBzZXJkZXIua2VkO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgcmV2LFxuICAgICAgaXhuLFxuICAgICAgc2lncyxcbiAgICAgIFtrZWVwZXIuYWxnb106IGtlZXBlci5wYXJhbXMoKVxuICAgIH07XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnMvJHtuYW1lfS9jcmVkZW50aWFscy8ke3NhaWR9YDtcbiAgICBjb25zdCBtZXRob2QgPSBcIkRFTEVURVwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbitjZXNyXCJcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMpO1xuICAgIGNvbnN0IG9wID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmV2OiBuZXcgU2VyZGVyKHJldiksXG4gICAgICBhbmM6IG5ldyBTZXJkZXIoaXhuKSxcbiAgICAgIG9wXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUHJlc2VudCBhIGNyZWRlbnRpYWxcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb3IgYWxpYXMgb2YgdGhlIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNhaWQgU0FJRCBvZiB0aGUgY3JlZGVudGlhbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjaXBpZW50IElkZW50aWZpZXIgcHJlZml4IG9mIHRoZSByZWNlaXZlciBvZiB0aGUgcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGU9dHJ1ZV0gRmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRvIHN0cmVhbSBjcmVkZW50aWFsIGFsb25nc2lkZSBwcmVzZW50YXRpb24gZXhjaGFuZ2UgbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgdG8gdGhlIGxvbmctcnVubmluZyBvcGVyYXRpb25cbiAgICovXG4gIGFzeW5jIHByZXNlbnQobmFtZSwgc2FpZCwgcmVjaXBpZW50LCBpbmNsdWRlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGhhYiA9IGF3YWl0IHRoaXMuY2xpZW50LmlkZW50aWZpZXJzKCkuZ2V0KG5hbWUpO1xuICAgIGNvbnN0IHByZSA9IGhhYi5wcmVmaXg7XG4gICAgY29uc3QgY3JlZCA9IGF3YWl0IHRoaXMuZ2V0KHNhaWQpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBpOiBjcmVkLnNhZC5pLFxuICAgICAgczogY3JlZC5zYWQucyxcbiAgICAgIG46IHNhaWRcbiAgICB9O1xuICAgIGNvbnN0IHZzID0gdmVyc2lmeShcIktFUklcIiAvKiBLRVJJICovLCB2b2lkIDAsIFwiSlNPTlwiIC8qIEpTT04gKi8sIDApO1xuICAgIGNvbnN0IF9zYWQgPSB7XG4gICAgICB2OiB2cyxcbiAgICAgIHQ6IElsa3MuZXhuLFxuICAgICAgZDogXCJcIixcbiAgICAgIGR0OiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIlpcIiwgXCIwMDArMDA6MDBcIiksXG4gICAgICByOiBcIi9wcmVzZW50YXRpb25cIixcbiAgICAgIHE6IHt9LFxuICAgICAgYTogZGF0YVxuICAgIH07XG4gICAgY29uc3QgWywgc2FkXSA9IFNhaWRlci5zYWlkaWZ5KF9zYWQpO1xuICAgIGNvbnN0IGV4biA9IG5ldyBTZXJkZXIoc2FkKTtcbiAgICBjb25zdCBrZWVwZXIgPSB0aGlzLmNsaWVudC5tYW5hZ2VyLmdldChoYWIpO1xuICAgIGNvbnN0IHNpZyA9IGF3YWl0IGtlZXBlci5zaWduKGIoZXhuLnJhdyksIHRydWUpO1xuICAgIGNvbnN0IHNpZ2VyID0gbmV3IFNpZ2VyKHsgcWI2NDogc2lnWzBdIH0pO1xuICAgIGNvbnN0IHNlYWwgPSBbXCJTZWFsTGFzdFwiLCB7IGk6IHByZSB9XTtcbiAgICBsZXQgaW1zID0gbWVzc2FnaXplKGV4biwgW3NpZ2VyXSwgc2VhbCwgdm9pZCAwLCB2b2lkIDAsIHRydWUpO1xuICAgIGltcyA9IGltcy5zbGljZShKU09OLnN0cmluZ2lmeShleG4ua2VkKS5sZW5ndGgpO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBleG46IGV4bi5rZWQsXG4gICAgICBzaWc6IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpbXMpLFxuICAgICAgcmVjaXBpZW50LFxuICAgICAgaW5jbHVkZVxuICAgIH07XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnMvJHtuYW1lfS9jcmVkZW50aWFscy8ke3NhaWR9L3ByZXNlbnRhdGlvbnNgO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbitjZXNyXCJcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMpO1xuICAgIHJldHVybiBhd2FpdCByZXMudGV4dCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0IGEgcHJlc2VudGF0aW9uIG9mIGEgY3JlZGVudGlhbFxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvciBhbGlhcyBvZiB0aGUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjaXBpZW50IElkZW50aWZpZXIgcHJlZml4IG9mIHRoZSByZWNlaXZlciBvZiB0aGUgcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWEgU0FJRCBvZiB0aGUgc2NoZW1hXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaXNzdWVyXSBPcHRpb25hbCBwcmVmaXggb2YgdGhlIGlzc3VlciBvZiB0aGUgY3JlZGVudGlhbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgdG8gdGhlIGxvbmctcnVubmluZyBvcGVyYXRpb25cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QobmFtZSwgcmVjaXBpZW50LCBzY2hlbWEsIGlzc3Vlcikge1xuICAgIGNvbnN0IGhhYiA9IGF3YWl0IHRoaXMuY2xpZW50LmlkZW50aWZpZXJzKCkuZ2V0KG5hbWUpO1xuICAgIGNvbnN0IHByZSA9IGhhYi5wcmVmaXg7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHM6IHNjaGVtYVxuICAgIH07XG4gICAgaWYgKGlzc3VlciAhPT0gdm9pZCAwKSB7XG4gICAgICBkYXRhW1wiaVwiXSA9IGlzc3VlcjtcbiAgICB9XG4gICAgY29uc3QgdnMgPSB2ZXJzaWZ5KFwiS0VSSVwiIC8qIEtFUkkgKi8sIHZvaWQgMCwgXCJKU09OXCIgLyogSlNPTiAqLywgMCk7XG4gICAgY29uc3QgX3NhZCA9IHtcbiAgICAgIHY6IHZzLFxuICAgICAgdDogSWxrcy5leG4sXG4gICAgICBkOiBcIlwiLFxuICAgICAgZHQ6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiWlwiLCBcIjAwMCswMDowMFwiKSxcbiAgICAgIHI6IFwiL3ByZXNlbnRhdGlvbi9yZXF1ZXN0XCIsXG4gICAgICBxOiB7fSxcbiAgICAgIGE6IGRhdGFcbiAgICB9O1xuICAgIGNvbnN0IFssIHNhZF0gPSBTYWlkZXIuc2FpZGlmeShfc2FkKTtcbiAgICBjb25zdCBleG4gPSBuZXcgU2VyZGVyKHNhZCk7XG4gICAgY29uc3Qga2VlcGVyID0gdGhpcy5jbGllbnQubWFuYWdlci5nZXQoaGFiKTtcbiAgICBjb25zdCBzaWcgPSBhd2FpdCBrZWVwZXIuc2lnbihiKGV4bi5yYXcpLCB0cnVlKTtcbiAgICBjb25zdCBzaWdlciA9IG5ldyBTaWdlcih7IHFiNjQ6IHNpZ1swXSB9KTtcbiAgICBjb25zdCBzZWFsID0gW1wiU2VhbExhc3RcIiwgeyBpOiBwcmUgfV07XG4gICAgbGV0IGltcyA9IG1lc3NhZ2l6ZShleG4sIFtzaWdlcl0sIHNlYWwsIHZvaWQgMCwgdm9pZCAwLCB0cnVlKTtcbiAgICBpbXMgPSBpbXMuc2xpY2UoSlNPTi5zdHJpbmdpZnkoZXhuLmtlZCkubGVuZ3RoKTtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgZXhuOiBleG4ua2VkLFxuICAgICAgc2lnOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaW1zKSxcbiAgICAgIHJlY2lwaWVudFxuICAgIH07XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnMvJHtuYW1lfS9yZXF1ZXN0c2A7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uK2Nlc3JcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycyk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH1cbn07XG52YXIgUmVnaXN0cnlSZXN1bHQgPSBjbGFzcyB7XG4gIF9yZWdzZXI7XG4gIF9zZXJkZXI7XG4gIF9zaWdzO1xuICBwcm9taXNlO1xuICBjb25zdHJ1Y3RvcihyZWdzZXIsIHNlcmRlciwgc2lncywgcHJvbWlzZSkge1xuICAgIHRoaXMuX3JlZ3NlciA9IHJlZ3NlcjtcbiAgICB0aGlzLl9zZXJkZXIgPSBzZXJkZXI7XG4gICAgdGhpcy5fc2lncyA9IHNpZ3M7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgfVxuICBnZXQgcmVnc2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdzZXI7XG4gIH1cbiAgZ2V0IHNlcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VyZGVyO1xuICB9XG4gIGdldCBzaWdzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWdzO1xuICB9XG4gIGFzeW5jIG9wKCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucHJvbWlzZTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxufTtcbnZhciBSZWdpc3RyaWVzID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBSZWdpc3RyaWVzXG4gICAqIEBwYXJhbSB7U2lnbmlmeUNsaWVudH0gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogTGlzdCByZWdpc3RyaWVzXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgbGlzdCBvZiByZWdpc3RyaWVzXG4gICAqL1xuICBhc3luYyBsaXN0KG5hbWUpIHtcbiAgICBjb25zdCBwYXRoID0gYC9pZGVudGlmaWVycy8ke25hbWV9L3JlZ2lzdHJpZXNgO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBudWxsKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVnaXN0cnlcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7Q3JlYXRlUmVnaXN0cnlBcmdzfVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxbYW55LCBTZXJkZXIsIGFueVtdLCBvYmplY3RdPiB9IEEgcHJvbWlzZSB0byB0aGUgbG9uZy1ydW5uaW5nIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKHtcbiAgICBuYW1lLFxuICAgIHJlZ2lzdHJ5TmFtZSxcbiAgICBub0JhY2tlcnMgPSB0cnVlLFxuICAgIHRvYWQgPSAwLFxuICAgIGJha3MgPSBbXSxcbiAgICBub25jZVxuICB9KSB7XG4gICAgY29uc3QgaGFiID0gYXdhaXQgdGhpcy5jbGllbnQuaWRlbnRpZmllcnMoKS5nZXQobmFtZSk7XG4gICAgY29uc3QgcHJlID0gaGFiLnByZWZpeDtcbiAgICBjb25zdCBjbmZnID0gW107XG4gICAgaWYgKG5vQmFja2Vycykge1xuICAgICAgY25mZy5wdXNoKFRyYWl0RGV4Lk5vQmFja2Vycyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gaGFiLnN0YXRlO1xuICAgIGNvbnN0IGVzdE9ubHkgPSBzdGF0ZS5jICE9PSB2b2lkIDAgJiYgc3RhdGUuYy5pbmNsdWRlcyhcIkVPXCIpO1xuICAgIGlmIChlc3RPbmx5KSB7XG4gICAgICBjbmZnLnB1c2goVHJhaXREZXguRXN0T25seSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ3NlciA9IHZkci5pbmNlcHQoeyBwcmUsIGJha3MsIHRvYWQsIG5vbmNlLCBjbmZnIH0pO1xuICAgIGlmIChlc3RPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlc3RhYmxpc2htZW50IG9ubHkgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZTIgPSBoYWIuc3RhdGU7XG4gICAgICBjb25zdCBzbiA9IHBhcnNlSW50KHN0YXRlMi5zLCAxNik7XG4gICAgICBjb25zdCBkaWcgPSBzdGF0ZTIuZDtcbiAgICAgIGNvbnN0IGRhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpOiByZWdzZXIucHJlLFxuICAgICAgICAgIHM6IFwiMFwiLFxuICAgICAgICAgIGQ6IHJlZ3Nlci5wcmVcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIGNvbnN0IHNlcmRlciA9IGludGVyYWN0KHtcbiAgICAgICAgcHJlLFxuICAgICAgICBzbjogc24gKyAxLFxuICAgICAgICBkYXRhLFxuICAgICAgICBkaWcsXG4gICAgICAgIHZlcnNpb246IFZlcnNpb25hZ2UsXG4gICAgICAgIGtpbmQ6IFwiSlNPTlwiIC8qIEpTT04gKi9cbiAgICAgIH0pO1xuICAgICAgY29uc3Qga2VlcGVyID0gdGhpcy5jbGllbnQubWFuYWdlci5nZXQoaGFiKTtcbiAgICAgIGNvbnN0IHNpZ3MgPSBhd2FpdCBrZWVwZXIuc2lnbihiKHNlcmRlci5yYXcpKTtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMuY3JlYXRlRnJvbUV2ZW50cyhcbiAgICAgICAgaGFiLFxuICAgICAgICBuYW1lLFxuICAgICAgICByZWdpc3RyeU5hbWUsXG4gICAgICAgIHJlZ3Nlci5rZWQsXG4gICAgICAgIHNlcmRlci5rZWQsXG4gICAgICAgIHNpZ3NcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IFJlZ2lzdHJ5UmVzdWx0KHJlZ3Nlciwgc2VyZGVyLCBzaWdzLCByZXMpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVGcm9tRXZlbnRzKGhhYiwgbmFtZSwgcmVnaXN0cnlOYW1lLCB2Y3AsIGl4biwgc2lncykge1xuICAgIGNvbnN0IHBhdGggPSBgL2lkZW50aWZpZXJzLyR7bmFtZX0vcmVnaXN0cmllc2A7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG5hbWU6IHJlZ2lzdHJ5TmFtZSxcbiAgICAgIHZjcCxcbiAgICAgIGl4bixcbiAgICAgIHNpZ3NcbiAgICB9O1xuICAgIGNvbnN0IGtlZXBlciA9IHRoaXMuY2xpZW50Lm1hbmFnZXIuZ2V0KGhhYik7XG4gICAgZGF0YVtrZWVwZXIuYWxnb10gPSBrZWVwZXIucGFyYW1zKCk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmFtZSBhIHJlZ2lzdHJ5XG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9yIGFsaWFzIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyeU5hbWUgQ3VycmVudCByZWdpc3RyeSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lIE5ldyByZWdpc3RyeSBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgcmVnaXN0cnkgcmVjb3JkXG4gICAqL1xuICBhc3luYyByZW5hbWUobmFtZSwgcmVnaXN0cnlOYW1lLCBuZXdOYW1lKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvaWRlbnRpZmllcnMvJHtuYW1lfS9yZWdpc3RyaWVzLyR7cmVnaXN0cnlOYW1lfWA7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQVVRcIjtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbmFtZTogbmV3TmFtZVxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBkYXRhKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxufTtcbnZhciBTY2hlbWFzID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBTY2hlbWFzXG4gICAqIEBwYXJhbSB7U2lnbmlmeUNsaWVudH0gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgc2NoZW1hXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc2FpZCBTQUlEIG9mIHRoZSBzY2hlbWFcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBzY2hlbWFcbiAgICovXG4gIGFzeW5jIGdldChzYWlkKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvc2NoZW1hLyR7c2FpZH1gO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBudWxsKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBzY2hlbWFzXG4gICAqIEBhc3luY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIGxpc3Qgb2Ygc2NoZW1hc1xuICAgKi9cbiAgYXN5bmMgbGlzdCgpIHtcbiAgICBjb25zdCBwYXRoID0gYC9zY2hlbWFgO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBudWxsKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxufTtcbnZhciBJcGV4ID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBTY2hlbWFzXG4gICAqIEBwYXJhbSB7U2lnbmlmeUNsaWVudH0gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIElQRVggZ3JhbnQgRVhOIG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIGdyYW50KGFyZ3MpIHtcbiAgICBjb25zdCBoYWIgPSBhd2FpdCB0aGlzLmNsaWVudC5pZGVudGlmaWVycygpLmdldChhcmdzLnNlbmRlck5hbWUpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBtOiBhcmdzLm1lc3NhZ2UgPz8gXCJcIixcbiAgICAgIGk6IGFyZ3MucmVjaXBpZW50XG4gICAgfTtcbiAgICBsZXQgYXRjID0gYXJncy5hbmNBdHRhY2htZW50O1xuICAgIGlmIChhdGMgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2VlcGVyID0gdGhpcy5jbGllbnQubWFuYWdlci5nZXQoaGFiKTtcbiAgICAgIGNvbnN0IHNpZ3MgPSBhd2FpdCBrZWVwZXIuc2lnbihiKGFyZ3MuYW5jLnJhdykpO1xuICAgICAgY29uc3Qgc2lnZXJzID0gc2lncy5tYXAoKHNpZykgPT4gbmV3IFNpZ2VyKHsgcWI2NDogc2lnIH0pKTtcbiAgICAgIGNvbnN0IGltcyA9IGQobWVzc2FnaXplKGFyZ3MuYW5jLCBzaWdlcnMpKTtcbiAgICAgIGF0YyA9IGltcy5zdWJzdHJpbmcoYXJncy5hbmMuc2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGFjZGNBdGMgPSBhcmdzLmFjZGNBdHRhY2htZW50ID09PSB2b2lkIDAgPyBkKHNlcmlhbGl6ZUFDRENBdHRhY2htZW50KGFyZ3MuaXNzKSkgOiBhcmdzLmFjZGNBdHRhY2htZW50O1xuICAgIGNvbnN0IGlzc0F0YyA9IGFyZ3MuaXNzQXR0YWNobWVudCA9PT0gdm9pZCAwID8gZChzZXJpYWxpemVJc3NFeG5BdHRhY2htZW50KGFyZ3MuYW5jKSkgOiBhcmdzLmlzc0F0dGFjaG1lbnQ7XG4gICAgY29uc3QgZW1iZWRzID0ge1xuICAgICAgYWNkYzogW2FyZ3MuYWNkYywgYWNkY0F0Y10sXG4gICAgICBpc3M6IFthcmdzLmlzcywgaXNzQXRjXSxcbiAgICAgIGFuYzogW2FyZ3MuYW5jLCBhdGNdXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhjaGFuZ2VzKCkuY3JlYXRlRXhjaGFuZ2VNZXNzYWdlKFxuICAgICAgaGFiLFxuICAgICAgXCIvaXBleC9ncmFudFwiLFxuICAgICAgZGF0YSxcbiAgICAgIGVtYmVkcyxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGFyZ3MuZGF0ZXRpbWUsXG4gICAgICBhcmdzLmFncmVlXG4gICAgKTtcbiAgfVxuICBhc3luYyBzdWJtaXRHcmFudChuYW1lLCBleG4sIHNpZ3MsIGF0YywgcmVjcCkge1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBleG46IGV4bi5rZWQsXG4gICAgICBzaWdzLFxuICAgICAgYXRjLFxuICAgICAgcmVjOiByZWNwXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKFxuICAgICAgYC9pZGVudGlmaWVycy8ke25hbWV9L2lwZXgvZ3JhbnRgLFxuICAgICAgXCJQT1NUXCIsXG4gICAgICBib2R5XG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSVBFWCBhZG1pdCBFWE4gbWVzc2FnZVxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvciBhbGlhcyBvZiB0aGUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBhY2NvbXBhbnkgaHVtYW4gcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGNyZWRlbnRpYWwgYmVpbmcgYWRtaXR0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGdyYW50IHFiNjQgU0FJRCBvZiBncmFudCBtZXNzYWdlIHRoaXMgYWRtaXQgaXMgcmVzcG9uZGluZyB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZXRpbWUgT3B0aW9uYWwgZGF0ZXRpbWUgdG8gc2V0IGZvciB0aGUgY3JlZGVudGlhbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxbU2VyZGVyLCBzdHJpbmdbXSwgc3RyaW5nXT59IEEgcHJvbWlzZSB0byB0aGUgbG9uZy1ydW5uaW5nIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgYWRtaXQobmFtZSwgbWVzc2FnZSwgZ3JhbnQsIGRhdGV0aW1lKSB7XG4gICAgY29uc3QgaGFiID0gYXdhaXQgdGhpcy5jbGllbnQuaWRlbnRpZmllcnMoKS5nZXQobmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG06IG1lc3NhZ2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGNoYW5nZXMoKS5jcmVhdGVFeGNoYW5nZU1lc3NhZ2UoXG4gICAgICBoYWIsXG4gICAgICBcIi9pcGV4L2FkbWl0XCIsXG4gICAgICBkYXRhLFxuICAgICAge30sXG4gICAgICB2b2lkIDAsXG4gICAgICBkYXRldGltZSxcbiAgICAgIGdyYW50XG4gICAgKTtcbiAgfVxuICBhc3luYyBzdWJtaXRBZG1pdChuYW1lLCBleG4sIHNpZ3MsIGF0YywgcmVjcCkge1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBleG46IGV4bi5rZWQsXG4gICAgICBzaWdzLFxuICAgICAgYXRjLFxuICAgICAgcmVjOiByZWNwXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKFxuICAgICAgYC9pZGVudGlmaWVycy8ke25hbWV9L2lwZXgvYWRtaXRgLFxuICAgICAgXCJQT1NUXCIsXG4gICAgICBib2R5XG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9hcHAvZXNjcm93aW5nLnRzXG52YXIgRXNjcm93cyA9IGNsYXNzIHtcbiAgY2xpZW50O1xuICAvKipcbiAgICogRXNjcm93c1xuICAgKiBAcGFyYW0ge1NpZ25pZnlDbGllbnR9IGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIExpc3QgcmVwbGF5IG1lc3NhZ2VzXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JvdXRlXSBPcHRpb25hbCByb3V0ZSBpbiB0aGUgcmVwbGF5IG1lc3NhZ2VcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsaXN0IG9mIHJlcGxheSBtZXNzYWdlc1xuICAgKi9cbiAgYXN5bmMgbGlzdFJlcGx5KHJvdXRlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChyb3V0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKFwicm91dGVcIiwgcm91dGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gYC9lc2Nyb3dzL3JweT9gICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbWV0aG9kID0gXCJHRVRcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIG51bGwpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG59O1xuXG4vLyBzcmMva2VyaS9jb3JlL2JleHRlci50c1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlcjEwIH0gZnJvbSBcImJ1ZmZlclwiO1xudmFyIEI2NFJFWCA9IFwiXltBLVphLXowLTlcXFxcLV9dKiRcIjtcbnZhciBSZWI2NCA9IG5ldyBSZWdFeHAoQjY0UkVYKTtcbnZhciBCZXh0ZXIgPSBjbGFzcyBfQmV4dGVyIGV4dGVuZHMgTWF0dGVyIHtcbiAgY29uc3RydWN0b3IoeyByYXcsIGNvZGUgPSBNdHJEZXguU3RyQjY0X0wwLCBxYjY0YiwgcWI2NCwgcWIyIH0sIGJleHQpIHtcbiAgICBpZiAocmF3ID09PSB2b2lkIDAgJiYgcWI2NGIgPT09IHZvaWQgMCAmJiBxYjY0ID09PSB2b2lkIDAgJiYgcWIyID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChiZXh0ID09PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBFbXB0eU1hdGVyaWFsRXJyb3IoXCJNaXNzaW5nIGJleHQgc3RyaW5nLlwiKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gUmViNjQuZXhlYyhiZXh0KTtcbiAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQmFzZTY0LlwiKTtcbiAgICAgIHJhdyA9IF9CZXh0ZXIuX3Jhd2lmeShiZXh0KTtcbiAgICB9XG4gICAgc3VwZXIoeyByYXcsIGNvZGUsIHFiNjRiLCBxYjY0LCBxYjIgfSk7XG4gICAgaWYgKCFCZXhEZXguaGFzKHRoaXMuY29kZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29kZSA9ICR7dGhpcy5jb2RlfSBmb3IgQmV4dGVyLmApO1xuICB9XG4gIHN0YXRpYyBfcmF3aWZ5KGJleHQpIHtcbiAgICBjb25zdCB0cyA9IGJleHQubGVuZ3RoICUgNDtcbiAgICBjb25zdCB3cyA9ICg0IC0gdHMpICUgNDtcbiAgICBjb25zdCBscyA9ICgzIC0gdHMpICUgMztcbiAgICBjb25zdCB3YWQgPSBuZXcgQXJyYXkod3MpO1xuICAgIHdhZC5maWxsKFwiQVwiKTtcbiAgICBjb25zdCBiYXNlID0gd2FkLmpvaW4oXCJcIikgKyBiZXh0O1xuICAgIGNvbnN0IHJhdyA9IGRlY29kZUJhc2U2NFVybChiYXNlKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJhdykuc3ViYXJyYXkobHMpO1xuICB9XG4gIGdldCBiZXh0KCkge1xuICAgIGNvbnN0IHNpemFnZSA9IE1hdHRlci5TaXplcy5nZXQodGhpcy5jb2RlKTtcbiAgICBjb25zdCB3YWQgPSBVaW50OEFycmF5LmZyb20obmV3IEFycmF5KHNpemFnZT8ubHMpLmZpbGwoMCkpO1xuICAgIGNvbnN0IGJleHQgPSBlbmNvZGVCYXNlNjRVcmwoQnVmZmVyMTAuZnJvbShbLi4ud2FkLCAuLi50aGlzLnJhd10pKTtcbiAgICBsZXQgd3MgPSAwO1xuICAgIGlmIChzaXphZ2U/LmxzID09PSAwICYmIGJleHQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGJleHRbMF0gPT09IFwiQVwiKSB7XG4gICAgICAgIHdzID0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd3MgPSAoc2l6YWdlPy5scyArIDEpICUgNDtcbiAgICB9XG4gICAgcmV0dXJuIGJleHQuc3Vic3RyaW5nKHdzKTtcbiAgfVxufTtcblxuLy8gc3JjL2tlcmkvY29yZS9wYXRoZXIudHNcbnZhciBQYXRoZXIgPSBjbGFzcyBfUGF0aGVyIGV4dGVuZHMgQmV4dGVyIHtcbiAgY29uc3RydWN0b3IoeyByYXcsIGNvZGUgPSBNdHJEZXguU3RyQjY0X0wwLCBxYjY0YiwgcWI2NCwgcWIyIH0sIGJleHQsIHBhdGgpIHtcbiAgICBpZiAocmF3ID09PSB2b2lkIDAgJiYgYmV4dCA9PT0gdm9pZCAwICYmIHFiNjRiID09PSB2b2lkIDAgJiYgcWI2NCA9PT0gdm9pZCAwICYmIHFiMiA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRW1wdHlNYXRlcmlhbEVycm9yKFwiTWlzc2luZyBiZXh0IHN0cmluZy5cIik7XG4gICAgICBiZXh0ID0gX1BhdGhlci5fYmV4dGlmeShwYXRoKTtcbiAgICB9XG4gICAgc3VwZXIoeyByYXcsIGNvZGUsIHFiNjRiLCBxYjY0LCBxYjIgfSwgYmV4dCk7XG4gIH1cbiAgLy8gVE9ETzogaW1wbGVtZW50IFNBRCBhY2Nlc3MgbWV0aG9kcyBsaWtlIHJlc29sdmUsIHJvb3QsIHN0cmlwLCBzdGFydHN3aXRoIGFuZCB0YWlsXG4gIGdldCBwYXRoKCkge1xuICAgIGlmICghdGhpcy5iZXh0LnN0YXJ0c1dpdGgoXCItXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFNBRCBwdHJcIik7XG4gICAgfVxuICAgIGxldCBwYXRoID0gdGhpcy5iZXh0O1xuICAgIHdoaWxlIChwYXRoLmNoYXJBdCgwKSA9PT0gXCItXCIpIHtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgY29uc3QgYXBhdGggPSBwYXRoLnNwbGl0KFwiLVwiKTtcbiAgICBpZiAoYXBhdGhbMF0gIT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBhcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2JleHRpZnkocGF0aCkge1xuICAgIGNvbnN0IHZhdGggPSBbXTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0aCkge1xuICAgICAgbGV0IHNwID0gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcCA9IHAudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwID0gcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoID0gUmViNjQuZXhlYyhzcCk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJOb24gQmFzZTY0IHBhdGggY29tcG9uZW50ID0gJHtwfS5gKTtcbiAgICAgIH1cbiAgICAgIHZhdGgucHVzaChzcCk7XG4gICAgfVxuICAgIHJldHVybiBcIi1cIiArIHZhdGguam9pbihcIi1cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2FwcC9leGNoYW5naW5nLnRzXG52YXIgRXhjaGFuZ2VzID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBFeGNoYW5nZXNcbiAgICogQHBhcmFtIHtTaWduaWZ5Q2xpZW50fSBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgZXhuIG1lc3NhZ2VcbiAgICogQGFzeW5jXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgbGlzdCBvZiByZXBsYXkgbWVzc2FnZXNcbiAgICogQHBhcmFtIHNlbmRlclxuICAgKiBAcGFyYW0gcm91dGVcbiAgICogQHBhcmFtIHBheWxvYWRcbiAgICogQHBhcmFtIGVtYmVkc1xuICAgKiBAcGFyYW0gcmVjaXBpZW50XG4gICAqIEBwYXJhbSBkYXRldGltZVxuICAgKiBAcGFyYW0gZGlnXG4gICAqL1xuICBhc3luYyBjcmVhdGVFeGNoYW5nZU1lc3NhZ2Uoc2VuZGVyLCByb3V0ZSwgcGF5bG9hZCwgZW1iZWRzLCByZWNpcGllbnQsIGRhdGV0aW1lLCBkaWcpIHtcbiAgICBjb25zdCBrZWVwZXIgPSB0aGlzLmNsaWVudC5tYW5hZ2VyLmdldChzZW5kZXIpO1xuICAgIGNvbnN0IFtleG4sIGVuZF0gPSBleGNoYW5nZShcbiAgICAgIHJvdXRlLFxuICAgICAgcGF5bG9hZCxcbiAgICAgIHNlbmRlcltcInByZWZpeFwiXSxcbiAgICAgIHJlY2lwaWVudCxcbiAgICAgIGRhdGV0aW1lLFxuICAgICAgZGlnLFxuICAgICAgdm9pZCAwLFxuICAgICAgZW1iZWRzXG4gICAgKTtcbiAgICBjb25zdCBzaWdzID0gYXdhaXQga2VlcGVyLnNpZ24oYihleG4ucmF3KSk7XG4gICAgcmV0dXJuIFtleG4sIHNpZ3MsIGQoZW5kKV07XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgZXhuIG1lc3NhZ2VzIHRvIGxpc3Qgb2YgcmVjaXBpZW50c1xuICAgKiBAYXN5bmNcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsaXN0IG9mIHJlcGxheSBtZXNzYWdlc1xuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gdG9waWNcbiAgICogQHBhcmFtIHNlbmRlclxuICAgKiBAcGFyYW0gcm91dGVcbiAgICogQHBhcmFtIHBheWxvYWRcbiAgICogQHBhcmFtIGVtYmVkc1xuICAgKiBAcGFyYW0gcmVjaXBpZW50c1xuICAgKi9cbiAgYXN5bmMgc2VuZChuYW1lLCB0b3BpYywgc2VuZGVyLCByb3V0ZSwgcGF5bG9hZCwgZW1iZWRzLCByZWNpcGllbnRzKSB7XG4gICAgY29uc3QgW2V4biwgc2lncywgYXRjXSA9IGF3YWl0IHRoaXMuY3JlYXRlRXhjaGFuZ2VNZXNzYWdlKFxuICAgICAgc2VuZGVyLFxuICAgICAgcm91dGUsXG4gICAgICBwYXlsb2FkLFxuICAgICAgZW1iZWRzXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kRnJvbUV2ZW50cyhcbiAgICAgIG5hbWUsXG4gICAgICB0b3BpYyxcbiAgICAgIGV4bixcbiAgICAgIHNpZ3MsXG4gICAgICBhdGMsXG4gICAgICByZWNpcGllbnRzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBleG4gbWVzc2FnZXQgdG8gbGlzdCBvZiByZWNpcGllbnRzXG4gICAqIEBhc3luY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIGxpc3Qgb2YgcmVwbGF5IG1lc3NhZ2VzXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSB0b3BpY1xuICAgKiBAcGFyYW0gZXhuXG4gICAqIEBwYXJhbSBzaWdzXG4gICAqIEBwYXJhbSBhdGNcbiAgICogQHBhcmFtIHJlY2lwaWVudHNcbiAgICovXG4gIGFzeW5jIHNlbmRGcm9tRXZlbnRzKG5hbWUsIHRvcGljLCBleG4sIHNpZ3MsIGF0YywgcmVjaXBpZW50cykge1xuICAgIGNvbnN0IHBhdGggPSBgL2lkZW50aWZpZXJzLyR7bmFtZX0vZXhjaGFuZ2VzYDtcbiAgICBjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdHBjOiB0b3BpYyxcbiAgICAgIGV4bjogZXhuLmtlZCxcbiAgICAgIHNpZ3MsXG4gICAgICBhdGMsXG4gICAgICByZWM6IHJlY2lwaWVudHNcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgZGF0YSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBleG4gbWVzc2FnZSBieSBzYWlkXG4gICAqIEBhc3luY1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdG8gdGhlIGV4biBtZXNzYWdlXG4gICAqIEBwYXJhbSBzYWlkIFRoZSBzYWlkIG9mIHRoZSBleG4gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgZ2V0KHNhaWQpIHtcbiAgICBjb25zdCBwYXRoID0gYC9leGNoYW5nZXMvJHtzYWlkfWA7XG4gICAgY29uc3QgbWV0aG9kID0gXCJHRVRcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIG51bGwpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG59O1xuZnVuY3Rpb24gZXhjaGFuZ2Uocm91dGUsIHBheWxvYWQsIHNlbmRlciwgcmVjaXBpZW50LCBkYXRlLCBkaWcsIG1vZGlmaWVycywgZW1iZWRzKSB7XG4gIGNvbnN0IHZzID0gdmVyc2lmeShcIktFUklcIiAvKiBLRVJJICovLCB2b2lkIDAsIFwiSlNPTlwiIC8qIEpTT04gKi8sIDApO1xuICBjb25zdCBpbGsgPSBJbGtzLmV4bjtcbiAgY29uc3QgZHQgPSBkYXRlICE9PSB2b2lkIDAgPyBkYXRlIDogbm93VVRDKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiWlwiLCBcIjAwMCswMDowMFwiKTtcbiAgY29uc3QgcCA9IGRpZyAhPT0gdm9pZCAwID8gZGlnIDogXCJcIjtcbiAgY29uc3QgcSA9IG1vZGlmaWVycyAhPT0gdm9pZCAwID8gbW9kaWZpZXJzIDoge307XG4gIGNvbnN0IGVtcyA9IGVtYmVkcyAhPSB2b2lkIDAgPyBlbWJlZHMgOiB7fTtcbiAgbGV0IGUgPSB7fTtcbiAgbGV0IGVuZCA9IFwiXCI7XG4gIE9iamVjdC5lbnRyaWVzKGVtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3Qgc2VyZGVyID0gdmFsdWVbMF07XG4gICAgY29uc3QgYXRjID0gdmFsdWVbMV07XG4gICAgZVtrZXldID0gc2VyZGVyLmtlZDtcbiAgICBpZiAoYXRjID09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGF0aGVkID0gXCJcIjtcbiAgICBjb25zdCBwYXRoZXIgPSBuZXcgUGF0aGVyKHt9LCB2b2lkIDAsIFtcImVcIiwga2V5XSk7XG4gICAgcGF0aGVkICs9IHBhdGhlci5xYjY0O1xuICAgIHBhdGhlZCArPSBhdGM7XG4gICAgY29uc3QgY291bnRlciA9IG5ldyBDb3VudGVyKHtcbiAgICAgIGNvZGU6IEN0ckRleC5QYXRoZWRNYXRlcmlhbFF1YWRsZXRzLFxuICAgICAgY291bnQ6IE1hdGguZmxvb3IocGF0aGVkLmxlbmd0aCAvIDQpXG4gICAgfSk7XG4gICAgZW5kICs9IGNvdW50ZXIucWI2NDtcbiAgICBlbmQgKz0gcGF0aGVkO1xuICB9KTtcbiAgaWYgKE9iamVjdC5rZXlzKGUpLmxlbmd0aCA+IDApIHtcbiAgICBlW1wiZFwiXSA9IFwiXCI7XG4gICAgWywgZV0gPSBTYWlkZXIuc2FpZGlmeShlKTtcbiAgfVxuICBjb25zdCBhdHRycyA9IHt9O1xuICBpZiAocmVjaXBpZW50ICE9PSB2b2lkIDApIHtcbiAgICBhdHRyc1tcImlcIl0gPSByZWNpcGllbnQ7XG4gIH1cbiAgY29uc3QgYSA9IHtcbiAgICAuLi5hdHRycyxcbiAgICAuLi5wYXlsb2FkXG4gIH07XG4gIGNvbnN0IF9rZWQgPSB7XG4gICAgdjogdnMsXG4gICAgdDogaWxrLFxuICAgIGQ6IFwiXCIsXG4gICAgaTogc2VuZGVyLFxuICAgIHAsXG4gICAgZHQsXG4gICAgcjogcm91dGUsXG4gICAgcSxcbiAgICBhLFxuICAgIGVcbiAgfTtcbiAgY29uc3QgWywga2VkXSA9IFNhaWRlci5zYWlkaWZ5KF9rZWQpO1xuICBjb25zdCBleG4gPSBuZXcgU2VyZGVyKGtlZCk7XG4gIHJldHVybiBbZXhuLCBiKGVuZCldO1xufVxuXG4vLyBzcmMva2VyaS9hcHAvZ3JvdXBpbmcudHNcbnZhciBHcm91cHMgPSBjbGFzcyB7XG4gIGNsaWVudDtcbiAgLyoqXG4gICAqIEdyb3Vwc1xuICAgKiBAcGFyYW0ge1NpZ25pZnlDbGllbnR9IGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBncm91cCByZXF1ZXN0IG1lc3NhZ2VzXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NhaWRdIFNBSUQgb2YgZXhuIG1lc3NhZ2UgdG8gbG9hZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIGxpc3Qgb2YgcmVwbGF5IG1lc3NhZ2VzXG4gICAqL1xuICBhc3luYyBnZXRSZXF1ZXN0KHNhaWQpIHtcbiAgICBjb25zdCBwYXRoID0gYC9tdWx0aXNpZy9yZXF1ZXN0L2AgKyBzYWlkO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZmV0Y2gocGF0aCwgbWV0aG9kLCBudWxsKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBtdWx0aXNpZyBleG4gcmVxdWVzdCAgbWVzc2FnZXMgdG8gb3RoZXIgZ3JvdXAgbWVtYmVyc1xuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSBodW1hbiByZWFkYWJsZSBuYW1lIG9mIGdyb3VwIEFJRFxuICAgKiBAcGFyYW0ge0RpY3Q8YW55Pn0gW2V4bl0gZXhuIG1lc3NhZ2UgdG8gc2VuZCB0byBvdGhlciBtZW1iZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtzaWdzXSBzaWduYXR1cmUgb2YgdGhlIHBhcnRpY2lwYW50IG92ZXIgdGhlIGV4blxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2F0Y10gYWRkaXRpb25hbCBhdHRhY2htZW50cyBmcm9tIGVtYmVkZGVkIGV2ZW50cyBpbiBleG5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsaXN0IG9mIHJlcGxheSBtZXNzYWdlc1xuICAgKi9cbiAgYXN5bmMgc2VuZFJlcXVlc3QobmFtZSwgZXhuLCBzaWdzLCBhdGMpIHtcbiAgICBjb25zdCBwYXRoID0gYC9pZGVudGlmaWVycy8ke25hbWV9L211bHRpc2lnL3JlcXVlc3RgO1xuICAgIGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBleG4sXG4gICAgICBzaWdzLFxuICAgICAgYXRjXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIGRhdGEpO1xuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBKb2luIG11bHRpc2lnIGdyb3VwIHVzaW5nIHJvdGF0aW9uIGV2ZW50LlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGJ5IHBhcnRpY2lwYW50cyBiZWluZyBhc2tlZCB0byBjb250cmlidXRlIGtleXMgdG8gYSByb3RhdGlvbiBldmVudCB0byBqb2luIGFuIGV4aXN0aW5nIGdyb3VwLlxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSBodW1hbiByZWFkYWJsZSBuYW1lIG9mIGdyb3VwIEFJRFxuICAgKiBAcGFyYW0ge2FueX0gW3JvdF0gcm90YXRpb24gZXZlbnRcbiAgICogQHBhcmFtIHthbnl9IFtzaWdzXSBzaWduYXR1cmVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZ2lkXSBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3NtaWRzXSBhcnJheSBvZiBwYXJ0aWNwYW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcm1pZHNdIGFycmF5IG9mIHBhcnRpY3BhbnRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0byB0aGUgbGlzdCBvZiByZXBsYXkgbWVzc2FnZXNcbiAgICovXG4gIGFzeW5jIGpvaW4obmFtZSwgcm90LCBzaWdzLCBnaWQsIHNtaWRzLCBybWlkcykge1xuICAgIGNvbnN0IHBhdGggPSBgL2lkZW50aWZpZXJzLyR7bmFtZX0vbXVsdGlzaWcvam9pbmA7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHRwYzogXCJtdWx0aXNpZ1wiLFxuICAgICAgcm90OiByb3Qua2VkLFxuICAgICAgc2lncyxcbiAgICAgIGdpZCxcbiAgICAgIHNtaWRzLFxuICAgICAgcm1pZHNcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgZGF0YSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2FwcC9ub3RpZnlpbmcudHNcbnZhciBOb3RpZmljYXRpb25zID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBOb3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSB7U2lnbmlmeUNsaWVudH0gY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogTGlzdCBub3RpZmljYXRpb25zXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFN0YXJ0IGluZGV4IG9mIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucywgZGVmYXVsdHMgdG8gMFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD0yNF0gRW5kIGluZGV4IG9mIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucywgZGVmYXVsdHMgdG8gMjRcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRvIHRoZSBsaXN0IG9mIG5vdGlmaWNhdGlvbnNcbiAgICovXG4gIGFzeW5jIGxpc3Qoc3RhcnQgPSAwLCBlbmQgPSAyNCkge1xuICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZXh0cmFIZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBub3Rlcz0ke3N0YXJ0fS0ke2VuZH1gKTtcbiAgICBjb25zdCBwYXRoID0gYC9ub3RpZmljYXRpb25zYDtcbiAgICBjb25zdCBtZXRob2QgPSBcIkdFVFwiO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgbnVsbCwgZXh0cmFIZWFkZXJzKTtcbiAgICBjb25zdCBjciA9IHJlcy5oZWFkZXJzLmdldChcImNvbnRlbnQtcmFuZ2VcIik7XG4gICAgY29uc3QgcmFuZ2UyID0gcGFyc2VSYW5nZUhlYWRlcnMoY3IsIFwibm90ZXNcIik7XG4gICAgY29uc3Qgbm90ZXMgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcmFuZ2UyLnN0YXJ0LFxuICAgICAgZW5kOiByYW5nZTIuZW5kLFxuICAgICAgdG90YWw6IHJhbmdlMi50b3RhbCxcbiAgICAgIG5vdGVzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWFyayBhIG5vdGlmaWNhdGlvbiBhcyByZWFkXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc2FpZCBTQUlEIG9mIHRoZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRvIHRoZSByZXN1bHQgb2YgdGhlIG1hcmtpbmdcbiAgICovXG4gIGFzeW5jIG1hcmsoc2FpZCkge1xuICAgIGNvbnN0IHBhdGggPSBgL25vdGlmaWNhdGlvbnMvYCArIHNhaWQ7XG4gICAgY29uc3QgbWV0aG9kID0gXCJQVVRcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5mZXRjaChwYXRoLCBtZXRob2QsIG51bGwpO1xuICAgIHJldHVybiBhd2FpdCByZXMudGV4dCgpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBub3RpZmljYXRpb25cbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzYWlkIFNBSUQgb2YgdGhlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdCBvZiB0aGUgZGVsZXRpb25cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShzYWlkKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvbm90aWZpY2F0aW9ucy9gICsgc2FpZDtcbiAgICBjb25zdCBtZXRob2QgPSBcIkRFTEVURVwiO1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKHBhdGgsIG1ldGhvZCwgbnVsbCk7XG4gIH1cbn07XG5cbi8vIHNyYy9rZXJpL2FwcC9jbGllbnRpbmcudHNcbnZhciBERUZBVUxUX0JPT1RfVVJMID0gXCJodHRwOi8vbG9jYWxob3N0OjM5MDNcIjtcbnZhciBTdGF0ZSA9IGNsYXNzIHtcbiAgYWdlbnQ7XG4gIGNvbnRyb2xsZXI7XG4gIHJpZHg7XG4gIHBpZHg7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYWdlbnQgPSBudWxsO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5waWR4ID0gMDtcbiAgICB0aGlzLnJpZHggPSAwO1xuICB9XG59O1xudmFyIFNpZ25pZnlDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnRyb2xsZXI7XG4gIHVybDtcbiAgYnJhbjtcbiAgcGlkeDtcbiAgYWdlbnQ7XG4gIGF1dGhuO1xuICBtYW5hZ2VyO1xuICB0aWVyO1xuICBib290VXJsO1xuICBleHRlcmFsTW9kdWxlcztcbiAgLyoqXG4gICAqIFNpZ25pZnlDbGllbnQgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBLRVJJQSBhZG1pbiBpbnRlcmZhY2UgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBicmFuIEJhc2U2NCAyMSBjaGFyIHN0cmluZyB0aGF0IGlzIHVzZWQgYXMgYmFzZSBtYXRlcmlhbCBmb3Igc2VlZCBvZiB0aGUgY2xpZW50IEFJRFxuICAgKiBAcGFyYW0ge1RpZXJ9IHRpZXIgU2VjdXJpdHkgdGllciBmb3IgZ2VuZXJhdGluZyBrZXlzIG9mIHRoZSBjbGllbnQgQUlEIChoaWdoIHwgbWV3ZGl1bSB8IGxvdylcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJvb3RVcmwgS0VSSUEgYm9vdCBpbnRlcmZhY2UgVVJMXG4gICAqIEBwYXJhbSB7RXh0ZXJuYWxNb2R1bGVbXX0gZXh0ZXJuYWxNb2R1bGVzIGxpc3Qgb2YgZXh0ZXJuYWwgbW9kdWxlcyB0byBsb2FkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1cmwsIGJyYW4sIHRpZXIgPSBcImxvd1wiIC8qIGxvdyAqLywgYm9vdFVybCA9IERFRkFVTFRfQk9PVF9VUkwsIGV4dGVybmFsTW9kdWxlcyA9IFtdKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgaWYgKGJyYW4ubGVuZ3RoIDwgMjEpIHtcbiAgICAgIHRocm93IEVycm9yKFwiYnJhbiBtdXN0IGJlIDIxIGNoYXJhY3RlcnNcIik7XG4gICAgfVxuICAgIHRoaXMuYnJhbiA9IGJyYW47XG4gICAgdGhpcy5waWR4ID0gMDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihicmFuLCB0aWVyKTtcbiAgICB0aGlzLmF1dGhuID0gbnVsbDtcbiAgICB0aGlzLmFnZW50ID0gbnVsbDtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMudGllciA9IHRpZXI7XG4gICAgdGhpcy5ib290VXJsID0gYm9vdFVybDtcbiAgICB0aGlzLmV4dGVyYWxNb2R1bGVzID0gZXh0ZXJuYWxNb2R1bGVzO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiBbdGhpcy51cmwsIHRoaXMuYnJhbiwgdGhpcy5waWR4LCB0aGlzLmF1dGhuXTtcbiAgfVxuICAvKipcbiAgICogQm9vdCBhIEtFUklBIGFnZW50XG4gICAqIEBhc3luY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59IEEgcHJvbWlzZSB0byB0aGUgcmVzdWx0IG9mIHRoZSBib290XG4gICAqL1xuICBhc3luYyBib290KCkge1xuICAgIGNvbnN0IFtldnQsIHNpZ25dID0gdGhpcy5jb250cm9sbGVyPy5ldmVudCA/PyBbXTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaWNwOiBldnQua2VkLFxuICAgICAgc2lnOiBzaWduLnFiNjQsXG4gICAgICBzdGVtOiB0aGlzLmNvbnRyb2xsZXI/LnN0ZW0sXG4gICAgICBwaWR4OiAxLFxuICAgICAgdGllcjogdGhpcy5jb250cm9sbGVyPy50aWVyXG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2godGhpcy5ib290VXJsICsgXCIvYm9vdFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzdGF0ZSBvZiB0aGUgYWdlbnQgYW5kIHRoZSBjbGllbnRcbiAgICogQGFzeW5jXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn0gQSBwcm9taXNlIHRvIHRoZSBzdGF0ZVxuICAgKi9cbiAgYXN5bmMgc3RhdGUoKSB7XG4gICAgY29uc3QgY2FpZCA9IHRoaXMuY29udHJvbGxlcj8ucHJlO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHRoaXMudXJsICsgYC9hZ2VudC8ke2NhaWR9YCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT0gNDA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFnZW50IGRvZXMgbm90IGV4aXN0IGZvciBjb250cm9sbGVyICR7Y2FpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBzdGF0ZS5hZ2VudCA9IGRhdGEuYWdlbnQgPz8ge307XG4gICAgc3RhdGUuY29udHJvbGxlciA9IGRhdGEuY29udHJvbGxlciA/PyB7fTtcbiAgICBzdGF0ZS5yaWR4ID0gZGF0YS5yaWR4ID8/IDA7XG4gICAgc3RhdGUucGlkeCA9IGRhdGEucGlkeCA/PyAwO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvKiogIENvbm5lY3QgdG8gYSBLRVJJQSBhZ2VudFxuICAgKiBAYXN5bmNcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLnN0YXRlKCk7XG4gICAgdGhpcy5waWR4ID0gc3RhdGUucGlkeDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihcbiAgICAgIHRoaXMuYnJhbixcbiAgICAgIHRoaXMudGllcixcbiAgICAgIDAsXG4gICAgICBzdGF0ZS5jb250cm9sbGVyXG4gICAgKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIucmlkeCA9IHN0YXRlLnJpZHggIT09IHZvaWQgMCA/IHN0YXRlLnJpZHggOiAwO1xuICAgIHRoaXMuYWdlbnQgPSBuZXcgQWdlbnQoc3RhdGUuYWdlbnQpO1xuICAgIGlmICh0aGlzLmFnZW50LmFuY2hvciAhPSB0aGlzLmNvbnRyb2xsZXIucHJlKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJjb21taXRtZW50IHRvIGNvbnRyb2xsZXIgQUlEIG1pc3NpbmcgaW4gYWdlbnQgaW5jZXB0aW9uIGV2ZW50XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRyb2xsZXIuc2VyZGVyLmtlZC5zID09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuYXBwcm92ZURlbGVnYXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyID0gbmV3IEtleU1hbmFnZXIoXG4gICAgICB0aGlzLmNvbnRyb2xsZXIuc2FsdGVyLFxuICAgICAgdGhpcy5leHRlcmFsTW9kdWxlc1xuICAgICk7XG4gICAgdGhpcy5hdXRobiA9IG5ldyBBdXRoZW50aWNhdGVyKFxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25lcixcbiAgICAgIHRoaXMuYWdlbnQudmVyZmVyXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSByZXNvdXJjZSBmcm9tIHRoZSBLRVJJQSBhZ2VudFxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBIVFRQIG1ldGhvZFxuICAgKiBAcGFyYW0ge2FueX0gZGF0YSBEYXRhIHRvIGJlIHNlbnQgaW4gdGhlIGJvZHkgb2YgdGhlIHJlc291cmNlXG4gICAqIEBwYXJhbSB7SGVhZGVyc30gW2V4dHJhSGVhZGVyc10gT3B0aW9uYWwgZXh0cmEgaGVhZGVycyB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdCBvZiB0aGUgZmV0Y2hcbiAgICovXG4gIGFzeW5jIGZldGNoKHBhdGgsIG1ldGhvZCwgZGF0YSwgZXh0cmFIZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IHNpZ25lZF9oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBjb25zdCBmaW5hbF9oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBoZWFkZXJzLnNldChcIlNpZ25pZnktUmVzb3VyY2VcIiwgdGhpcy5jb250cm9sbGVyLnByZSk7XG4gICAgaGVhZGVycy5zZXQoXG4gICAgICBIRUFERVJfU0lHX1RJTUUsXG4gICAgICAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIlpcIiwgXCIwMDArMDA6MDBcIilcbiAgICApO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICBjb25zdCBfYm9keSA9IG1ldGhvZCA9PSBcIkdFVFwiID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGlmICh0aGlzLmF1dGhuKSB7XG4gICAgICBzaWduZWRfaGVhZGVycyA9IHRoaXMuYXV0aG4uc2lnbihcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXRoLnNwbGl0KFwiP1wiKVswXVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xpZW50IG5lZWQgdG8gY2FsbCBjb25uZWN0IGZpcnN0XCIpO1xuICAgIH1cbiAgICBzaWduZWRfaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBmaW5hbF9oZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICBpZiAoZXh0cmFIZWFkZXJzICE9PSB2b2lkIDApIHtcbiAgICAgIGV4dHJhSGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGZpbmFsX2hlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHRoaXMudXJsICsgcGF0aCwge1xuICAgICAgbWV0aG9kLFxuICAgICAgYm9keTogX2JvZHksXG4gICAgICBoZWFkZXJzOiBmaW5hbF9oZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgSFRUUCAke21ldGhvZH0gJHtwYXRofSAtICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2Vycm9yfWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGlzU2FtZUFnZW50ID0gdGhpcy5hZ2VudD8ucHJlID09PSByZXMuaGVhZGVycy5nZXQoXCJzaWduaWZ5LXJlc291cmNlXCIpO1xuICAgIGlmICghaXNTYW1lQWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UgZnJvbSBhIGRpZmZlcmVudCByZW1vdGUgYWdlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHZlcmlmaWNhdGlvbiA9IHRoaXMuYXV0aG4udmVyaWZ5KFxuICAgICAgcmVzLmhlYWRlcnMsXG4gICAgICBtZXRob2QsXG4gICAgICBwYXRoLnNwbGl0KFwiP1wiKVswXVxuICAgICk7XG4gICAgaWYgKHZlcmlmaWNhdGlvbikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2UgdmVyaWZpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFNpZ25lZCBSZXF1ZXN0IHRvIGZldGNoIGEgcmVzb3VyY2UgZnJvbSBhbiBleHRlcm5hbCBVUkwgd2l0aCBoZWFkZXJzIHNpZ25lZCBieSBhbiBBSURcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhaWROYW1lIE5hbWUgb3IgYWxpYXMgb2YgdGhlIEFJRCB0byBiZSB1c2VkIGZvciBzaWduaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIG9mIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtSZXF1ZXN0SW5pdH0gcmVxIFJlcXVlc3Qgb3B0aW9ucyBzaG91bGQgaW5jbHVkZTpcbiAgICogICAgIC0gbWV0aG9kOiBIVFRQIG1ldGhvZFxuICAgKiAgICAgLSBkYXRhIERhdGEgdG8gYmUgc2VudCBpbiB0aGUgYm9keSBvZiB0aGUgcmVzb3VyY2UuXG4gICAqICAgICAgICAgICAgICBJZiB0aGUgZGF0YSBpcyBhIENFU1IgSlNPTiBzdHJpbmcgdGhlbiB5b3Ugc2hvdWxkIGFsc28gc2V0IGNvbnRlbnRUeXBlIHRvICdhcHBsaWNhdGlvbi9qc29uK2Nlc3InXG4gICAqICAgICAgICAgICAgICBJZiB0aGUgZGF0YSBpcyBhIEZvcm1EYXRhIG9iamVjdCB0aGVuIHlvdSBzaG91bGQgbm90IHNldCB0aGUgY29udGVudFR5cGUgYW5kIHRoZSBicm93c2VyIHdpbGwgc2V0IGl0IHRvICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgKiAgICAgICAgICAgICAgSWYgdGhlIGRhdGEgaXMgYW4gb2JqZWN0IHRoZW4geW91IHNob3VsZCB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29udmVydCBpdCB0byBhIHN0cmluZyBhbmQgc2V0IHRoZSBjb250ZW50VHlwZSB0byAnYXBwbGljYXRpb24vanNvbidcbiAgICogICAgIC0gY29udGVudFR5cGUgQ29udGVudCB0eXBlIG9mIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0Pn0gQSBwcm9taXNlIHRvIHRoZSBjcmVhdGVkIFJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNpZ25lZFJlcXVlc3QoYWlkTmFtZSwgdXJsLCByZXEpIHtcbiAgICBjb25zdCBoYWIgPSBhd2FpdCB0aGlzLmlkZW50aWZpZXJzKCkuZ2V0KGFpZE5hbWUpO1xuICAgIGNvbnN0IGtlZXBlciA9IHRoaXMubWFuYWdlci5nZXQoaGFiKTtcbiAgICBjb25zdCBhdXRoZW50aWNhdG9yID0gbmV3IEF1dGhlbnRpY2F0ZXIoXG4gICAgICBrZWVwZXIuc2lnbmVyc1swXSxcbiAgICAgIGtlZXBlci5zaWduZXJzWzBdLnZlcmZlclxuICAgICk7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcS5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldChcIlNpZ25pZnktUmVzb3VyY2VcIiwgaGFiW1wicHJlZml4XCJdKTtcbiAgICBoZWFkZXJzLnNldChcbiAgICAgIEhFQURFUl9TSUdfVElNRSxcbiAgICAgICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiWlwiLCBcIjAwMCswMDowMFwiKVxuICAgICk7XG4gICAgY29uc3Qgc2lnbmVkX2hlYWRlcnMgPSBhdXRoZW50aWNhdG9yLnNpZ24oXG4gICAgICBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgIHJlcS5tZXRob2QgPz8gXCJHRVRcIixcbiAgICAgIG5ldyBVUkwodXJsKS5wYXRobmFtZVxuICAgICk7XG4gICAgcmVxLmhlYWRlcnMgPSBzaWduZWRfaGVhZGVycztcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCByZXEpO1xuICB9XG4gIC8qKlxuICAgKiBBcHByb3ZlIHRoZSBkZWxlZ2F0aW9uIG9mIHRoZSBjbGllbnQgQUlEIHRvIHRoZSBLRVJJQSBhZ2VudFxuICAgKiBAYXN5bmNcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdCBvZiB0aGUgYXBwcm92YWxcbiAgICovXG4gIGFzeW5jIGFwcHJvdmVEZWxlZ2F0aW9uKCkge1xuICAgIGNvbnN0IHNpZ3MgPSB0aGlzLmNvbnRyb2xsZXIuYXBwcm92ZURlbGVnYXRpb24odGhpcy5hZ2VudCk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGl4bjogdGhpcy5jb250cm9sbGVyLnNlcmRlci5rZWQsXG4gICAgICBzaWdzXG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2goXG4gICAgICB0aGlzLnVybCArIFwiL2FnZW50L1wiICsgdGhpcy5jb250cm9sbGVyLnByZSArIFwiP3R5cGU9aXhuXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2F2ZSBvbGQgY2xpZW50IHBhc3Njb2RlIGluIEtFUklBIGFnZW50XG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc2NvZGUgUGFzc2NvZGUgdG8gYmUgc2F2ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBBIHByb21pc2UgdG8gdGhlIHJlc3VsdCBvZiB0aGUgc2F2ZVxuICAgKi9cbiAgYXN5bmMgc2F2ZU9sZFBhc3Njb2RlKHBhc3Njb2RlKSB7XG4gICAgY29uc3QgY2FpZCA9IHRoaXMuY29udHJvbGxlcj8ucHJlO1xuICAgIGNvbnN0IGJvZHkgPSB7IHNhbHQ6IHBhc3Njb2RlIH07XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHRoaXMudXJsICsgXCIvc2FsdC9cIiArIGNhaWQsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBzYXZlZCBwYXNzY29kZSBmcm9tIEtFUklBIGFnZW50XG4gICAqIEBhc3luY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59IEEgcHJvbWlzZSB0byB0aGUgcmVzdWx0IG9mIHRoZSBkZWxldGlvblxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUGFzc2NvZGUoKSB7XG4gICAgY29uc3QgY2FpZCA9IHRoaXMuY29udHJvbGxlcj8ucHJlO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaCh0aGlzLnVybCArIFwiL3NhbHQvXCIgKyBjYWlkLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgY2xpZW50IEFJRFxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5icmFuIEJhc2U2NCAyMSBjaGFyIHN0cmluZyB0aGF0IGlzIHVzZWQgYXMgYmFzZSBtYXRlcmlhbCBmb3IgdGhlIG5ldyBzZWVkXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWlkcyBMaXN0IG9mIG1hbmFnZWQgQUlEcyB0byBiZSByb3RhdGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn0gQSBwcm9taXNlIHRvIHRoZSByZXN1bHQgb2YgdGhlIHJvdGF0aW9uXG4gICAqL1xuICBhc3luYyByb3RhdGUobmJyYW4sIGFpZHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jb250cm9sbGVyLnJvdGF0ZShuYnJhbiwgYWlkcyk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHRoaXMudXJsICsgXCIvYWdlbnQvXCIgKyB0aGlzLmNvbnRyb2xsZXIucHJlLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGlkZW50aWZpZXJzIHJlc291cmNlXG4gICAqIEByZXR1cm5zIHtJZGVudGlmaWVyfVxuICAgKi9cbiAgaWRlbnRpZmllcnMoKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgT09CSXMgcmVzb3VyY2VcbiAgICogQHJldHVybnMge09vYmlzfVxuICAgKi9cbiAgb29iaXMoKSB7XG4gICAgcmV0dXJuIG5ldyBPb2Jpcyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG9wZXJhdGlvbnMgcmVzb3VyY2VcbiAgICogQHJldHVybnMge09wZXJhdGlvbnN9XG4gICAqL1xuICBvcGVyYXRpb25zKCkge1xuICAgIHJldHVybiBuZXcgT3BlcmF0aW9ucyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGtleUV2ZW50cyByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7S2V5RXZlbnRzfVxuICAgKi9cbiAga2V5RXZlbnRzKCkge1xuICAgIHJldHVybiBuZXcgS2V5RXZlbnRzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQga2V5U3RhdGVzIHJlc291cmNlXG4gICAqIEByZXR1cm5zIHtLZXlTdGF0ZXN9XG4gICAqL1xuICBrZXlTdGF0ZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlTdGF0ZXModGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjcmVkZW50aWFscyByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7Q3JlZGVudGlhbHN9XG4gICAqL1xuICBjcmVkZW50aWFscygpIHtcbiAgICByZXR1cm4gbmV3IENyZWRlbnRpYWxzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgSVBFWCByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7SXBleH1cbiAgICovXG4gIGlwZXgoKSB7XG4gICAgcmV0dXJuIG5ldyBJcGV4KHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcmVnaXN0cmllcyByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7UmVnaXN0cmllc31cbiAgICovXG4gIHJlZ2lzdHJpZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpc3RyaWVzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc2NoZW1hcyByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7U2NoZW1hc31cbiAgICovXG4gIHNjaGVtYXMoKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlbWFzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY2hhbGxlbmdlcyByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7Q2hhbGxlbmdlc31cbiAgICovXG4gIGNoYWxsZW5nZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBDaGFsbGVuZ2VzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY29udGFjdHMgcmVzb3VyY2VcbiAgICogQHJldHVybnMge0NvbnRhY3RzfVxuICAgKi9cbiAgY29udGFjdHMoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250YWN0cyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG5vdGlmaWNhdGlvbnMgcmVzb3VyY2VcbiAgICogQHJldHVybnMge05vdGlmaWNhdGlvbnN9XG4gICAqL1xuICBub3RpZmljYXRpb25zKCkge1xuICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9ucyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGVzY3Jvd3MgcmVzb3VyY2VcbiAgICogQHJldHVybnMge0VzY3Jvd3N9XG4gICAqL1xuICBlc2Nyb3dzKCkge1xuICAgIHJldHVybiBuZXcgRXNjcm93cyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGdyb3VwcyByZXNvdXJjZVxuICAgKiBAcmV0dXJucyB7R3JvdXBzfVxuICAgKi9cbiAgZ3JvdXBzKCkge1xuICAgIHJldHVybiBuZXcgR3JvdXBzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZXhjaGFuZ2UgcmVzb3VyY2VcbiAgICogQHJldHVybnMge0V4Y2hhbmdlc31cbiAgICovXG4gIGV4Y2hhbmdlcygpIHtcbiAgICByZXR1cm4gbmV3IEV4Y2hhbmdlcyh0aGlzKTtcbiAgfVxufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2RlZmF1bHQgPSBleHBvcnRzX2V4cG9ydHM7XG5leHBvcnQge1xuICBBZ2VudCxcbiAgQWxnb3MsXG4gIEF1dGhlbnRpY2F0ZXIsXG4gIEI2NENockJ5SWR4LFxuICBCNjRJZHhCeUNocixcbiAgQmV4Q29kZXgsXG4gIEJleERleCxcbiAgQ2Vzck51bWJlcixcbiAgQ2hhbGxlbmdlcyxcbiAgQ2lnYXIsXG4gIENpcGhlcixcbiAgQ29kZXgsXG4gIENvbnRhY3RzLFxuICBDb250cm9sbGVyLFxuICBDb3VudGVyLFxuICBDb3VudGVyQ29kZXgsXG4gIENyZWF0b3J5LFxuICBDcmVkZW50aWFsVHlwZXMsXG4gIENyZWRlbnRpYWxzLFxuICBDdHJEZXgsXG4gIERlY3J5cHRlcixcbiAgRGlnZXIsXG4gIERpZ2lDb2RleCxcbiAgRGlnaURleCxcbiAgRGlwTGFiZWxzLFxuICBEcnRMYWJlbHMsXG4gIEVtcHR5TWF0ZXJpYWxFcnJvcixcbiAgRW5jcnlwdGVyLFxuICBFc2Nyb3dzLFxuICBFdmVudFJlc3VsdCxcbiAgRXhjaGFuZ2VzLFxuICBGQUxTWSxcbiAgR3JvdXBLZWVwZXIsXG4gIEdyb3VwcyxcbiAgSEVBREVSX1NJR19JTlBVVCxcbiAgSEVBREVSX1NJR19USU1FLFxuICBIYWIsXG4gIEhhYmVyeSxcbiAgSWNwTGFiZWxzLFxuICBJZGVudCxcbiAgSWRlbnRpZmllcixcbiAgSWRyRGV4LFxuICBJZHMsXG4gIElkeEJ0aFNpZ0RleCxcbiAgSWR4Q3J0U2lnRGV4LFxuICBJZHhTaWdEZXgsXG4gIElsa3MsXG4gIEluZGV4ZWRCb3RoU2lnQ29kZXgsXG4gIEluZGV4ZWRDdXJyZW50U2lnQ29kZXgsXG4gIEluZGV4ZWRTaWdDb2RleCxcbiAgSW5kZXhlcixcbiAgSW5kZXhlckNvZGV4LFxuICBJbnB1dGFnZSxcbiAgSXBleCxcbiAgSXhuTGFiZWxzLFxuICBLZXlFdmVudHMsXG4gIEtleU1hbmFnZXIsXG4gIEtleVN0YXRlcyxcbiAgS3NuTGFiZWxzLFxuICBMYXJnZVZyekRleCxcbiAgTUlOU0lHU0laRSxcbiAgTUlOU05JRkZTSVpFLFxuICBNYW5hZ2VyLFxuICBNYXR0ZXIsXG4gIE1hdHRlckNvZGV4LFxuICBNdHJEZXgsXG4gIE5vblRyYW5zQ29kZXgsXG4gIE5vblRyYW5zRGV4LFxuICBOb3RpZmljYXRpb25zLFxuICBOdW1Db2RleCxcbiAgTnVtRGV4LFxuICBPb2JpcyxcbiAgT3BlcmF0aW9ucyxcbiAgUHJlZml4ZXIsXG4gIFJhbmR5Q3JlYXRvcixcbiAgUmFuZHlLZWVwZXIsXG4gIFJlZ2lzdHJpZXMsXG4gIFJlZ2lzdHJ5UmVzdWx0LFxuICBSb3RMYWJlbHMsXG4gIFJweUxhYmVscyxcbiAgU2FpZGVyLFxuICBTYWx0ZXIsXG4gIFNhbHR5Q3JlYXRvcixcbiAgU2FsdHlLZWVwZXIsXG4gIFNjaGVtYXMsXG4gIFNlcW5lcixcbiAgU2VyZGVyLFxuICBTZXJpYWxzLFxuICBTaWdlcixcbiAgU2lnbmFnZSxcbiAgU2lnbmVyLFxuICBTaWduaWZ5Q2xpZW50LFxuICBTaXphZ2UsXG4gIFNtYWxsVnJ6RGV4LFxuICBUUlVUSFksXG4gIFRob2xkZXIsXG4gIFRpZXIsXG4gIFRyYWl0Q29kZXgsXG4gIFRyYWl0RGV4LFxuICBVbnF1YWxpZmllZCxcbiAgVkVSRVgsXG4gIFZFUkZVTExTSVpFLFxuICBWZXJmZXIsXG4gIFZlcnNpb24sXG4gIFZlcnNpb25hZ2UsXG4gIFhpemFnZSxcbiAgYW1wbGUsXG4gIGFycmF5RXF1YWxzLFxuICBiLFxuICBiNjRUb0ludCxcbiAgYnl0ZXNUb0ludCxcbiAgY29uY2F0LFxuICBkLFxuICBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBkZXNpZ2lucHV0LFxuICBkZXNpZ25hdHVyZSxcbiAgZGV2ZXJzaWZ5LFxuICBkdW1wcyxcbiAgZXhjaGFuZ2UsXG4gIGV4dHJhY3RWYWx1ZXMsXG4gIGluY2VwdCxcbiAgaW50VG9CNjQsXG4gIGludFRvQjY0YixcbiAgaW50VG9CeXRlcyxcbiAgaW50ZXJhY3QsXG4gIG1lc3NhZ2l6ZSxcbiAgbm9ybWFsaXplLFxuICBub3dVVEMsXG4gIG9wZW5NYW5hZ2VyLFxuICBwYWQsXG4gIHBhcnNlUmFuZ2VIZWFkZXJzLFxuICByYW5kb21Ob25jZSxcbiAgcmFuZG9tUGFzc2NvZGUsXG4gIHJhbmdlLFxuICByZWFkSW50LFxuICByZWFkeSxcbiAgcmVwbHksXG4gIHJpS2V5LFxuICByb3RhdGUsXG4gIHNlcmlhbGl6ZUFDRENBdHRhY2htZW50LFxuICBzZXJpYWxpemVJc3NFeG5BdHRhY2htZW50LFxuICBzaWdpbnB1dCxcbiAgc2lnbmF0dXJlLFxuICBzaXplaWZ5LFxuICB2ZXJzaWZ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmlmeS10cy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/signify-ts/dist/signify-ts.mjs\n");

/***/ })

};
;